export const bondPricingFundamentalsQuiz = [
  {
    id: 'bpf-q-1',
    question:
      "Design a production-grade bond pricing engine that handles: (1) Multiple bond types (fixed-rate, zero-coupon, floating-rate), (2) All major day count conventions (30/360, Actual/365, Actual/Actual, Actual/360), (3) Accrued interest calculations for trades between coupon dates, (4) Clean vs dirty price calculations, (5) Yield-to-maturity calculation using Newton-Raphson with convergence validation, (6) Price sensitivity analysis (what-if scenarios for yield changes). Requirements: Type-safe Python with dataclasses, error handling for invalid inputs (negative yields, past maturity dates, invalid day counts), caching for performance (same bond + yield → cached price), logging for audit trail, unit tests with edge cases. How do you handle: bonds trading ex-dividend (buyer doesn't get next coupon)? Bonds with irregular first/last coupon periods? Day count adjustments for holidays? Performance optimization for pricing 10,000+ bonds simultaneously?",
    sampleAnswer:
      "Bond pricing engine architecture: Core design: Use dataclass for Bond definition (face_value, coupon_rate, maturity_date, frequency, day_count_convention, first_coupon_date, issue_date), separate Pricer class with caching (functools.lru_cache on price() method), Day count module: Implement DayCountCalculator with factory pattern (DayCountCalculator.create(convention_type) returns specific calculator: Thirty360Calculator, Actual365Calculator, ActualActualCalculator), each implements calculate_factor(start_date, end_date) -> float, handle holidays using business day calendar (python-holidays library), Pricing logic: price(bond, settlement_date, ytm) calculates: (1) Determine actual coupon dates considering irregular periods (if first_coupon_date != expected from issue_date, adjust first period), (2) Calculate cash flows for each period using day count convention, (3) Discount each cash flow: PV = CF / (1 + ytm/freq)^t where t = actual_factor from day_count, (4) Sum to get clean price, Accrued interest: if trading between coupons, accrued = coupon × (days_since_last_coupon / days_in_period) using convention, check if ex-dividend: if settlement_date > (next_coupon_date - ex_div_days), buyer doesn't get next coupon so exclude from calculation, dirty_price = clean_price + accrued_interest, YTM calculation: Newton-Raphson iteration: ytm_new = ytm_old - f(ytm) / f'(ytm) where f(ytm) = price(ytm) - market_price, f'(ytm) ≈ (price(ytm+δ) - price(ytm)) / δ (numerical derivative), convergence check: |f(ytm)| < tolerance (1e-6) or max 100 iterations, handle edge cases: if ytm < 0, clip to 0.0001 (negative yields possible in some markets but unusual), if not converged, try bisection method as fallback, Performance optimization: Vectorize using numpy for batch pricing: cash_flows_matrix (10000 bonds × max_periods), discount_factors = 1 / (1 + ytm_vector / freq) ** periods_matrix, prices = (cash_flows_matrix × discount_factors).sum(axis=1), cache recently priced bonds: @lru_cache(maxsize=10000) on (bond_id, settlement_date, ytm) tuple, for streaming prices, use incremental updates (only recalculate if yield or settlement date changes), Edge cases: Ex-dividend: flag on bond.is_ex_dividend(settlement_date) checks if settlement > (next_coupon - 5 business days), exclude next coupon from PV calculation, Irregular periods: first coupon might be short/long period, calculate first_period_factor = day_count(issue_date, first_coupon_date) / day_count(typical_period), adjust first cash flow accordingly, Holidays: use pd.offsets.BDay() for business day adjustments, if coupon date falls on holiday, roll to next business day (or previous, depending on convention), Error handling: validate inputs with Pydantic models, raise ValueError for: face_value <= 0, coupon_rate < 0 or > 1, maturity_date < settlement_date, log all pricing requests: logger.info(f\"Pricing {bond.id}: settlement={date}, ytm={ytm:.4f}\"), Testing: unit tests for each day count convention (compare to known Bloomberg values), edge case tests: zero-coupon bonds, bonds at par/premium/discount, bonds with one day to maturity, stress tests: price 10K bonds in <1 second (target), API design: expose REST endpoint POST /bonds/price with JSON body: {bond_id, settlement_date, ytm}, return {clean_price, dirty_price, accrued_interest, duration, convexity}.",
    keyPoints: [
      'Dataclass for Bond (face_value, coupon_rate, maturity, frequency, day_count), separate Pricer class with @lru_cache for performance',
      'Day count factory pattern: DayCountCalculator.create(type) returns Thirty360/Actual365/ActualActual with calculate_factor() method',
      'Accrued interest: coupon × (days_since_last / days_in_period), handle ex-dividend (if settlement > coupon_date-5 days, exclude coupon)',
      'YTM Newton-Raphson: ytm_new = ytm_old - (price(ytm) - market_price) / numerical_derivative, fallback to bisection if not converged',
      'Performance: Vectorize with numpy (10K bonds in matrix), cache with lru_cache(10000), incremental updates only when inputs change',
    ],
  },
  {
    id: 'bpf-q-2',
    question:
      'Build an accrued interest calculation system for a bond trading platform that: (1) Calculates accrued interest for any settlement date between coupon payments, (2) Handles all day count conventions correctly (30/360 has special end-of-month rules, Actual/Actual varies by period), (3) Supports irregular coupon periods (first short/long coupon, last short coupon), (4) Implements ex-dividend trading (settlement date determines if buyer receives next coupon), (5) Provides breakdown showing: days accrued, days in period, coupon amount, accrued amount, next coupon date. Include validation: settlement date not before issue date, settlement not after maturity, proper business day adjustments. How do you handle: month-end rule for 30/360 (Feb 28 → 30)? Leap year adjustments for Actual/Actual? Payment delay if coupon date is holiday? Testing against Bloomberg reference values?',
    sampleAnswer:
      'Accrued interest system architecture: Core AccruedInterestCalculator class with methods: calculate(bond, settlement_date, last_coupon_date, next_coupon_date) -> AccruedInterestResult (dataclass with: accrued_amount, days_accrued, days_in_period, next_coupon_date, ex_dividend_flag, day_count_method), Day count implementations: (1) 30/360 US (NASD): Handle end-of-month rule: if d1 = 31, set d1 = 30, if d2 = 31 and d1 = 30 or 31, set d2 = 30, if d1 = Feb-end (28 or 29), set d1 = 30, if d2 = Feb-end and d1 = Feb-end, set d2 = 30, Calculate: days = 360×(y2-y1) + 30×(m2-m1) + (d2-d1), day_factor = days / 360, (2) Actual/365 Fixed: actual_days = (end_date - start_date).days, day_factor = actual_days / 365 (always 365, even leap years), (3) Actual/Actual ICMA: For coupon period: days_in_period = actual days between coupon dates, day_factor = actual_days_accrued / days_in_period (most accurate), handles leap years naturally, (4) Actual/360: actual_days / 360 (used for some money market instruments), Irregular period handling: First coupon short: if first_coupon_date - issue_date < normal_period, calculate: short_period_factor = actual_days / normal_days, accrued for short period prorated, First coupon long: if first_coupon_date - issue_date > normal_period, treat as multiple periods: num_periods = days / normal_period_days, accrued accumulates over all sub-periods, Last coupon short: similar logic for maturity_date - last_coupon < normal_period, Ex-dividend logic: Define ex_dividend_days (typically 5 business days for US bonds, 1 business day for UK gilts), if settlement_date >= (next_coupon_date - ex_dividend_days), ex_dividend = True, buyer does NOT receive next coupon, accrued interest still owed up to ex-dividend date (not settlement), accrued = calculate_accrued(last_coupon_date, ex_dividend_date) [not next_coupon_date], Business day adjustment: if next_coupon_date is holiday, apply convention: "following" = next business day, "modified following" = next business day unless crosses month, then previous, "previous" = previous business day, use numpy.is_busday(date, holidays=us_federal_holidays) for checking, Validation: assert settlement_date >= issue_date, "Cannot settle before issue", assert settlement_date <= maturity_date, "Cannot settle after maturity", assert last_coupon_date < settlement_date < next_coupon_date, "Settlement must be between coupons", if settlement_date == next_coupon_date, accrued = 0 (paid in full), Breakdown calculation: days_accrued = day_count_factor(last_coupon_date, settlement_date, convention), days_in_period = day_count_factor(last_coupon_date, next_coupon_date, convention), accrued_fraction = days_accrued / days_in_period, accrued_amount = coupon_payment × accrued_fraction, return AccruedInterestResult with all fields for transparency, Testing strategy: Reference data: Download Bloomberg sample bonds with known accrued interest, compare our calculations to Bloomberg (tolerance ±$0.01), Edge cases: Test on Feb 28/29 with 30/360 (month-end rules), Test leap year Feb 29 with Actual/Actual, Test holiday coupon dates (July 4 coupon → July 5), Test ex-dividend (settlement 4 days before coupon vs 6 days before), Test irregular first coupon (3-month period vs 6-month standard), Performance: Batch calculation for portfolio (calculate accrued for 1000 bonds at once), cache day count factors for common periods (6 months = 181 days, etc.), API design: POST /bonds/{bond_id}/accrued with {settlement_date}, return {accrued_amount, days_accrued, days_in_period, calculation_method, ex_dividend, clean_price, dirty_price}, Example: bond with 5% coupon semi-annual, last coupon Jun 15, settlement Aug 20, next coupon Dec 15: days_accrued = 66 days (actual), days_in_period = 183 days, accrued_fraction = 66/183 = 0.3607, accrued_amount = $25 × 0.3607 = $9.02.',
    keyPoints: [
      'Day count conventions: 30/360 with month-end rules (Feb 28→30, d1=31→30), Actual/365 fixed, Actual/Actual ICMA (most accurate for coupons)',
      'Irregular periods: First coupon short/long (prorate using actual_days / normal_days), last coupon short, handle as multiple sub-periods if needed',
      "Ex-dividend: If settlement >= (next_coupon - ex_div_days), buyer doesn't get coupon, accrued calculated to ex-div date not settlement",
      'Business day adjustment: If coupon date is holiday, apply "following" or "modified following" rule, use numpy.is_busday() for validation',
      'Testing: Compare to Bloomberg reference values (±$0.01 tolerance), test edge cases (leap year, month-end, holidays, irregular periods)',
    ],
  },
  {
    id: 'bpf-q-3',
    question:
      'Implement a yield-to-maturity (YTM) calculator that: (1) Uses Newton-Raphson method for fast convergence, (2) Falls back to bisection method if Newton-Raphson diverges, (3) Handles edge cases (negative yields in some markets, zero-coupon bonds, bonds near maturity with <1 payment left, perpetual bonds), (4) Provides convergence diagnostics (iterations taken, final error, method used), (5) Validates output (YTM should be reasonable: typically -5% to +50%). Requirements: Start with intelligent initial guess (current yield for coupon bonds, discount rate for zeros), numerical derivative calculation for Newton-Raphson, bracketing for bisection method, maximum iteration limits (100 for Newton, 50 for bisection), tolerance levels (1e-6 for price convergence). How do you handle: callable bonds (YTM vs YTC)? Negative market prices (theoretical but important edge case)? Very long maturity (30+ years where precision matters)? Real-time requirements (calculate YTM for 1000 bonds in <1 second)?',
    sampleAnswer:
      'YTM calculator implementation: Core YieldCalculator class with method: calculate_ytm(bond, market_price, method="auto") -> YieldResult (ytm, iterations, method_used, final_error, converged), Initial guess strategy: For coupon bonds: Start with current_yield = annual_coupon / market_price, Adjust for premium/discount: if market_price > face_value (premium), ytm_guess = current_yield × 0.9 (YTM < current yield), if market_price < face_value (discount), ytm_guess = current_yield × 1.1 (YTM > current yield), For zero-coupon: ytm_guess = (face_value / market_price) ** (1 / years_to_maturity) - 1 (direct formula), For bonds near maturity (<1 year): ytm_guess = (face_value + next_coupon - market_price) / market_price (simple approximation), Newton-Raphson method: Iteration: ytm_new = ytm_old - f(ytm_old) / f\'(ytm_old), where f(ytm) = price(ytm) - market_price (function to find root of), f\'(ytm) = numerical derivative ≈ (price(ytm + δ) - price(ytm)) / δ with δ = 1e-6, Convergence check: if |f(ytm)| < tolerance (1e-6) and |ytm_new - ytm_old| < 1e-8, converged, Safeguards: if derivative too small (|f\'| < 1e-10), switch to bisection, if ytm goes negative in markets where not allowed, clip to 0.0001, if ytm > 1.0 (100%), something wrong, try bisection, max 100 iterations, Bisection fallback: Initialize brackets: ytm_low = -0.05 (allow negative yields), ytm_high = 0.50 (cap at 50%), Find initial bracket: ensure price(ytm_low) > market_price and price(ytm_high) < market_price (or vice versa), Iterate: ytm_mid = (ytm_low + ytm_high) / 2, price_mid = price(ytm_mid), if |price_mid - market_price| < tolerance, return ytm_mid, else if price_mid > market_price, ytm_low = ytm_mid (need higher yield), else ytm_high = ytm_mid (need lower yield), Converges in log(n) iterations (max 50 for bisection), Edge cases: Zero-coupon bonds: Only one cash flow, YTM = (FV/Price)^(1/t) - 1 (direct formula, no iteration needed), Negative yields: Some government bonds (Japan, Switzerland) trade at negative yields, allow ytm_low = -0.10 in bisection, verify price > face_value (premium), Bonds near maturity: If <30 days to maturity, use simple approximation: ytm ≈ (total_cash_flow - market_price) / market_price / (days/365), only one coupon payment left, precision less critical, Perpetual bonds (consols): No maturity, only coupon payments forever, yield = annual_coupon / market_price (current yield, no iteration needed), Callable bonds: Calculate two yields: YTM = yield to maturity assuming not called, YTC = yield to call (assuming called at first call date), Convention: Quote the lower of YTM and YTC (worst case for investor), Validation: After convergence, verify: -0.10 < ytm < 1.0 (reasonable range), Recalculate price using computed YTM, should match market_price within tolerance, If fails validation, log warning and return with converged=False flag, Performance optimization: For batch calculation: vectorize using numpy: ytm_guesses = calculate_initial_guesses(bonds, market_prices), iterate all bonds simultaneously: ytm_new = ytm_old - f_vector / f_prime_vector, Check convergence per bond, remove converged bonds from iteration, Cache price calculations: if pricing same bond at similar yields, cache results, Target: 1000 bonds in <1 second (1ms per bond), achieved through vectorization, Real-time streaming: For live market data, maintain running YTM: Only recalculate if |price_change| > threshold (e.g., $0.10), Use previous YTM as initial guess for Newton-Raphson (usually converges in 1-2 iterations), Diagnostics: YieldResult includes: ytm: calculated yield, iterations: number of iterations taken, method_used: "newton-raphson" or "bisection", final_error: |price(ytm) - market_price|, converged: True/False, duration_seconds: time taken, API design: POST /bonds/{bond_id}/ytm with {market_price, precision}, return YieldResult JSON, GET /bonds/batch-ytm with array of {bond_id, market_price}, returns array of YieldResults, Example walkthrough: 10-year bond, 5% coupon, market price $982.14: Initial guess: current_yield = $50 / $982.14 = 5.09%, Since discount (price < $1000), guess = 5.09% × 1.1 = 5.60%, Newton iteration 1: price(5.60%) = $963.85, f = $963.85 - $982.14 = -$18.29, derivative ≈ -$17.85 per 1%, ytm_new = 5.60% - (-$18.29/-$17.85) = 5.60% - 1.02% = 4.58%, Iteration 2: price(4.58%) = $983.10, f = $0.96, ytm_new = 4.58% - ($0.96/-$17.85) = 4.53%, Iteration 3: price(4.53%) = $982.08, f = -$0.06, converged (error < $0.10), Final YTM = 4.53%, iterations = 3, method = "newton-raphson".',
    keyPoints: [
      'Initial guess: current_yield for coupon bonds (adjust for premium/discount), (FV/Price)^(1/t)-1 for zeros, previous YTM for streaming',
      "Newton-Raphson: ytm_new = ytm_old - f(ytm) / f'(ytm), f = price(ytm) - market_price, f' = numerical derivative with δ=1e-6",
      'Bisection fallback: Bracket [-5%, 50%], iterate ytm_mid = (low+high)/2, adjust bracket based on price comparison, log(n) convergence',
      'Edge cases: Zero-coupon direct formula, negative yields (allow ytm < 0), near maturity (<30d use simple approx), callable bonds (min of YTM/YTC)',
      'Performance: Vectorize with numpy for batch (1000 bonds in <1s), cache price calculations, incremental updates for streaming (reuse previous YTM)',
    ],
  },
];
