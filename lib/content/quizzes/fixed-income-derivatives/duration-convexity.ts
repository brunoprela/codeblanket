export const durationConvexityQuiz = [
  {
    id: 'dc-q-1',
    question:
      'Design a portfolio immunization system for a pension fund with: (1) Calculate liability duration from projected benefit payments (cash flows over 30 years), (2) Build bond portfolio matching liability duration using Treasuries, (3) Implement rebalancing algorithm (trigger when duration drift >0.25 years), (4) Monitor funded status (asset PV / liability PV), (5) Generate alerts when immunization breaks down, (6) Support multiple liability streams (different pension cohorts). Requirements: Handle cash flow timing (monthly benefit payments), discount curves (spot rates for PV calculation), convexity matching (not just duration), transaction costs in rebalancing (minimize turnover), performance (calculate portfolio duration for 1000+ bonds in <1 second). How do you handle: non-parallel yield curve shifts (steepening/flattening breaks immunization)? Convexity mismatch (positive convexity good but expensive)? Reinvestment risk (coupon payments need reinvesting)? Credit risk (corporate bonds cheaper but add risk)?',
    sampleAnswer:
      'Pension immunization system architecture: Liability modeling: Schema: liabilities (cohort_id, payment_date, amount, discount_rate), Project monthly benefit payments for 30 years, Calculate PV of each payment: PV_t = CF_t / (1 + s_t)^t using spot rate s_t, Liability duration: D_L = Σ(t × PV_t) / Σ(PV_t), weighted average time, Store: total_liability_PV, liability_duration, liability_convexity, Asset portfolio construction: Objective: Match D_portfolio = D_liability ± 0.25 years (tolerance), Constraints: Use only Treasuries (no credit risk), Budget constraint: Σ(price_i × quantity_i) ≤ total_assets, Duration constraint: Σ(w_i × D_i) = D_target where w_i = market_value_i / total, Convexity matching: Prefer assets with convexity close to liability convexity (reduces key rate risk), Optimization: Mixed-integer linear program (MILP) using scipy.optimize or Gurobi, Variables: quantity of each bond to purchase, Minimize: transaction_costs + deviation_from_target_duration, Solver: Branch and bound for discrete quantities (round lots), Portfolio duration calculation: For each bond: modified_duration_i = macaulay_duration_i / (1 + ytm_i / freq), Portfolio_duration = Σ(MV_i / Total_MV × D_i), Performance: Vectorize using numpy: durations_vector, mv_weights_vector, portfolio_duration = np.dot(mv_weights, durations), Cache bond durations (update only when yields change), Target: 1000 bonds in <1 second (1ms per bond), Rebalancing algorithm: Schedule: Calculate daily after market close (4pm ET), Check duration drift: current_port_duration - target_duration, If |drift| > 0.25 years, trigger rebalance, Rebalance strategy: Calculate gap: duration_gap = target - current, If gap > 0 (need more duration): Buy longer bonds, sell shorter bonds, If gap < 0: Opposite, Trade sizing: DV01_gap = duration_gap × portfolio_value × 0.0001, Select bonds to trade: minimize transaction costs (liquidity, bid-ask), Execute trades (send to OMS - Order Management System), Transaction cost modeling: Bid-ask spread: Typically 1-5 basis points for Treasuries, 10-20bp for corporates, Commission: Minimal for institutional ($0.25 per $1000), Market impact: Large trades (>$10M) may move market, estimate 2-10bp slippage, Total cost = spread/2 + commission + slippage, Minimize turnover: Only rebalance when drift > threshold, prefer swaps (simultaneously buy/sell) over separate trades, Non-parallel shifts handling: Key rate durations: Measure sensitivity to specific maturity buckets (2yr, 5yr, 10yr, 30yr), Portfolio KRDs: Σ(w_i × KRD_i,j) for each maturity bucket j, Match both: Overall duration AND key rate durations to liabilities, Steepening scenario: If curve steepens (long rates rise more), short duration bonds outperform, Match KRD distribution to protect against this, Tool: PCA (Principal Component Analysis) on historical curve changes, first 3 components explain 99% of variance, Convexity matching: Liabilities typically have low convexity (fixed payments), Assets (bonds) have positive convexity = good (asymmetric benefit), But higher convexity bonds more expensive (lower yield), Trade-off: Match convexity within 10% of liability convexity, Monitor convexity gap: C_assets - C_liabilities, if large, add/remove long-duration bonds, Reinvestment risk: Coupon payments create cash that must be reinvested, Strategy: Ladder maturities (bonds maturing each quarter), reinvest at current rates, Alternatively: Use zero-coupon bonds (no coupons = no reinvestment risk), STRIPS (Separate Trading of Registered Interest and Principal), Monitor reinvestment rate vs assumed rate, if diverges >50bp, adjust, Credit risk consideration: Investment grade corporates yield 50-200bp more than Treasuries, Tempting for higher returns but adds credit risk (defaults reduce asset value), Policy decision: Pension boards typically mandate Treasuries-only for immunization, If corporates allowed: Add credit spread duration to model, diversify issuers (max 5% per issuer), Funded status monitoring: Calculate daily: Funded_ratio = PV(assets) / PV(liabilities), Target: 100% funded (assets = liabilities), Alert thresholds: <95% = warning (need contributions), <90% = critical (regulatory issue), >110% = overfunded (can reduce contributions or improve benefits), Dashboard metrics: Funded ratio, duration gap, convexity gap, rebalance triggers, API design: GET /pension/liabilities returns {total_pv, duration, convexity, cash_flows}, GET /pension/assets returns {total_mv, duration, dv01, convexity, positions}, POST /pension/rebalance with {target_duration} returns trade recommendations, GET /pension/funded-status returns current ratio and historical trend.',
    keyPoints: [
      'Liability duration: Calculate from projected payments, D_L = Σ(t × PV_t) / Σ(PV_t), use spot rates for discounting, store total PV and duration',
      'Asset portfolio: Optimize Σ(w_i × D_i) = D_target ± 0.25yr tolerance, minimize transaction costs, use Treasuries (no credit risk), match convexity within 10%',
      'Rebalancing: Daily check, trigger if |drift| > 0.25yr, calculate DV01_gap, select trades minimizing costs (bid-ask + commissions + slippage), execute swaps',
      'Non-parallel shifts: Calculate key rate durations (2/5/10/30yr buckets), match KRD distribution to liabilities, use PCA for curve risk, protect steepening/flattening',
      'Performance: Vectorize with numpy (1000 bonds <1s), cache durations, monitor funded ratio daily, alert <95% (warning) or <90% (critical)',
    ],
  },
  {
    id: 'dc-q-2',
    question:
      'Build a duration-convexity-based hedging system for a bond portfolio that: (1) Calculates portfolio Greeks (modified duration, DV01, convexity) by aggregating individual positions, (2) Recommends hedge positions to achieve target Greeks (e.g., duration-neutral, convexity-optimized), (3) Handles multiple hedge instruments (Treasuries, Treasury futures, interest rate swaps), (4) Optimizes hedge efficiency (minimize cost, minimize tracking error), (5) Rebalances dynamically as market moves. Include: delta-hedging (daily rebalance for duration neutrality), gamma hedging (convexity matching), cross-hedging (using different instruments), basis risk measurement (imperfect correlation). How do you handle: futures basis (futures price != spot price due to cost of carry)? Convexity of swaps (swaps have near-zero convexity, bonds positive)? Hedge ratio calculation (quantity of hedge instrument needed)? Real-time requirements (calculate and execute hedges within minutes of market moves)?',
    sampleAnswer:
      'Duration-convexity hedging system: Portfolio Greeks calculation: For each position i: modified_duration_i from bond pricer, DV01_i = mod_duration_i × price_i × quantity_i × 0.0001, convexity_i from bond pricer, Portfolio aggregation: Total_DV01 = Σ(DV01_i), Portfolio_duration = Σ(MV_i × D_i) / Total_MV, Portfolio_convexity = Σ(MV_i × C_i) / Total_MV, Store in real-time cache (Redis), update on every trade or price change, Target Greeks: User specifies targets: target_duration (e.g., 0 for neutral, 5 for positioning), target_convexity (e.g., maximize positive convexity), target_dv01 (e.g., 0 for hedged), Calculate gaps: duration_gap = target - current, dv01_gap = target - current, convexity_gap = target - current, Hedge instruments: Treasury bonds: Liquid, positive convexity, expensive (low yield), Fetch available bonds (2yr, 5yr, 10yr, 30yr), calculate their durations, Treasury futures: Highly liquid, leverage (5-10x notional), slight basis risk, Contract specs: 10yr note future (notional $100k, duration ~8), convexity ~100, Basis = Futures_price - Spot_price × Conversion_factor, typically 10-50bp, Interest rate swaps: Zero upfront cost, near-zero convexity (different from bonds!), Duration: fixed leg duration minus floating leg duration ≈ fixed leg duration, Typically 5yr swap has duration ~4.5, 10yr swap duration ~8.5, Hedge ratio calculation: For duration hedge using instrument j: Hedge_ratio = Portfolio_DV01 / Instrument_DV01_j, quantity_j = -Hedge_ratio (negative for short hedge), Example: Portfolio DV01 = $10,000, 10yr Treasury future DV01 = $85 per contract, contracts_needed = $10,000 / $85 = 118 contracts (short), For convexity: More complex (quadratic term), typically use options or convexity-rich bonds, Optimization problem: Multi-instrument hedge (bonds + futures + swaps), Variables: quantities of each instrument, Objective: Minimize cost (bid-ask + commissions) + λ × tracking_error, Constraints: duration_achieved ≈ target ± ε, convexity_achieved ≥ target_min, Solver: Quadratic programming (cvxpy or scipy.optimize), Delta hedging (duration neutrality): Daily rebalance: Calculate portfolio duration at 4pm close, If |duration| > 0.1 (tolerance), rebalance, Hedge with futures (fastest execution): contracts = (Portfolio_duration × Portfolio_MV × 0.0001) / Future_DV01, Execute market orders (fill within seconds), Mark-to-market: Calculate P&L from duration hedge: expected P&L = -Hedge_DV01 × Δyield (should offset portfolio P&L), Gamma hedging (convexity matching): Portfolio convexity: Typically positive (good) but expensive, To increase convexity: Buy out-of-the-money options (calls + puts = straddle), Add long-duration bonds (30yr Treasuries have high convexity ~300), To decrease convexity (capture premium): Sell options (covered calls), Use swaps (near-zero convexity), Convexity P&L: P&L_convexity = 0.5 × Portfolio_convexity × (Δyield)^2 × Portfolio_MV, Positive convexity benefits from volatility, Cross-hedging: Using correlated but different instruments, Example: Hedge corporate bond portfolio with Treasury futures, Correlation typically 0.7-0.9 (not perfect), Basis risk = Portfolio_return - Hedge_return, measure with tracking error, Hedge ratio adjustment: β = Cov(Portfolio, Hedge) / Var(Hedge), quantity = β × naive_quantity, Futures basis handling: Basis = F - S × CF where CF = conversion factor, Cost of carry: Basis ≈ (Financing_cost - Coupon_income) × time, Typically positive (contango) for Treasuries, Hedge adjustment: Effective_hedge_DV01 = Future_DV01 × (1 + Basis_change_expectation), Monitor basis risk: Track actual vs expected basis, if diverges, adjust hedge, Swap convexity issue: Swaps have near-zero convexity (linear P&L with rates), Bonds have positive convexity (curved P&L), If hedge with swaps: Perfect duration hedge BUT miss convexity benefits, Solution: Use bond + swap combination: Swap for cheap duration hedge, Bonds for convexity exposure, Ratio: 70% swaps (cost), 30% bonds (convexity), Real-time execution: Market data feed: Subscribe to bond prices, futures quotes (WebSocket), On price update: Recalculate portfolio Greeks (cached computations, <100ms), Check hedge effectiveness: actual_hedge_pnl vs expected, If drift > threshold: Generate rebalance order, send to execution system, Latency target: Detect → Calculate → Execute in <1 minute, High-frequency not needed (duration changes slowly), API design: GET /portfolio/greeks returns {duration, dv01, convexity, by_position}, POST /hedge/calculate with {target_duration, instruments: ["futures", "bonds"]} returns recommended trades, POST /hedge/execute with {trades} submits to OMS, WebSocket /ws/hedge-status for real-time P&L and hedge effectiveness.',
    keyPoints: [
      'Portfolio Greeks: Aggregate DV01 = Σ(DV01_i), duration = Σ(MV_i × D_i) / Total_MV, convexity = Σ(MV_i × C_i) / Total_MV, cache in Redis, update on trades',
      'Hedge ratio: quantity = Portfolio_DV01 / Instrument_DV01 (for duration), adjust for correlation (β = Cov/Var) in cross-hedges, short for hedging',
      'Instruments: Treasury futures (liquid, leverage, basis risk), bonds (convexity, expensive), swaps (zero cost, zero convexity), optimize mix for cost vs tracking error',
      'Delta hedging: Daily rebalance if |duration| > 0.1, use futures (fast execution), calculate contracts = (Port_dur × MV × 0.0001) / Future_DV01, short to neutralize',
      'Gamma hedging: Positive convexity = good (buy via long bonds/options), capture with 0.5 × C × (Δy)^2, swaps have zero convexity (linear P&L), combine instruments',
    ],
  },
  {
    id: 'dc-q-3',
    question:
      'Implement a duration and convexity estimation system that: (1) Calculates duration/convexity analytically (closed-form formulas for standard bonds), (2) Falls back to numerical methods for complex bonds (callables, convertibles, MBS), (3) Estimates effective duration (using price changes for ±1bp yield shock), (4) Validates estimates (compare analytical vs numerical, flag large discrepancies), (5) Provides attribution (which cash flows contribute most to duration?), (6) Handles edge cases (zero-coupon, perpetuities, floating rate). Include: performance optimization (analytical 100x faster than numerical), accuracy requirements (duration ±0.01, convexity ±0.1), caching strategy (cache by bond + yield). How do you handle: callable bonds (duration shortens as price approaches call price)? Negative convexity (mortgages prepay when rates fall)? Key rate durations (sensitivity to specific curve points)? Very long maturities (100-year bonds, perpetuities)?',
    sampleAnswer:
      'Duration/convexity estimation system: Analytical calculation (fast path): For standard fixed-rate bonds: Macaulay_duration = Σ(t × PV(CF_t)) / Price, closed-form summation, Modified_duration = Mac_duration / (1 + y/m), Convexity = Σ[t(t+1) × PV(CF_t)] / [Price × (1+y)^2], Implementation: Vectorize with numpy, calculate all t values, discount factors, weighted sums, Performance: 1 million bonds in <10 seconds (10 microseconds per bond), Special cases: Zero-coupon: Duration = maturity (exact), Convexity = maturity × (maturity + 1) / (1+y)^2, Perpetuity: Duration = (1+y) / y, Convexity = 2 / y^2, Floating rate: Duration ≈ time to next reset (typically 0.25 for quarterly reset), Numerical methods (complex bonds): Effective duration: Shock yield up 1bp: price_up = bond.price(ytm + 0.0001), Shock yield down 1bp: price_down = bond.price(ytm - 0.0001), Effective_duration = (price_down - price_up) / (2 × price_0 × 0.0001), Works for any bond (including callables, MBS), Effective convexity: Convexity = (price_up + price_down - 2×price_0) / (price_0 × (0.0001)^2), Captures curvature even with embedded options, Computational cost: 3 price calculations vs 1 analytical, still fast (<1ms per bond), Callable bonds: Issue: Duration depends on whether bond will be called, If price > call_price and rates low: likely called early → short duration, If price < call_price: acts like normal bond → full maturity duration, Calculation: Effective duration captures this (price doesn\'t rise much above call price), Alternatively: Calculate to worst (duration to call date vs maturity, use shorter), Negative convexity: price_up - price_0 < price_0 - price_down (asymmetric), Option-adjusted spread (OAS) models handle this, Mortgages (MBS): When rates fall, homeowners refinance → prepayments accelerate, Effective duration shortens (cash flows come sooner), Negative convexity (prepayment option is short option), Model: Use prepayment model (PSA curve) to estimate cash flows, Calculate duration on adjusted cash flows, Validation: Compare methods: duration_analytical vs duration_numerical, if |difference| > 0.05, flag for review (likely embedded option), Check sanity: Duration ≤ maturity (always true unless exotic), Duration > 0 (except inverse floaters), Convexity > 0 for standard bonds, may be negative for callables/MBS, Attribution analysis: Which cash flows matter most? For each cash flow t: contribution_t = (t × PV_t) / Price, typically final payment (principal + coupon) contributes 30-50% of duration, Visualize: Bar chart showing contribution by year, Insight: Longer-maturity bonds more sensitive to distant cash flows (obvious but quantified), Key rate durations: Definition: Sensitivity to specific maturity bucket (2yr, 5yr, 10yr), Calculation: Shock only one point on curve, measure price change, KRD_5yr = (price with 5yr spot -1bp) - price_0) / (price_0 × 0.0001), Compute for each bucket (typically 10 points: 3mo, 6mo, 1yr, 2yr, 3yr, 5yr, 7yr, 10yr, 20yr, 30yr), Sum of KRDs ≈ Effective duration (parallel shift), Use case: Barbell (short + long bonds) has similar duration to bullet (medium bonds) but different KRD profile, Very long maturities: 100-year bonds: Duration typically 15-20 (not 100!), because distant cash flows heavily discounted, Perpetuities (consols): Duration = (1+y)/y, for y=5%, Duration = 21 years, Convexity very high (~400-500), benefit from rate volatility, Edge case: As maturity → ∞, duration approaches (1+y)/y asymptotically, Caching strategy: Key: (bond_id, ytm, method) → (duration, convexity, timestamp), TTL: 1 hour (prices change, but duration stable for small yield moves), Invalidation: On bond modification (coupon change, call schedule update), clear cache, Storage: Redis hash map, O(1) lookup, Performance optimization: Batch calculation: Calculate 1000 bonds in single vectorized operation, Lazy evaluation: Only calculate convexity if requested (not always needed), Parallel processing: Use multiprocessing for large portfolios (divide bonds across cores), Target: 10,000 bonds in <1 second (100 microseconds per bond with analytical), API design: POST /duration/calculate with {bond_id, ytm, method: "analytical"/"numerical"} returns {macaulay, modified, dv01, convexity, method_used}, GET /duration/attribution with {bond_id, ytm} returns cash flow contributions, POST /duration/key-rates with {bond_id, curve} returns {krd_2yr, krd_5yr, ..., krd_30yr}.',
    keyPoints: [
      'Analytical (fast): Mac_duration = Σ(t × PV_t) / P, Mod = Mac/(1+y/m), Convexity = Σ[t(t+1) × PV_t] / [P×(1+y)^2], vectorize with numpy (10μs per bond)',
      'Numerical (callables): Eff_duration = (P_down - P_up) / (2 × P_0 × Δy), Δy=1bp, 3 price calcs, captures embedded options, works for MBS/callables',
      'Callable bonds: Duration shortens near call price, use effective duration (captures optionality), or calculate to worst (min of to-call and to-maturity)',
      "Negative convexity: MBS prepay when rates fall (price doesn't rise much), effective convexity = (P_up + P_down - 2P_0) / (P_0 × Δy^2), may be negative",
      'Key rate durations: KRD_j = ΔP / (P × Δs_j) for maturity bucket j, sum ≈ effective duration, different KRD profiles even if same duration (barbell vs bullet)',
    ],
  },
];
