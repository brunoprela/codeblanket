export const corporateBondsQuiz = [
    {
        id: 'cb-q-1',
        question:
            'Design a callable bond pricing system that: (1) Values embedded call option using binomial interest rate tree, (2) Calculates option-adjusted spread (OAS) by finding spread that matches market price after option adjustment, (3) Computes effective duration and effective convexity (not modified duration - those assume no optionality), (4) Identifies negative convexity region (where price appreciation is capped), (5) Generates optimal call decision at each node in tree. Requirements: Interest rate model (Cox-Ross-Rubinstein or Black-Derman-Toy), call schedule handling (multiple call dates with declining premiums), callable American-style (can call anytime after protection period). How do you handle: call protection periods (5 years non-callable then callable)? Declining call premiums (102 in year 6, 101 in year 7, 100 in year 8+)? Optimal call decision (issuer calls when beneficial but accounting for transaction costs)? Performance for portfolio of 100+ callable bonds?',
        sampleAnswer:
            'Callable bond pricing architecture: Binomial rate tree construction: Cox-Ross-Rubinstein model: Time steps: dt = T / n_steps (e.g., 10yr / 50 steps = 0.2yr per step), Up factor: u = exp(σ × sqrt(dt)), Down factor: d = 1/u, Risk-neutral probability: p = 0.5 (recombining tree), Interest rates at node (i,j): r_ij = r_0 × u^j × d^(i-j), where i=time step, j=number of ups, Build tree: n_steps × n_steps matrix of rates, Alternative: Black-Derman-Toy (more sophisticated, fits term structure exactly), Backward induction pricing: Terminal value (at maturity): V_ij = Face_value + Coupon (final payment), Backward from maturity: For each node (i,j): Discount expected value: EV = [p × V_(i+1,j+1) + (1-p) × V_(i+1,j)] / (1 + r_ij × dt), Add coupon if payment date: EV += Coupon, Optimal call decision: time_from_issue = T - i×dt, If time_from_issue >= call_protection_period (e.g., 5 years): Determine call_price from schedule: years_since_callable = time_from_issue - call_protection, if years_since_callable < 1: call_price = 102 × Face_value/100, elif years_since_callable < 2: call_price = 101 × Face_value/100, else: call_price = Face_value (par), Issuer calls if EV > call_price + transaction_costs, transaction_costs = 0.5% × Face_value (typical), V_ij = min(EV, call_price) if callable else EV, Store call decision at each node for analysis, Price = V_00 (value at root node), Option-adjusted spread (OAS): Definition: Spread over benchmark curve after removing option value, Algorithm: Fetch benchmark curve: spot_rates = [s(t) for t in maturities], Build shifted curve: shifted_curve(t) = spot_rate(t) + OAS, Re-price callable bond using shifted curve (add OAS to all rates in tree), Find OAS such that model_price(OAS) = market_price, Solver: Use scipy.optimize.brentq (root finding): def objective(oas): return model_price(oas) - market_price, oas = brentq(objective, bounds=(0, 0.05)), Bounds: 0 to 500bp (typical range for corporates), Interpretation: OAS removes call option value, Pure credit + liquidity spread, Effective duration/convexity: Modified duration doesn\'t work (assumes no optionality), Effective duration: Shock entire curve up/down: price_up = callable_bond_price(ytm + 1bp, shifted tree), price_down = callable_bond_price(ytm - 1bp, shifted tree), eff_duration = (price_down - price_up) / (2 × price_0 × 0.0001), Effective convexity: convexity = (price_up + price_down - 2×price_0) / (price_0 × 0.0001^2), Negative if bond in call region (rates fall, price capped), Negative convexity region: Calculate price-yield curve: yields = np.linspace(0.02, 0.08, 50), prices = [callable_price(y) for y in yields], Detect region where second derivative < 0: convexity_curve = np.gradient(np.gradient(prices)), negative_region = yields[convexity_curve < 0], Typically occurs when bond trades above call_price (in-the-money for issuer to call), Call protection handling: In tree: Add flag at each node: is_callable = (current_time >= call_protection_end_date), Only apply call decision if is_callable, Call protection = non-callable period: Common: 5yr hard protection (absolutely non-callable), Then callable anytime (American style), Performance optimization: Tree size trade-off: More steps = more accurate but slower, 50 steps typically sufficient (error <$0.10), 100+ steps for high precision (research), Cache tree: If pricing multiple bonds with same rate characteristics, reuse rate tree, only recalculate payoffs, Vectorize: Use numpy arrays for entire tree, calculate all nodes at time i simultaneously, instead of loops, Parallel: For portfolio, price bonds in parallel (multiprocessing), Target: 100 bonds in <10 seconds (100ms per bond), API design: POST /callable/price with {bond, ytm, volatility, n_steps} returns {price, oas, eff_duration, negative_convexity_region}, GET /callable/optimal-call-path with {bond_id} returns sequence of nodes where call optimal, POST /portfolio/callable-risk with {positions} returns aggregate effective duration and convexity.',
        keyPoints: [
            'Binomial tree: CRR with u=exp(σ√dt), d=1/u, p=0.5, r_ij = r_0 × u^j × d^(i-j), build n_steps×n_steps rate tree, backward induction from maturity',
            'Optimal call: At each node if callable (time >= protection_period), issuer calls if EV > call_price + costs, V_ij = min(EV, call_price), store decisions',
            'OAS calculation: Find spread such that model_price(curve + OAS) = market_price, use root-finding (brentq), OAS = pure credit spread (option removed)',
            'Effective duration: eff_dur = (P_down - P_up) / (2×P_0×Δy), shock entire curve, accounts for call optionality, NOT modified duration (wrong for callables)',
            'Negative convexity: Occurs when price near/above call price, second derivative < 0, gains capped when rates fall, identify region from price-yield curve',
        ],
    },
    {
        id: 'cb-q-2',
        question:
            'Build a convertible bond valuation and arbitrage system that: (1) Prices convertible using binomial tree (models both equity and debt components), (2) Calculates Greeks (delta to stock, vega to volatility, rho to rates, credit spread sensitivity), (3) Identifies arbitrage opportunities (convertible mispriced vs underlying stock and debt), (4) Recommends hedges (long convertible + short stock = convert arb), (5) Monitors conversion triggers (stock price crosses conversion price). Include: soft call provisions (can call only if stock > 130% of conversion price for 20 days), forced conversion (issuer forces conversion by calling), conversion value parity. How do you handle: credit spread widening (bond floor falls)? Dividend payments (reduce conversion value)? Conversion premium compression as maturity approaches? Hedging dynamic delta (rebalance as stock moves)?',
        sampleAnswer:
            'Convertible bond valuation system: Binomial tree approach: Build 2D tree: Stock price tree: S_ij = S_0 × u^j × d^(i-j), u = exp(σ_stock × sqrt(dt)), d=1/u, n_steps from today to maturity, Discount rate tree: Use risk-free rate + credit spread, Corporate bond discount: r_ij = r_free + credit_spread, At each node, value = max(conversion_value, bond_value), Backward induction: Terminal (maturity): Conversion_value = Conversion_ratio × S_iT, Bond_value = Face_value + Coupon, Value = max(Conversion_value, Bond_value), Intermediate nodes: EV_continue = [p×V_(i+1,j+1) + (1-p)×V_(i+1,j)] / (1 + r_ij×dt), Add coupon if payment date, Conversion_value = Conversion_ratio × S_ij, Optimal decision: Holder converts if Conversion_value > EV_continue (immediate exercise optimal), Value = max(Conversion_value, EV_continue), Call provisions: Soft call: Issuer can call only if: S_t > Soft_call_threshold × Conversion_price (e.g., 130%), Sustained for 20 consecutive trading days, Implementation: Track stock price history in tree, if condition met, issuer can force conversion, If called: holder converts (receives stock) or gets call_price (typically par), Value = min(EV, Conversion_value) if soft-call active, Forced conversion: When issuer calls, rational holder converts (gets conversion_value) rather than accepting call_price if conversion_value > call_price, Greeks calculation: Delta (equity sensitivity): Δ = ∂V / ∂S, Numerical: delta = (V(S+1) - V(S-1)) / 2, Hedge ratio: Short delta × convertible_quantity shares, Vega (volatility sensitivity): ν = ∂V / ∂σ, Numerical: vega = V(σ+0.01) - V(σ-0.01), Higher volatility = higher option value = higher convert value, Rho (rate sensitivity): ρ = ∂V / ∂r, Dual effect: Higher rates reduce bond floor (negative), but also reduce PV of dividends making equity more attractive (positive), Credit spread sensitivity: CS_sens = ∂V / ∂spread, Wider spreads lower bond floor (increases downside risk), Update daily as market moves, Arbitrage identification: Convertible vs components: Bond_floor = PV(coupons + principal) at corporate YTM, Conversion_parity = Conversion_ratio × Stock_price, Theoretical_value = max(Bond_floor, Conversion_parity) + Time_value, Market_price from trading, Arbitrage opportunities: If Market_price < Theoretical - transaction_costs: BUY convertible, potentially short stock, "Cheap convertible", If Market_price > Theoretical + transaction_costs: SELL convertible (if able to short), "Rich convertible", Convertible arbitrage strategy: Long convertible + Short delta × quantity stock: Delta-neutral (no directional equity exposure), Profit from: Volatility (long gamma, benefit from swings), Credit spread tightening (if bond floor rises), Time decay management (theta can be negative or positive), Rebalance daily to maintain delta neutrality, Conversion triggers: Monitor stock price vs conversion price: Conversion_price = Face_value / Conversion_ratio, In-the-money: Stock_price > Conversion_price, At-the-money: Stock_price ≈ Conversion_price, Out-of-the-money: Stock_price < Conversion_price, Alert thresholds: Stock crosses conversion_price (ATM), Stock > 120% of conversion_price (deep ITM, conversion likely), Stock > 130% × 20 days (soft call trigger imminent), Credit spread handling: Credit spread widening: Bond_floor = PV using (r_free + wider_spread), Bond_floor falls (bad for convertible holders), Offset if stock rises (equity component benefits), Monitor: If spread > 500bp (distressed), bond floor may be far below par, conversion option may be only value, Dividend impact: Stock dividends reduce stock price: On ex-dividend date: S_new = S_old - Dividend, Reduces conversion value: Conv_value = ratio × (S - cumulative_divs), Some convertibles have dividend protection clauses (adjust ratio), Update tree: Subtract expected dividends from stock price at each payment date, Conversion premium: Premium = (Convert_price - Conversion_parity) / Conversion_parity, Time decay: Premium compresses as maturity approaches, At maturity: Premium = 0 (intrinsic value only), Model: Premium = f(time, volatility, credit spread), expect compression over time, Hedging dynamic delta: Initial hedge: Short delta_0 shares of stock, Delta changes as: Stock moves (gamma effect), Time passes (charm), Volatility changes (vanna), Rebalancing: Daily: Recalculate delta, adjust short position, Transaction costs: 0.5-1% roundtrip for stock, balance frequency vs costs, Target: Keep delta within ±10% of neutral, API design: POST /convertible/price with {bond, stock_price, volatility, credit_spread} returns {value, greeks, arbitrage_opportunity}, GET /convertible/conversion-value with {bond_id} returns {parity, premium, in_the_money}, POST /arbitrage/convertible with {bond_id} returns {hedge_ratio, expected_profit, risks}, WebSocket /ws/conversion-alerts for real-time trigger notifications.',
        keyPoints: [
            'Binomial tree: Price stock (S_ij = S_0×u^j×d^(i-j)) and bond jointly, at each node V = max(Conversion_value, Bond_value), backward induction, soft call if S > 130% × conversion_price for 20 days',
            'Greeks: Delta = ∂V/∂S (hedge ratio), Vega = ∂V/∂σ (volatility exposure), Rho = ∂V/∂r (rate sensitivity), Credit_sens = ∂V/∂spread (bond floor impact), calculate numerically',
            'Arbitrage: Compare market_price to theoretical (max(bond_floor, conversion_parity) + time_value), if cheap buy convertible + short delta shares, delta-neutral arb',
            'Conversion triggers: Monitor stock vs conversion_price, alert when stock crosses parity, > 120% (deep ITM), > 130%×20d (soft call trigger), forced conversion imminent',
            'Dynamic hedging: Rebalance delta daily (stock moves → gamma → delta changes), transaction costs 0.5-1% roundtrip, keep delta within ±10% neutral, dividends reduce conversion value',
        ],
    },
    {
        id: 'cb-q-3',
        question:
            'Implement a floating rate note (FRN) pricing and analytics system that: (1) Prices FRN using forward rates from yield curve (discount margin method), (2) Handles reference rate transitions (LIBOR to SOFR), (3) Calculates spread duration (sensitivity to credit spread changes, not rate changes), (4) Manages reset dates and payment conventions, (5) Accounts for caps and floors (interest rate options embedded). Include: accrued interest for FRNs (tricky because coupon unknown until reset), index lag (3-month SOFR set at beginning of period, paid at end), spread over index. How do you handle: coupon discontinuity at reset dates (price jump)? Negative rates (SOFR can go negative, floors prevent negative coupons)? Discount margin (DM) vs quoted margin? Compare FRN to fixed-rate bond duration?',
        sampleAnswer:
            'FRN pricing and analytics system: Forward rate discounting: FRN cash flows: At each reset date t_i: Index_rate = SOFR(t_i) or forward_rate(t_i) from curve, Coupon = (Index_rate + Quoted_margin) × Face_value × day_count_fraction, Example: 3mo SOFR + 150bp, SOFR forecasted at 4.5%, coupon = (4.5% + 1.5%) = 6.0%, Face_value $1000, quarter = 0.25, payment = $15, Pricing formula: Price = Σ [Forecast_coupon_i / (1 + (Index_i + DM))^t_i] + Face / (1 + (Index_n + DM))^t_n, DM = Discount Margin (spread for discounting, may differ from Quoted_margin), Quoted_margin = spread added to index for coupon calculation, DM = spread that makes PV = par (or market price), Solving for DM: Given market_price, solve for DM such that PV(cash_flows, DM) = market_price, Use Newton-Raphson iteration, Interpretation: DM reflects credit quality, DM > Quoted_margin means bond trading below par (deteriorated credit), Reference rate transition: LIBOR → SOFR: LIBOR discontinued 2023, legacy FRNs converted to SOFR + spread adjustment, Spread adjustment ≈ 26bp for 3mo LIBOR (historical differential), Updated formula: Coupon = SOFR + Original_spread + Adjustment_spread, Handle multiple reference rates in database: (bond_id, reference_rate, quoted_margin, adjustment), Reset mechanics: Reset dates: Typically quarterly for 3mo SOFR, semi-annual for 6mo, Index lag: Index set at beginning of period, Payment at end of period, Example: Jan 1 reset: SOFR_Jan1 = 4.5%, Apr 1 payment: Pay based on 4.5% SOFR (not current SOFR), Forward projection: Project future coupons using forward SOFR from curve, Spread duration: Definition: Sensitivity to credit spread change, not interest rate, Key insight: FRN has very low rate duration (~0.25 for quarterly reset), But significant spread duration (like fixed bond duration), Calculation: Spread_duration = ∂Price / ∂DM, Numerical: spread_dur = (Price(DM-1bp) - Price(DM+1bp)) / (2 × Price × 0.0001), Typically 2-7 years depending on maturity, Compare to rate duration: Rate_duration ≈ time_to_next_reset (0.25 for quarterly), FRN protects from rate risk, not credit risk, Caps and floors: Cap: Maximum coupon rate (e.g., 3mo SOFR + 150bp, capped at 8%), Embedded short call option on rates (bad for investor), Value: FRN_with_cap = FRN - Cap_option_value, Floor: Minimum coupon rate (e.g., max(SOFR + 150bp, 3.0%)), Embedded long put option on rates (good for investor), Particularly relevant when rates low or negative, Value: FRN_with_floor = FRN + Floor_option_value, Pricing caps/floors: Use Black model for interest rate options, Call_value = Σ Black(Forward_rate_i, Strike, vol, t_i), Sum over all reset dates, Accrued interest: Challenge: Coupon for current period unknown until reset, Estimate: Use current index rate (SOFR today), Accrued = (Current_SOFR + Quoted_margin) × Face × days_accrued / days_in_period, Example: 3mo period, 45 days since reset, SOFR = 4.5%, margin = 1.5%, Accrued = (4.5% + 1.5%) × $1000 × (45/90) = $30, Update: Recalculate daily as SOFR changes, Discontinuity at reset: On reset date: Old_coupon locked in, New_coupon projected using forward, Price may jump if realized_rate ≠ forward_rate, Example: Forward SOFR was 4.5%, actual SOFR fixes at 5.0%, Next coupon higher than expected → price jumps up, Model: Account for jump risk in valuation, Historical vol of (realized - forward) rate, Negative rates: SOFR can technically go negative (happened briefly in 2020), Many FRNs have floor at 0% (SOFR floor), Coupon = max(0, SOFR) + Quoted_margin, ensures non-negative index, If SOFR = -0.5%, floor activates, coupon = 0% + 1.5% = 1.5%, Pricing: Value floor option when rates near zero (0-1% SOFR), Duration comparison: Fixed 10yr bond: Modified duration ≈ 7.5 years, FRN 10yr maturity: Rate duration ≈ 0.25 (next reset), Spread duration ≈ 7.5 (similar to fixed), Interpretation: FRN hedges interest rate risk (coupon adjusts), But exposed to credit spread risk (spread fixed), API design: POST /frn/price with {bond, current_index, discount_margin} returns {price, spread_duration, accrued}, GET /frn/coupons with {bond_id, forward_curve} projects all future coupons, POST /frn/discount-margin with {bond_id, market_price} solves for DM, GET /frn/cap-floor-value with {bond_id, rate_vol} prices embedded options.',
        keyPoints: [
            'Pricing: Project coupons = (Forward_SOFR + Quoted_margin) × Face × dcf, discount at (Index + DM), DM = discount margin (credit spread), solve for DM given market price',
            'Spread duration: ∂Price/∂DM, typically 2-7yr (like fixed bond), rate duration ≈ time_to_reset (0.25 for quarterly), FRN hedges rate risk not credit risk',
            'Caps/floors: Cap = short call on rates (lowers value), Floor = long put (raises value), price with Black model, sum over all reset dates, floor important when SOFR near 0%',
            'Accrued interest: Estimate using current index (SOFR today + margin), update daily, discontinuity at reset (coupon locks in, may differ from forward projection)',
            'LIBOR→SOFR: Add spread adjustment (≈26bp for 3mo), index lag (set at period start, pay at end), negative rates possible (floors prevent negative coupons)',
        ],
    },
];

