export const yieldCurvesTermStructureQuiz = [
  {
    id: 'ycts-q-1',
    question:
      "Build a production yield curve bootstrapping system that: (1) Extracts spot rates from market bond prices using iterative solving, (2) Handles both zero-coupon bonds (T-Bills) and coupon bonds (T-Notes), (3) Implements cubic spline interpolation for smooth curve, (4) Calculates forward rates between any two maturities, (5) Detects curve shape (normal/inverted/flat/humped) and triggers alerts on inversion, (6) Stores historical curves in time-series database for analysis. Requirements: Handle edge cases (first bond non-zero coupon, missing maturities like no 7yr bond, negative yields in some markets), performance (bootstrap 50+ bonds in <100ms), accuracy (match Bloomberg curve within 1bp). How do you handle: iterative solving for coupon bonds when multiple unknowns? Choosing interpolation method (linear vs cubic vs Nelson-Siegel)? Validating no arbitrage (forward rates don't violate expectations)? Real-time updates as bond prices change?",
    sampleAnswer:
      'Yield curve bootstrapping architecture: Core algorithm: (1) Sort bonds by maturity ascending, (2) For zero-coupon bonds: spot_rate = (FV/Price)^(1/t) - 1 (direct calculation, no iteration), (3) For coupon bonds: Known cash flows up to maturity can be discounted using already-bootstrapped shorter spots, remaining PV = Price - PV(known_cash_flows), solve for spot at maturity: spot_T = [(Final_CF / remaining_PV)]^(1/T) - 1, Iterative solving for coupon bonds: For bond with maturity T and coupon C: Price = Σ(i=1 to n-1) [C / (1 + s_i)^t_i] + [(C + FV) / (1 + s_T)^T], All s_i for i < T are known (already bootstrapped), Only s_T is unknown, Rearrange: s_T = {[(C + FV) / (Price - PV_known)]}^(1/T) - 1, where PV_known = present value of all coupons before maturity using interpolated spots, Implementation: Use scipy.optimize.brentq if analytical formula insufficient (rare), typically direct calculation works, Edge cases: First bond non-zero coupon: If shortest bond is 6-month with coupon (not T-Bill), estimate initial spot using YTM approximation, refine in second pass, Missing maturities: If no 7yr bond, interpolate using surrounding maturities (5yr and 10yr), Negative yields: Allow spot < 0 for markets like Japan/Switzerland, validate Price > FV for negative yield bonds, Interpolation methods: Cubic spline: Smooth, C2 continuous, best for visualization, can produce unrealistic humps between points, Linear: Simple, fast, but not smooth (kinks at each point), Nelson-Siegel: β₀ + β₁×[(1-exp(-m/τ))/(m/τ)] + β₂×[(1-exp(-m/τ))/(m/τ) - exp(-m/τ)], parametric fit, ensures smooth curve, realistic shapes, preferred by central banks, Choice: Use cubic spline for speed, Nelson-Siegel for monthly official curve, Forward rate calculation: f(t1, t2) = [(1+s2)^t2 / (1+s1)^t1]^(1/(t2-t1)) - 1, Validate: forward rates should be positive (except rare markets), forward curve smoother than spot curve typically, No-arbitrage check: If f(1,2) > f(2,3) by large margin, suggests arbitrage, validate by checking if synthetic 2yr bond (1yr + 1yr forward) price matches market, Curve shape detection: Sample rates: short = spot(0.25), medium = spot(2.0), long = spot(10.0), Inverted: short > long + 0.20% (20bp threshold to avoid false positives), Normal: long > short + 0.20%, Flat: |long - short| < 0.20%, Humped: medium > max(short, long), Alert on inversion: Send notification (email/Slack) when curve inverts, Historical context: Check if first inversion or continuation, Log event for analysis (recession prediction model), Time-series storage: Schema: (timestamp, maturity, spot_rate, forward_rate, curve_shape), Use TimescaleDB or InfluxDB for efficient time-series queries, Index on (timestamp, maturity) for fast range scans, Retention: Keep daily snapshots for 10+ years (recession analysis), Performance optimization: Cache bond PV calculations (same bond + spot → cache), Vectorize using numpy for multiple bonds: Build cash_flow_matrix (bonds × periods), discount_factor_matrix using known spots, Batch solve for remaining spots, Target: 50 bonds in <100ms (2ms per bond), Incremental updates: When bond price changes, only re-bootstrap from that maturity onward (earlier spots unchanged), Lazy evaluation: Only calculate forward rates when requested (not during bootstrap), Real-time updates: Subscribe to market data feed (bond prices), On price update: Check if significant (>$0.10 change), if yes, re-bootstrap affected maturities, Publish updated curve via WebSocket to subscribers, Rate limit: Max 1 curve update per second (avoid thrashing), API design: GET /yield-curve?date=2024-01-15 returns {maturities, spot_rates, curve_shape}, POST /yield-curve/bootstrap with {bonds: [{maturity, coupon, price}]} returns bootstrapped curve, WebSocket /ws/yield-curve for real-time updates.',
    keyPoints: [
      'Bootstrap algorithm: Zero-coupon direct calculation, coupon bonds solve s_T = [(Final_CF / (Price - PV_known))]^(1/T) - 1 iteratively',
      'Interpolation: Cubic spline for speed/smoothness, Nelson-Siegel for realistic shapes, linear for simplicity, validate no arbitrage with forwards',
      'Curve shape: Sample short/medium/long, detect inverted (short > long + 20bp), normal (long > short + 20bp), alert on inversion (recession signal)',
      'Time-series storage: TimescaleDB with (timestamp, maturity, spot_rate), daily snapshots 10yr retention, index on (timestamp, maturity)',
      'Performance: Vectorize with numpy (50 bonds <100ms), cache PV calculations, incremental updates (re-bootstrap from changed maturity onward)',
    ],
  },
  {
    id: 'ycts-q-2',
    question:
      'Design a forward rate calculation and FRA (Forward Rate Agreement) pricing system that: (1) Calculates forward rates between any two maturities from spot curve, (2) Prices FRAs (contracts locking in future borrowing rate), (3) Handles both simple compounding (money market) and continuous compounding, (4) Validates no-arbitrage conditions (synthetic positions match actual), (5) Calculates P&L on existing FRA positions as spot curve moves. Include: day count conventions for FRAs (Actual/360 for USD), settlement amount calculation at maturity, mark-to-market valuation before settlement. How do you handle: FRA notation (e.g., 3x9 means borrow in 3 months for 6 months)? Convexity adjustments for futures vs forwards? Bid-ask spreads in real markets? Hedging FRA positions with bond positions?',
    sampleAnswer:
      'Forward rate and FRA system architecture: Forward rate calculation: From spot rates s₁ and s₂: (1 + s₂)^t₂ = (1 + s₁)^t₁ × (1 + f)^(t₂-t₁), Solving: f = [(1+s₂)^t₂ / (1+s₁)^t₁]^(1/(t₂-t₁)) - 1, Simple compounding (money market): f = [(1 + s₂×t₂) / (1 + s₁×t₁) - 1] / (t₂-t₁), used for short-term FRAs (<1yr), Continuous compounding: f = (s₂×t₂ - s₁×t₁) / (t₂-t₁), used in academic pricing, Example: s(0.25) = 4%, s(0.75) = 4.5%, forward 3mo-9mo: f = [(1.045^0.75) / (1.04^0.25)]^(1/0.5) - 1 = [1.0333/1.0099]^2 - 1 = 4.72%, FRA notation: "3x9 FRA" means: Start in 3 months, end in 9 months, period length = 9-3 = 6 months, Contract locks in 6-month rate 3 months from now, Notional (e.g., $1M) and rate (e.g., 4.75%) agreed today, FRA pricing: Fair FRA rate = forward rate from spot curve, For 3x9 FRA: FRA_rate = forward(0.25, 0.75) = 4.72%, If bank quotes 4.75%, buyer pays 4.75% but fair is 4.72% → 3bp unfavorable, FRA settlement: At maturity (3 months), compare FRA rate to actual LIBOR (now SOFR), If SOFR = 5.0% and FRA rate = 4.75%: Seller pays buyer: (5.0% - 4.75%) × Notional × (days/360) × DF, DF = 1/(1 + SOFR × days/360) for discounting to settlement date, Settlement_amount = 0.25% × $1M × (180/360) × DF = $1,250 × 0.9756 = $1,219, Mark-to-market valuation: Before settlement, FRA value changes as forward rates move, MTM_value = (Current_forward - Contracted_forward) × Notional × (days/360) × DF, If 3x9 forward moves from 4.75% to 5.0%, MTM gain for buyer = $1,219 (same calculation), Day count conventions: USD FRAs: Actual/360 (actual days between dates / 360), EUR FRAs: Actual/360, GBP FRAs: Actual/365, Use day_count_factor() function from bond pricer, No-arbitrage validation: Synthetic FRA using bonds: Long bond maturing at t₂, short bond maturing at t₁, Verify: synthetic FRA rate = actual FRA rate, If mismatch > 5bp, arbitrage opportunity (rare in liquid markets), Example: If 3x9 FRA is 4.75% but synthetic is 4.60%, arbitrage: sell FRA at 4.75%, create synthetic at 4.60%, lock in 15bp spread, Convexity adjustment: Futures vs Forwards: Futures: Daily mark-to-market → gains reinvested → convexity benefit, Forwards: No interim cash flows → no convexity, Futures_rate ≈ Forward_rate + 0.5 × σ² × t₁ × t₂, where σ = volatility of forward rate, For 3x9 with σ=1%: adjustment ≈ 0.5 × 0.01² × 0.25 × 0.75 = 0.0009% (negligible), Significant only for long-dated contracts (>2 years), Bid-ask spreads: Market makers quote two-way prices: 4.72% bid (they receive fixed) / 4.75% offer (they pay fixed), Spread = 3bp, Edge case: During volatility (Fed announcement), spreads widen to 10-20bp, Model: fair_rate ± spread/2, For pricing customer FRAs, add spread to fair rate, Hedging FRA positions: FRA exposure: Receive-fixed FRA → lose if forward rates fall (bond prices rise), Hedge with bond: Long bond position (benefits if rates fall), Hedge ratio: Duration-match to FRA, FRA DV01 = Notional × (days/360) × 0.0001, Bond DV01 = Duration × Price × 0.0001, Hedge_quantity = FRA_DV01 / Bond_DV01, Example: $10M FRA, 180 days → DV01 = $10M × 0.5 × 0.0001 = $50, Bond with DV01=$0.05 per $100 → need $100,000 face value bonds, Dynamic hedging: Rebalance daily as forward rates change, Transaction costs: Bid-ask spread on bonds + FRA spread, API design: GET /forward-rate?start=3mo&end=9mo returns {forward_rate, period_length}, POST /fra/price with {notional, start, end, rate} returns {fair_rate, mtm_value, dv01}, POST /fra/settle with {contract_id, fixing_rate} calculates settlement amount, Portfolio view: GET /fra/portfolio returns all FRA positions with MTM and risk metrics.',
    keyPoints: [
      'Forward rate: f = [(1+s₂)^t₂ / (1+s₁)^t₁]^(1/(t₂-t₁)) - 1, simple compounding for <1yr money market, continuous for academic',
      'FRA notation: 3x9 = borrow in 3mo for 6mo, fair FRA rate = forward rate, settlement = (SOFR - FRA_rate) × Notional × days/360 × DF',
      'Mark-to-market: MTM = (Current_forward - Contract_forward) × Notional × days/360 × DF, update daily for P&L tracking',
      'No-arbitrage: Validate synthetic FRA (long t₂ bond + short t₁ bond) matches actual FRA, <5bp tolerance, arbitrage if larger',
      'Hedging: Duration-match with bonds, hedge_qty = FRA_DV01 / Bond_DV01, rebalance daily, account for transaction costs (spreads)',
    ],
  },
  {
    id: 'ycts-q-3',
    question:
      'Implement a yield curve shape detection and recession prediction system that: (1) Classifies curve shape (normal/inverted/flat/humped) based on key maturity spreads, (2) Tracks historical inversions (2yr-10yr spread going negative), (3) Generates alerts when spread crosses zero or threshold (-25bp = strong signal), (4) Maintains historical database of inversions and subsequent recessions, (5) Calculates probability of recession based on inversion depth and duration, (6) Provides visualization dashboard showing spread over time with recession bars. Include: real-time monitoring (check every minute during market hours), false positive filtering (short-duration inversions <5 days ignored), statistical model (logistic regression on inversion depth/duration → recession probability). How do you handle: defining "inversion" (which spread: 2y-10y vs 3mo-10y)? Lead time variability (6-24 month range)? Current vs future recessions (forward-looking indicators)? Communication to non-technical users (executives)?',
    sampleAnswer:
      'Yield curve inversion monitoring system: Core metrics: Primary spread: 2yr-10yr (most reliable historically), Secondary spreads: 3mo-10yr (earlier signal), 5yr-10yr, 1yr-10yr, Calculate: spread = spot_rate(10yr) - spot_rate(2yr), Negative spread = inverted curve, Shape classification: Sample key points: short (3mo), medium (2yr), long (10yr), Normal: long > medium > short (upward sloping), Inverted: short > long (any key inversion), Flat: max(spread) < 25bp across all maturities, Humped: medium > max(short, long), Inversion detection: Current spread: spread_2y10y = spot(10) - spot(2), if spread_2y10y < 0: inversion = True, Track inversion_start_date, duration_days = today - inversion_start_date, depth = minimum spread reached (most negative), Alert thresholds: Spread crosses 0bp (from positive to negative): Send "Inversion Alert" (high priority), Spread < -25bp: Send "Deep Inversion Alert" (highest priority, strong recession signal), Spread reverts to positive after inversion: Send "Steepening Alert" (inversion ended), False positive filtering: Ignore inversions lasting <5 trading days (noise, technical factors), Only trigger recession model if inversion sustained 5+ days, Example: If spread goes -5bp for 2 days then +10bp, ignore (too brief), Historical database: Table: inversions (inversion_id, start_date, end_date, min_spread, duration_days, recession_occurred, recession_date, lead_time_months), Pre-populate with historical inversions: 1989 inversion → 1990 recession (12mo lead), 2000 inversion → 2001 recession (15mo lead), 2006 inversion → 2008 recession (22mo lead), 2019 inversion → 2020 recession (8mo lead, COVID-accelerated), Use for model training, Recession probability model: Features: inversion_depth = |min_spread| (e.g., -30bp = 0.30), inversion_duration = days inverted / 30 (months), current_spread = today\'s spread, Logistic regression: P(recession) = 1 / (1 + exp(-(β₀ + β₁×depth + β₂×duration + β₃×current_spread))), Train on historical data (inversions with known recession outcomes), Coefficients (example from historical fit): β₀=-2.5, β₁=15, β₂=0.5, β₃=-10, Example: depth=0.30 (30bp), duration=3 months, current=-20bp: P = 1/(1+exp(-(−2.5+15×0.3+0.5×3−10×0.2))) = 1/(1+exp(-3.5)) = 97%, Output: High probability (>80%) = imminent recession, Medium (50-80%) = elevated risk, Low (<50%) = low risk, Lead time analysis: Historical range: 6-24 months from inversion to recession start, Median: 12-15 months, Model output: Expected recession date = today + 12 months (median lead), Confidence interval: 6-24 months, Caveat: Lead time varies (2019→2020 was only 8 months), Real-time monitoring: Schedule: Check every 1 minute during market hours (9:30am-4pm ET), Outside hours: Check every 15 minutes (for after-hours trading), Fetch latest bond prices from market data feed, Re-bootstrap yield curve, Calculate spread, Compare to previous spread: If sign change (positive→negative or vice versa), trigger alert, If depth change >5bp, update probability model, Visualization dashboard: Chart: Time series of 2y-10y spread over 40 years, Overlay recession periods (gray bars) from NBER data, Horizontal line at y=0 (inversion threshold), Current spread highlighted (green if positive, red if negative), Metrics panel: Current spread, Days since inversion (if inverted), Recession probability (gauge: 0-100%), Historical avg lead time, Executive communication: Non-technical summary: "Yield Curve Alert: INVERTED", Plain language: "The 2-year Treasury yield (X%) is now higher than the 10-year yield (Y%). Historically, this signal has preceded recessions by 6-24 months.", Actionable: "Recommend defensive portfolio positioning: increase cash, reduce equity exposure, favor quality bonds.", Avoid jargon: Don\'t say "The 2s10s spread inverted by 30bp", Say: "Short-term rates are 0.30% higher than long-term rates, suggesting economic slowdown ahead", Historical context: "This is the Nth inversion since 1980. Previous inversions led to recessions in X% of cases.", Edge cases: Simultaneous inversions: If 2y-10y inverts but 3mo-10y doesn\'t, note "Partial inversion", Full inversion: All spreads negative = stronger signal, Persistent inversion: >180 days inverted = very strong signal (2006-2007 = 21 months inverted), Rapid uninversion: If spread goes +50bp after inversion, may signal recession already started (Fed cutting rates), API design: GET /yield-curve/spread?start=2yr&end=10yr returns current spread, GET /yield-curve/inversion/status returns {inverted, duration_days, recession_prob}, GET /yield-curve/historical-inversions returns list of past inversions with outcomes, WebSocket /ws/inversion-alerts for real-time notifications, Backtesting: Test model on historical data (out-of-sample): Train on 1980-2000, test on 2000-2020, Metrics: Sensitivity (% of recessions predicted), Specificity (% of non-recessions not predicted), Lead time accuracy (predicted vs actual), Refine model coefficients based on backtest results.',
    keyPoints: [
      'Inversion detection: spread_2y10y = spot(10yr) - spot(2yr), inverted if < 0, track depth (min spread) and duration (days negative)',
      'Alert thresholds: Spread crosses 0 (inversion alert), <-25bp (deep inversion, strong signal), filter false positives (<5 day inversions)',
      'Recession probability: Logistic regression on (inversion_depth, duration, current_spread), P(recession) using historical training data (1980-2020)',
      'Historical analysis: Store all inversions with recession outcomes, lead time 6-24mo (median 12-15), current inversion → predict recession in 12mo ± 6mo',
      'Executive communication: Plain language ("short-term rates higher than long-term"), historical context (X% accuracy), actionable recommendations (defensive positioning)',
    ],
  },
];
