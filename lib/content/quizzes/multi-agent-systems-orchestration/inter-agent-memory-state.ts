/**
 * Quiz questions for Inter-Agent Memory & State section
 */

export const interagentmemorystateQuiz = [
  {
    id: 'maas-memory-q-1',
    question:
      'Compare shared memory vs message passing for inter-agent state management. For a real-time collaborative document editing system with 10 agents, which approach would you use and why?',
    hint: 'Consider update frequency and consistency requirements.',
    sampleAnswer:
      '**Shared Memory Approach:** All agents read/write to shared document state: {document_content, cursor_positions, edit_history}. Pros: Low latency (direct memory access), all agents see same state immediately, simple for read-heavy operations (agents checking cursor positions). Cons: Race conditions (two agents editing same paragraph simultaneously), requires locking (hurts parallelism), tight coupling (agents directly access shared structure). **Message Passing Approach:** Agents send edit messages: {agent_id, edit_type, position, content}. Central coordinator applies edits sequentially. Agents receive updated document state. Pros: No race conditions (sequential edits), easier to debug (trace message history), loose coupling, can replay messages for undo. Cons: Higher latency (message → coordinator → apply → broadcast), more complex architecture. **For Real-Time Collaborative Editing - Hybrid Approach Best:** Use message passing for WRITES (edits): Agent makes edit → send EditMessage → coordinator applies → broadcast to all. Use shared memory for READS (viewing): Agents read current document state directly without messages. Why: Edits are infrequent (relative to reads), need consistency. Reads are constant (agents viewing document), need low latency. **Specific Design:** Shared memory: {document: "text...", version: 42, last_edit_time: timestamp}. Messages for edits: EditMessage{agent_id, old_version, edit: {type: insert, position: 100, text: "hello"}}. Coordinator: Receives edit, checks if based on current version, applies edit, increments version, updates shared memory. **Handling Conflicts:** If two agents send edits for version 42 simultaneously: First edit accepted, version → 43. Second edit rejected (based on old version 42). Second agent must fetch version 43, rebase edit, resubmit. **Why Not Pure Shared Memory:** Without coordination, Agent A and Agent B could both insert text at position 100 simultaneously. Result: Corruption or lost edits. Need locking, but locking hurts UX (editor freezes while locked). **Why Not Pure Message Passing:** Agent viewing document would need to send ReadMessage, wait for response. Unacceptable latency for real-time viewing (100ms+). **Conclusion:** Hybrid (message passing for writes, shared memory for reads) balances consistency and performance.',
    keyPoints: [
      'Shared memory: Fast reads but race conditions on writes',
      'Message passing: Safe writes but higher latency',
      'Real-time collaboration: Hybrid (message writes, shared reads)',
      'Coordinator pattern for sequential edit application',
    ],
  },
  {
    id: 'maas-memory-q-2',
    question:
      'Design a memory system for a long-running multi-agent application that needs to remember conversations and decisions across multiple sessions (days apart). How do you handle memory growth, retrieval, and relevance decay?',
    hint: 'Think about short-term, long-term, and episodic memory.',
    sampleAnswer:
      '**Three-Tier Memory Architecture:** (1) **Short-Term Memory (STM):** Recent context (last 10-20 interactions). Stored in RAM. Fast access. Cleared after session. Example: Last 10 messages in conversation. (2) **Long-Term Memory (LTM):** Important facts, decisions. Stored in database. Persists across sessions. Example: "User prefers Python", "Project X was approved on 2024-01-15". (3) **Episodic Memory:** Past conversations/events. Stored in database with timestamps. Searchable by time or topic. Example: "On 2024-01-10, discussed API design". **Memory Flow:** New interaction → STM. End of session: Consolidate important items from STM → LTM. Archive full session → Episodic. **Handling Growth:** Problem: LTM and Episodic grow unbounded. Solutions: (A) **Relevance Decay:** Assign importance scores. Decay over time: importance(t) = initial_importance * e^(-λ * days_since). Delete memories below threshold (importance < 0.1). (B) **Periodic Summarization:** Old episodic memories (>30 days): Summarize multiple episodes into single summary. Example: 10 conversations about "API design" → "Discussed API design extensively in January. Key decisions: REST over GraphQL, JWT auth." (C) **Hierarchical Storage:** Recent (< 7 days): Full detail, in fast database. Medium (7-30 days): Compressed/summarized, in standard database. Old (>30 days): Heavily summarized or archived, in cheap storage. (D) **Access-Based Retention:** Track access_count. Frequently accessed memories retained longer. Unused memories deleted sooner. **Retrieval Strategy:** (1) Always search STM first (recent is often most relevant). (2) Semantic search in LTM: Convert query to embedding, find similar memories. (3) Time-based search in Episodic: "What did we discuss last Tuesday?" (4) Combine results: Recent memories weighted higher. **Implementation:** class MemorySystem: stm: List[Memory] (max_size=20). ltm: Database (with embeddings for semantic search). episodic: Database (with timestamps). async def remember(event): stm.append(event). if len(stm) > 20: oldest = stm.pop(0). if is_important(oldest): promote_to_ltm(oldest). async def recall(query): recent = search_stm(query). facts = semantic_search_ltm(query, top_k=5). episodes = search_episodic(query, days=30). return combine([recent, facts, episodes]). async def consolidate_session(): for item in stm: if item.importance > 0.7: save_to_ltm(item). save_session_to_episodic(stm). stm.clear(). **Relevance Decay Implementation:** Every week: for memory in ltm: memory.importance *= 0.9. if memory.importance < 0.1: delete(memory). **Benefits:** Bounded memory growth. Fast retrieval (recent in RAM, old in DB). Important memories retained. Old, unimportant memories naturally forgotten.',
    keyPoints: [
      'Three-tier: Short-term (recent), Long-term (facts), Episodic (history)',
      'Relevance decay: Older memories lose importance over time',
      'Periodic summarization to compress old memories',
      'Access-based retention: Keep frequently used memories',
    ],
  },
  {
    id: 'maas-memory-q-3',
    question:
      'Two agents are updating shared state simultaneously causing race conditions. Design a conflict resolution strategy using optimistic locking or CRDTs. Show how it handles the scenario where Agent A sets status="processing" and Agent B sets status="complete" at the same time.',
    hint: 'Consider version numbers or conflict-free data structures.',
    sampleAnswer:
      '**Problem:** Agent A reads state: {status: "pending", version: 1}. Agent B reads state: {status: "pending", version: 1}. Agent A writes: {status: "processing", version: 2}. Agent B writes: {status: "complete", version: 2}. One update lost! **Solution 1 - Optimistic Locking (Version-Based):** Each state has version number. Updates must specify: (old_version, new_state). System only applies update if current version == old_version. Implementation: def update_state(old_version, new_state): with lock: if current_state.version == old_version: current_state = new_state. current_state.version += 1. return SUCCESS. else: return CONFLICT (current version is {current_state.version}). **Applying to Scenario:** Agent A: update_state(old_version=1, status="processing") → SUCCESS, version→2. Agent B: update_state(old_version=1, status="complete") → CONFLICT (current version is 2). Agent B: Must retry. Fetch latest state (version 2, status="processing"). Decide: Is "complete" still valid given current state is "processing"? Yes → update_state(old_version=2, status="complete") → SUCCESS, version→3. **Solution 2 - Last-Write-Wins with Timestamps:** Each update has timestamp. Latest timestamp wins. Agent A: {status: "processing", timestamp: 100}. Agent B: {status: "complete", timestamp: 101}. System: B\'s timestamp is later → apply B\'s update. Final state: "complete". Downside: Not always semantically correct. Maybe "processing" → "complete" makes sense, but skipping "processing" entirely doesn\'t. **Solution 3 - CRDT (Conflict-Free Replicated Data Type):** Use data structures that can be merged automatically. For status: Use state machine + causal ordering. Track state transitions: pending → processing → complete. Each agent tracks: current_state + observed_transitions. Merge rule: Take "furthest" state in transition order. Agent A: pending → processing (observed). Agent B: pending → complete (observed). Merge: "complete" is further along → final state is "complete". But also record that "processing" was seen (for audit). **Solution 4 - Operational Transform:** Track operations, not just final state. Agent A: Operation{type: set_status, value: "processing"}. Agent B: Operation{type: set_status, value: "complete"}. System: Apply both operations in causal order. If B happened after A: "processing" → "complete". If simultaneous: Use priority rules (e.g., "complete" has higher priority than "processing"). **Best Approach for Status Field:** Optimistic locking (Solution 1) is clearest. Agents must handle CONFLICT and retry with latest state. Ensures agents make decisions based on current reality. **Implementation:** class VersionedState: state: Dict. version: int. def update(self, agent_id, old_version, updates): if old_version != self.version: return {success: False, error: "Version mismatch", current_version: self.version}. self.state.update(updates). self.version += 1. return {success: True, new_version: self.version}. **Agent Retry Logic:** max_retries = 3. for attempt in range(max_retries): current = fetch_state(). new_state = agent_logic(current). result = update_state(current.version, new_state). if result.success: break. else: sleep(0.1 * 2**attempt). # Exponential backoff',
    keyPoints: [
      'Optimistic locking: Use version numbers, reject stale updates',
      'Last-write-wins: Simple but can lose semantics',
      'CRDTs: Automatically merge conflicting updates',
      'Always handle conflicts: Retry with latest state',
    ],
  },
];
