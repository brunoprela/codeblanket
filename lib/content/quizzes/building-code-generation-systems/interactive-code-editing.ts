/**
 * Quiz questions for Interactive Code Editing section
 */

export const interactivecodeeditingQuiz = [
  {
    id: 'bcgs-interactive-q-1',
    question:
      'Design a conversation state management system for interactive code editing that maintains context across multiple turns. What information must be preserved, and how would you prevent the context from growing unbounded?',
    hint: 'Consider message history, file state, applied changes, and context window limits.',
    sampleAnswer:
      "**Conversation State Management:** **Must Preserve:** 1) **File State** - Original content (for undo), Current content (after edits), Pending changes (not yet applied). 2) **Message History** - User requests and AI responses. Needed for context continuity. 3) **Change History** - Applied edits with timestamps, Undo/redo stack. 4) **Session Metadata** - File path, Language, User preferences. **Preventing Unbounded Growth:** **1) Sliding Window** - Keep only recent N messages (e.g., last 10). ```python\nclass SessionState:\n    def __init__(self, max_messages=10):\n        self.messages = deque(maxlen=max_messages)  # Auto-drops old\n    \n    def add_message(self, msg):\n        self.messages.append(msg)  # Oldest auto-removed``` **2) Summarization** - Periodically summarize old conversations: ```python\nif len(messages) > 20:\n    # Summarize messages 1-10\n    summary = llm_summarize(messages[:10])\n    messages = [summary] + messages[10:]  # Keep recent, summarize old``` **3) Smart Truncation** - Keep critical messages even if old: Recent messages (always keep), Messages with unapplied edits (keep until resolved), Initial problem statement (provides context). **4) File State Compression** - Don't store full file content in every message: Store diffs, not full content for history, Keep only: original + current + pending diffs. **5) Token Budget Management** - Track tokens used by state: ```python\nclass TokenBudgetState:\n    def __init__(self, max_tokens=4000):\n        self.max_tokens = max_tokens\n    \n    def build_context(self):\n        context = []\n        tokens_used = 0\n        \n        # Add in priority order\n        # 1. Current file (required)\n        context.append(current_file)\n        tokens_used += count_tokens(current_file)\n        \n        # 2. Recent messages (as many as fit)\n        for msg in reversed(messages):\n            msg_tokens = count_tokens(msg)\n            if tokens_used + msg_tokens < self.max_tokens:\n                context.insert(1, msg)\n                tokens_used += msg_tokens\n            else:\n                break``` **Example:** After 50 turns of conversation (10,000 tokens), compress to: Current file state (2,000 tokens), Summary of old discussion (500 tokens), Last 5 messages (1,500 tokens) = 4,000 tokens total.",
    keyPoints: [
      'Preserve: file states, message history, change history',
      'Use sliding window for message history',
      'Summarize old messages periodically',
      'Track token budget and prioritize recent/important content',
    ],
  },
  {
    id: 'bcgs-interactive-q-2',
    question:
      'When should your interactive editor ask clarifying questions vs. making assumptions and generating edits? Design a decision framework with specific criteria and examples.',
    hint: 'Consider ambiguity level, risk of wrong assumptions, and user experience.',
    sampleAnswer:
      '**Clarifying Question Decision Framework:** **Ask Questions When:** **1) High Ambiguity** - Multiple valid interpretations: ```\\nUser: "Make it faster"\\n↓\\nAI: "What would you like me to optimize?\\n1. Algorithm complexity (O(n²) → O(n))\\n2. I/O operations (add caching)\\n3. Database queries (add indexes)"``` Criteria: If >2 reasonable approaches with different outcomes. **2) Missing Critical Information** - Can\'t proceed without details: ```\\nUser: "Add authentication"\\n↓\\nAI: "What authentication method?\\n- JWT tokens\\n- Session-based\\n- OAuth\\n- API keys"``` Criteria: Decision fundamentally changes implementation. **3) High-Risk Changes** - Wrong assumption could break system: ```\\nUser: "Change the database schema"\\n↓\\nAI: "This will affect existing data. Should I:\\n1. Create migration script\\n2. Add backward compatibility\\n3. Create new tables (keep old)"``` Criteria: Affects data integrity or backward compatibility. **4) Conflicting Requirements** - Current code conflicts with request: ```\\nUser: "Make function async"\\n↓\\nAI: "This function is called from 5 sync contexts. Should I:\\n1. Update all callers to async\\n2. Create async version (keep sync)\\n3. Make callers run in event loop"``` **Make Assumptions When:** **1) Low Ambiguity** - One obvious interpretation: ```\\nUser: "Add type hints"\\n↓\\nAI: *Generates type hints*  # Clear what to do\\n``` **2) Easy to Undo** - User can quickly reject if wrong: ```\\nUser: "Fix the typo"\\n↓\\nAI: *Proposes specific fix*\\nUser can reject if wrong variable``` **3) Following Patterns** - Clear pattern from codebase: ```\\nUser: "Add error handling"\\n↓\\nAI: *Uses project\'s standard error pattern*  # Established pattern\\n``` **4) Low-Risk Additions** - Won\'t break existing functionality: ```\\nUser: "Add docstring"\\n↓\\nAI: *Generates docstring*  # Can\'t break code\\n``` **Decision Algorithm:** ```python\\ndef should_ask_clarifying_question(request, context):\\n    ambiguity_score = measure_ambiguity(request)\\n    risk_score = measure_risk(request, context)\\n    \\n    if ambiguity_score > 0.7:  # Very ambiguous\\n        return True, generate_clarifying_questions(request)\\n    \\n    if risk_score > 0.8:  # High risk\\n        return True, explain_risks(request)\\n    \\n    # Proceed with best guess\\n    return False, None``` **Example Scenarios:** "Add error handling" → Low ambiguity (use project pattern), make assumption. "Improve performance" → High ambiguity, ask question. "Delete this function" → High risk (might be used elsewhere), ask confirmation.',
    keyPoints: [
      'Ask when: high ambiguity (>2 interpretations), missing critical info, high risk',
      'Assume when: clear intent, low risk, easy to undo, following patterns',
      'Decision based on ambiguity score + risk score',
      'Always allow quick rejection if assumption wrong',
    ],
  },
  {
    id: 'bcgs-interactive-q-3',
    question:
      'Design an undo/redo system for multi-turn code editing that handles not just changes but also the conversation context. What makes this more complex than simple file undo, and how would you implement it?',
    hint: 'Consider conversation state, multiple edits per turn, and dependencies between turns.',
    sampleAnswer:
      '**Multi-Turn Undo/Redo System:** **Why More Complex Than File Undo:** **1) Conversation Context** - Undoing changes should also undo conversation: ```\\nTurn 1: "Add error handling" → edits applied\\nTurn 2: "Now make those errors more specific" → edits applied\\nUndo Turn 2 → revert edits AND conversation\\nUndo Turn 1 → revert original edits AND conversation``` Simple file undo doesn\'t track conversation context. **2) Multi-Edit Transactions** - One turn might generate multiple edits: ```\\nTurn 1: "Rename user to customer" → 15 files edited\\nUndo should revert ALL 15, not just one``` **3) Dependencies Between Turns** - Later turns depend on earlier: ```\\nTurn 1: Add function X\\nTurn 2: Call function X from function Y\\nUndo Turn 1 → Must also undo Turn 2 (depends on X)``` **Implementation:** ```python\\n@dataclass\\nclass EditTurn:\\n    """Represents one conversation turn."""\\n    turn_id: int\\n    user_message: str\\n    ai_response: str\\n    edits: List[SearchReplace]\\n    file_state_before: str\\n    file_state_after: str\\n    depends_on: List[int]  # Turn IDs this depends on\\n\\nclass InteractiveUndoSystem:\\n    def __init__(self):\\n        self.turns: List[EditTurn] = []\\n        self.current_index = -1\\n    \\n    def apply_turn(self, turn: EditTurn):\\n        # Add new turn\\n        self.turns = self.turns[:self.current_index+1]  # Remove future turns\\n        self.turns.append(turn)\\n        self.current_index = len(self.turns) - 1\\n    \\n    def undo(self) -> Optional[EditTurn]:\\n        """Undo last turn, including dependent turns."""\\n        if self.current_index < 0:\\n            return None\\n        \\n        current_turn = self.turns[self.current_index]\\n        \\n        # Find all turns that depend on this one\\n        dependent_turns = self._find_dependent_turns(current_turn.turn_id)\\n        \\n        if dependent_turns:\\n            # Must undo dependent turns first\\n            print(f"This will also undo {len(dependent_turns)} dependent turns")\\n            for dep_turn in reversed(dependent_turns):\\n                self._revert_turn(dep_turn)\\n        \\n        # Undo the turn\\n        self._revert_turn(current_turn)\\n        self.current_index -= 1\\n        \\n        return self.turns[self.current_index] if self.current_index >= 0 else None\\n    \\n    def redo(self) -> Optional[EditTurn]:\\n        """Redo next turn."""\\n        if self.current_index >= len(self.turns) - 1:\\n            return None\\n        \\n        self.current_index += 1\\n        turn = self.turns[self.current_index]\\n        self._apply_turn(turn)\\n        return turn\\n    \\n    def _find_dependent_turns(self, turn_id: int) -> List[EditTurn]:\\n        """Find turns that depend on given turn."""\\n        dependent = []\\n        for turn in self.turns[turn_id+1:]:\\n            if turn_id in turn.depends_on:\\n                dependent.append(turn)\\n        return dependent\\n    \\n    def _revert_turn(self, turn: EditTurn):\\n        """Revert file to state before turn."""\\n        write_file(turn.file_state_before)\\n        # Also remove turn from conversation history display\\n    \\n    def _apply_turn(self, turn: EditTurn):\\n        """Apply turn edits."""\\n        write_file(turn.file_state_after)\\n``` **Example:** ```\\nTurn 1: Add function calculate_total\\nTurn 2: Use calculate_total in process_order (depends on Turn 1)\\nTurn 3: Add error handling to process_order\\n\\nUndo Turn 2 → Must undo Turn 3 first (depends on Turn 2\'s changes)\\nUndo Turn 1 → Must undo Turns 2 and 3 (both depend on Turn 1)\\n```',
    keyPoints: [
      'Track conversation context with each turn',
      'Group multi-file edits as single undoable transaction',
      'Detect dependencies between turns',
      'Undo dependent turns automatically when undoing base turn',
    ],
  },
];
