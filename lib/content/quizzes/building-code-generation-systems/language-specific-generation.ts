/**
 * Quiz questions for Language-Specific Generation section
 */

export const languagespecificgenerationQuiz = [
  {
    id: 'bcgs-langspec-q-1',
    question:
      'Why is generating idiomatic code in each language more important than just generating syntactically correct code? Give concrete examples of non-idiomatic vs idiomatic code in Python and JavaScript.',
    hint: 'Consider readability, maintainability, performance, and community expectations.',
    sampleAnswer:
      '**Why Idiomatic Code Matters:** **1) Readability** - Developers expect certain patterns. Non-idiomatic code is harder to read even if correct. **2) Maintainability** - Idiomatic code follows best practices, easier to modify. **3) Performance** - Idiomatic patterns often more efficient. **4) Community Standards** - Non-idiomatic code looks "wrong" to experienced developers. **Python Examples:** **Non-Idiomatic (Correct but un-Pythonic):** ```python\\n# Creating a list with loop\\nresult = []\\nfor i in range(len(items)):\\n    if items[i].active:\\n        result.append(items[i].name)\\n\\n# Checking for None\\nif user is not None:\\n    process(user)\\n\\n# String formatting\\nmessage = "Hello " + name + ", you have " + str(count) + " items"\\n\\n# File handling\\nf = open("file.txt")\\ndata = f.read()\\nf.close()``` **Idiomatic (Pythonic):** ```python\\n# List comprehension\\nresult = [item.name for item in items if item.active]\\n\\n# Truthy check\\nif user:\\n    process(user)\\n\\n# f-strings\\nmessage = f"Hello {name}, you have {count} items"\\n\\n# Context manager\\nwith open("file.txt") as f:\\n    data = f.read()``` **JavaScript Examples:** **Non-Idiomatic:** ```javascript\\n// Old-style callbacks\\ngetData(function(err, data) {\\n    if (err) return handleError(err);\\n    processData(data, function(err, result) {\\n        if (err) return handleError(err);\\n        saveResult(result);\\n    });\\n});\\n\\n// var and concatenation\\nvar message = "Hello " + name;\\nvar items = [];\\nfor (var i = 0; i < data.length; i++) {\\n    items.push(data[i].id);\\n}``` **Idiomatic (Modern JS):** ```javascript\\n// async/await\\ntry {\\n    const data = await getData();\\n    const result = await processData(data);\\n    await saveResult(result);\\n} catch (err) {\\n    handleError(err);\\n}\\n\\n// const, template literals, map\\nconst message = `Hello $${name}`;\\nconst items = data.map(item => item.id);``` **Impact Examples:** Non-idiomatic Python loop: Works but looks wrong to Python developers, 3x more lines, Harder to modify. Idiomatic list comprehension: Instantly recognizable, Concise, Often faster (optimized in CPython). **Code Review Reaction:** Non-idiomatic: "Why didn\'t you use a list comprehension?" Idiomatic: No comments, clean approval.',
    keyPoints: [
      'Idiomatic code is more readable and maintainable',
      'Python: use comprehensions, f-strings, context managers',
      'JavaScript: use async/await, const/let, arrow functions, map/filter',
      'Non-idiomatic code triggers questions in code review',
    ],
  },
  {
    id: 'bcgs-langspec-q-2',
    question:
      "Design a system that learns a project's specific coding style and conventions from its existing codebase. What patterns would you extract, and how would you apply them to new code generation?",
    hint: 'Consider naming, structure, error handling, and language-specific idioms.',
    sampleAnswer:
      '**Style Learning System:** **1) Pattern Extraction** - **Naming Conventions:** ```python\\ndef analyze_naming(codebase):\\n    patterns = {\\n        "functions": [],\\n        "classes": [],\\n        "constants": [],\\n        "private": []\\n    }\\n    \\n    for file in codebase:\\n        tree = ast.parse(file)\\n        for node in ast.walk(tree):\\n            if isinstance(node, ast.FunctionDef):\\n                patterns["functions"].append(node.name)\\n            elif isinstance(node, ast.ClassDef):\\n                patterns["classes"].append(node.name)\\n    \\n    # Analyze patterns\\n    func_analysis = {\\n        "case": detect_case(patterns["functions"]),  # snake_case\\n        "avg_length": avg_length(patterns["functions"]),\\n        "prefix_patterns": detect_prefixes(patterns["functions"]),  # get_, set_, is_\\n        "verb_first": check_verb_first(patterns["functions"])  # True\\n    }\\n    \\n    return func_analysis``` **Error Handling Patterns:** ```python\\ndef analyze_error_handling(codebase):\\n    patterns = []\\n    \\n    for file in codebase:\\n        tree = ast.parse(file)\\n        for node in ast.walk(tree):\\n            if isinstance(node, ast.Try):\\n                # What exceptions are caught?\\n                exceptions = [handler.type.id for handler in node.handlers]\\n                patterns.append({\\n                    "exceptions": exceptions,\\n                    "has_finally": len(node.finalbody) > 0,\\n                    "raises": extract_raises(node)\\n                })\\n    \\n    # Common pattern: 95% of try blocks catch ValueError, TypeError\\n    return most_common_pattern(patterns)``` **Code Structure Patterns:** ```python\\ndef analyze_structure(codebase):\\n    patterns = {}\\n    \\n    # Import organization\\n    patterns["imports"] = analyze_import_groups(codebase)\\n    # Result: {group1: stdlib, group2: third_party, group3: local}\\n    \\n    # Function organization\\n    patterns["function_order"] = analyze_function_order(codebase)\\n    # Result: {public_first, private_last, helpers_at_bottom}\\n    \\n    # Documentation\\n    patterns["doc_style"] = detect_docstring_style(codebase)\\n    # Result: "Google" style, 90% coverage, includes examples\\n    \\n    return patterns``` **2) Pattern Application** - Use learned patterns in generation prompts: ```python\\ndef generate_with_project_style(task, learned_style):\\n    style_prompt = f"""Generate code following these project conventions:\\n\\nNaming:\\n- Functions: {learned_style["naming"]["functions"]["case"]} case\\n- Average function name length: {learned_style["naming"]["avg_length"]}\\n- Common prefixes: {", ".join(learned_style["naming"]["prefixes"])}\\n\\nError Handling:\\n- Common exceptions: {", ".join(learned_style["error_handling"]["exceptions"])}\\n- Always include finally blocks: {learned_style["error_handling"]["has_finally"]}\\n\\nDocumentation:\\n- Style: {learned_style["docs"]["style"]}\\n- Include examples: {learned_style["docs"]["include_examples"]}\\n\\nImport Organization:\\n{format_import_rules(learned_style["imports"])}\\n\\nTask: {task}\\n"""``` **3) Validation Against Style:** ```python\\ndef validate_matches_style(generated_code, learned_style):\\n    violations = []\\n    \\n    tree = ast.parse(generated_code)\\n    \\n    # Check naming\\n    for node in ast.walk(tree):\\n        if isinstance(node, ast.FunctionDef):\\n            if not matches_case(node.name, learned_style["naming"]["case"]):\\n                violations.append(f"Function {node.name} doesn\'t match {learned_style[\'naming\'][\'case\']} case")\n    \n    # Check error handling\n    for try_block in find_try_blocks(tree):\n        expected_exceptions = learned_style["error_handling"]["exceptions"]\n        actual_exceptions = [h.type.id for h in try_block.handlers]\n        if not set(actual_exceptions).issuperset(expected_exceptions):\n            violations.append("Missing common exceptions")\n    \n    return violations\n``` **4) Example Application:** ```\nLearned Style: \n - Functions: snake_case, avg 15 chars, verb - first\n - Error handling: Always catch ValueError, TypeError\n - Docstrings: Google style with examples\n\nGenerated(matching style): \ndef calculate_user_score(user_id: int) -> float: \n    """Calculate the score for a user.\n    \n    Args: \n        user_id: The user ID\n    \n    Returns: \n        User score as float\n    \n    Example: \n        >>> calculate_user_score(123) \n        85.5\n    \n    Raises: \n        ValueError: If user_id is negative\n        TypeError: If user_id is not an integer\n    """\n    try: \n        # implementation\n    except (ValueError, TypeError) as e:\n        logger.error(f"Error calculating score: { e }")\n        raise\n```',
    keyPoints: [
      'Extract patterns: naming conventions, error handling, structure',
      'Analyze majority patterns across codebase',
      'Apply patterns via enhanced generation prompts',
      'Validate generated code matches learned style',
    ],
  },
  {
    id: 'bcgs-langspec-q-3',
    question:
      'You need to convert code from Python to TypeScript while preserving functionality and using TypeScript idioms. What are the key challenges, and how would you ensure the conversion is correct?',
    hint: 'Consider type systems, async patterns, error handling, and runtime differences.',
    sampleAnswer:
      '**Python → TypeScript Conversion Challenges:** **1) Type System Differences** - **Python (gradual typing):** ```python\\ndef process(data: List[Dict[str, Any]]) -> Optional[str]:\\n    if not data:\\n        return None\\n    return data[0].get("name", "Unknown")``` **TypeScript (strict typing):** ```typescript\\ninterface DataItem {\\n    name?: string;\\n    [key: string]: any;\\n}\\n\\nfunction process(data: DataItem[]): string | null {\\n    if (data.length === 0) {\\n        return null;\\n    }\\n    return data[0].name ?? "Unknown";\\n}``` Challenge: TypeScript needs explicit interface definitions. **2) Async/Await Patterns** - **Python:** ```python\\nasync def fetch_user(user_id): \\n    user = await db.get_user(user_id) \\n    return user``` **TypeScript:** ```typescript\\nasync function fetchUser(userId: number): Promise<User> { \\n    const user = await db.getUser(userId); \\n    return user; \\n } ``` Challenge: TypeScript requires Promise<T> return types. **3) Error Handling** - **Python (exceptions):** ```python\\ndef divide(a, b): \\n    if b == 0: \\n        raise ValueError("Division by zero")\\n    return a / b\\n\\ntry:\\n    result = divide(10, 0)\\nexcept ValueError as e:\\n    print(f"Error: {e}")``` **TypeScript (exceptions or Result types):** ```typescript\\n// Option 1: Exceptions (like Python)\\nfunction divide(a: number, b: number): number {\\n    if (b === 0) {\\n        throw new Error("Division by zero");\\n    }\\n    return a / b;\\n}\\n\\ntry {\\n    const result = divide(10, 0);\\n} catch (e) {\\n    console.log(`Error: $${e.message}`);\\n}\\n\\n// Option 2: Result type (more TypeScript-y)\\ntype Result<T> = { ok: true; value: T } | { ok: false; error: string };\\n\\nfunction divide(a: number, b: number): Result<number> {\\n    if (b === 0) {\\n        return { ok: false, error: "Division by zero" };\\n    }\\n    return { ok: true, value: a / b };\\n}``` **4) None/null/undefined** - Python\'s None → TypeScript null or undefined. Decision needed! **5) List/Dict Differences** - Python: Flexible, runtime checks. TypeScript: Needs interfaces. **Conversion Strategy:** **1) Analyze Python Code:** ```python\\ndef analyze_for_conversion(python_code):\\n    analysis = {\\n        "types_used": extract_types(python_code),\\n        "async_functions": find_async_functions(python_code),\\n        "exceptions_raised": find_exceptions(python_code),\\n        "data_structures": find_data_structures(python_code)\\n    }``` **2) Generate TypeScript Interfaces:** ```python\\ndef generate_interfaces(types_used):\\n    interfaces = []\\n    for type_name, fields in types_used.items():\\n        interface = f"interface {type_name} {{\\\\n"\\n        for field, field_type in fields.items():\\n            ts_type = python_type_to_ts(field_type)\\n            interface += f"  {field}: {ts_type};\\\\n"\\n        interface += "}"\\n        interfaces.append(interface)``` **3) Convert Async Properly:** Add Promise<T> to async functions, Convert await calls. **4) Validation:** ```python\\ndef validate_conversion(python_code, typescript_code):\\n    # Run tests on both\\n    python_result = run_python_tests(python_code)\\n    ts_result = run_typescript_tests(typescript_code)\\n    \\n    # Compare outputs\\n    assert_equal(python_result, ts_result)``` **Example Conversion:** ```python\\n# Python\\nasync def get_user_posts(user_id: int) -> List[Dict[str, str]]:\\n    user = await db.fetch_user(user_id)\\n    if not user:\\n        raise ValueError("User not found")\\n    return await db.fetch_posts(user.id)\\n\\n# TypeScript\\ninterface Post {\\n    id: string;\\n    title: string;\\n    content: string;\\n}\\n\\nasync function getUserPosts(userId: number): Promise<Post[]> {\\n    const user = await db.fetchUser(userId);\\n    if (!user) {\\n        throw new Error("User not found");\\n    }\\n    return await db.fetchPosts(user.id);\\n}``` **Correctness Validation:** 1) Type check with tsc, 2) Run equivalent tests, 3) Compare outputs, 4) Manual review of idioms.',
    keyPoints: [
      'Define TypeScript interfaces for Python Dict types',
      'Add Promise<T> return types for async functions',
      'Convert error handling (exceptions or Result types)',
      'Validate by running equivalent tests on both versions',
    ],
  },
];
