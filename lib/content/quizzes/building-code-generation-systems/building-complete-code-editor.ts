/**
 * Quiz questions for Building a Complete Code Editor section
 */

export const buildingcompletecodeeditorQuiz = [
  {
    id: 'bcgs-completeeditor-q-1',
    question:
      "Design the architecture for a production-ready code editor like Cursor. What are the core components, how do they interact, and how would you ensure they're loosely coupled for maintainability?",
    hint: 'Consider separation of concerns, modularity, and communication between components.',
    sampleAnswer:
      '**Production Code Editor Architecture:** **Core Components:** **1) File Management Layer** - Responsibilities: Read/write files, Watch for changes, Handle permissions, Backup/restore. Interface: ```python\nclass FileManager:\n    def read_file(self, path: str) -> str\n    def write_file(self, path: str, content: str)\n    def watch_file(self, path: str, callback)\n    def create_backup(self, path: str) -> str``` **2) Code Analysis Layer** - Responsibilities: Parse code (AST), Extract types/functions, Find dependencies, Build project graph. Interface: ```python\nclass CodeAnalyzer:\n    def parse(self, code: str, language: str) -> AST\n    def extract_symbols(self, code: str) -> List[Symbol]\n    def find_references(self, symbol: str) -> List[Location]\n    def get_dependencies(self, file: str) -> Set[str]``` **3) Generation Engine** - Responsibilities: Generate code from prompts, Edit existing code, Validate generated code, Retry on failures. Interface: ```python\nclass GenerationEngine:\n    def generate(self, prompt: str, context: Context) -> str\n    def edit(self, code: str, instruction: str) -> List[Edit]\n    def validate(self, code: str) -> ValidationResult``` **4) Execution Layer** - Responsibilities: Run code in sandbox, Execute tests, Measure performance, Handle timeouts. Interface: ```python\nclass ExecutionEngine:\n    def execute(self, code: str, timeout: int) -> ExecutionResult\n    def run_tests(self, code: str, tests: str) -> TestResults``` **5) Session Manager** - Responsibilities: Maintain conversation state, Track edit history, Manage undo/redo, Store user preferences. Interface: ```python\nclass SessionManager:\n    def create_session(self, file: str) -> Session\n    def add_message(self, session_id: str, message: Message)\n    def apply_edit(self, session_id: str, edit: Edit)\n    def undo(self, session_id: str)``` **6) UI Layer** - Responsibilities: Display code, Show diffs, Collect user input, Provide feedback. Interface: ```python\nclass UILayer:\n    def show_code(self, code: str, highlights: List[Range])\n    def show_diff(self, before: str, after: str)\n    def get_user_input(self, prompt: str) -> str\n    def show_progress(self, message: str)``` **Component Interaction:** ```\nUser Input → UI Layer → Session Manager → Generation Engine → Code Analyzer\n                                ↓                    ↓\n                          File Manager ← Execution Engine\n``` **Loose Coupling via Interfaces:** ```python\n# Define interfaces\nclass IFileManager(ABC):\n    @abstractmethod\n    def read_file(self, path: str) -> str: ...\n\nclass IGenerationEngine(ABC):\n    @abstractmethod\n    def generate(self, prompt: str) -> str: ...\n\n# Components depend on interfaces, not implementations\nclass Editor:\n    def __init__(\n        self,\n        file_manager: IFileManager,\n        generation_engine: IGenerationEngine,\n        # ... other interfaces\n    ):\n        self.file_manager = file_manager\n        self.generation_engine = generation_engine\n``` **Event Bus for Communication:** ```python\nclass EventBus:\n    def emit(self, event: Event)\n    def subscribe(self, event_type: str, handler)\n\n# Components communicate via events\nfile_manager.subscribe("file_changed", lambda e: analyzer.reparse(e.file))\neditor.subscribe("edit_applied", lambda e: session.add_to_history(e.edit))``` **Benefits:** 1) Can swap implementations (local LLM vs API), 2) Easy to test (mock interfaces), 3) Can add features without modifying core, 4) Clear responsibilities.',
    keyPoints: [
      'Core components: FileManager, CodeAnalyzer, GenerationEngine, ExecutionEngine, SessionManager, UI',
      'Define clear interfaces for each component',
      'Use dependency injection and interface-based coupling',
      'Event bus for cross-component communication',
    ],
  },
  {
    id: 'bcgs-completeeditor-q-2',
    question:
      'How would you design the user experience for reviewing and accepting code changes? Consider both immediate feedback and async operations. What makes a good confirmation flow?',
    hint: 'Think about preview, undo, progressive disclosure, and different user skill levels.',
    sampleAnswer:
      '**Code Change Review UX Design:** **1) Immediate Feedback Flow** - **Step 1: Show Intent** - User: "Add error handling", AI: "I\'ll add try-catch blocks to handle ValueError and TypeError." (Explain what will happen). **Step 2: Generate & Show Preview** - Show diff immediately: ```diff\n- def process(data):\n+ def process(data):\n+     try:\n         result = transform(data)\n         return result\n+     except (ValueError, TypeError) as e:\n+         logger.error(f"Error: {e}")\n+         raise\n``` Highlight: Lines removed (red), Lines added (green), Context (gray). **Step 3: Action Buttons** - [Accept] [Reject] [Modify] [Ask Questions]. **2) Progressive Disclosure** - Beginner users: Simple diff with colors, "Accept" or "Try Again" buttons. Advanced users: Full diff with line numbers, [Accept] [Reject] [Modify] [Show Full File] [Run Tests], Keyboard shortcuts (Cmd+Enter = Accept). **3) Async Operation Handling** - For slow operations (test execution): ```\n[Generating changes...] ━━━━━━━━━━━━━━━━━━━━ 50%\n\n[Changes ready! Running tests...] ━━━━━━━━━━━━━━━━━━━━ 80%\n\n[Tests passed ✓] Ready to apply.\n[Accept] [Review Changes]\n``` Keep user informed, Don\'t block UI, Allow cancellation. **4) Risk-Aware Confirmation** - **Low Risk (add comment, rename variable):** - Show inline preview, Single click to apply, Auto-apply after 3 seconds (with countdown). **Medium Risk (add function, modify logic):** - Show full diff, Require explicit accept, Highlight changed lines. **High Risk (delete code, change API):** - Show diff + impact analysis: "This will affect 5 files", Require explicit confirmation, Show affected files list, Option to review each file. **5) Undo Always Available** - Prominent [Undo] button after any apply, Show what was changed: "Undone: Added error handling to process()", Keyboard shortcut (Cmd+Z). **6) Detailed Review Option** - [▼ Show Details] expands to: Full file diff, Files affected, Test results, Performance impact. **7) Feedback Loop** - After accept: "Changes applied ✓ [Undo]", After reject: "What would you like differently?" (helps AI improve). **Example Flow:** ```\n1. User: "Add authentication"\n2. AI: "I\'ll add JWT authentication with login/logout endpoints."\n3. [Preview shows diff in 3 files]\n4. User: "Show me routes.py"\n5. [Expands routes.py diff]\n6. User: "Change to session-based instead"\n7. [AI regenerates, shows new diff]\n8. User: [Accept]\n9. [Applying changes... ✓ Applied]\n10. [Undo button available]\n``` **Bad UX to Avoid:** ❌ Applying changes without preview, ❌ No way to undo, ❌ Blocking UI during generation, ❌ No indication of what changed, ❌ Can\'t review before accepting.',
    keyPoints: [
      'Show preview before any changes (diff with colors)',
      'Progressive disclosure: simple for beginners, detailed for experts',
      'Risk-aware: low risk = quick apply, high risk = explicit confirmation',
      'Always provide undo and clear feedback',
    ],
  },
  {
    id: 'bcgs-completeeditor-q-3',
    question:
      'Your code editor has users reporting "it\'s slow" when editing large files (>1000 lines). Design a comprehensive performance optimization strategy covering all layers of the system.',
    hint: 'Consider prompt optimization, caching, incremental updates, and async processing.',
    sampleAnswer:
      '**Performance Optimization Strategy:** **1) Prompt Layer Optimization** - **Problem:** Sending entire 1000-line file in every request = expensive + slow. **Solutions:** a) **Smart Context Window:** Only send edited section + 50 lines context: ```python\ndef get_relevant_context(file, edit_line, window=50):\n    start = max(0, edit_line - window)\n    end = min(len(file.lines), edit_line + window)\n    return file.lines[start:end]``` b) **Function-Level Context:** If editing function, send only that function + its dependencies: ```python\ndef get_function_context(file, function_name):\n    function_code = extract_function(file, function_name)\n    dependencies = find_dependencies(function_name)\n    return function_code + dependencies``` c) **Summarize Distant Code:** Replace non-relevant functions with summaries: ```python\n# Instead of full implementation\ndef process_data(items):  # [50 lines - processes user data]\n    ...\n``` **2) Caching Layer** - **Semantic Caching:** Cache similar requests: ```python\nclass SemanticCache:\n    def get(self, prompt: str, context: str) -> Optional[str]:\n        # Check if similar prompt was asked\n        for cached in self.cache:\n            if similarity(prompt, cached.prompt) > 0.9:\n                if similarity(context, cached.context) > 0.85:\n                    return cached.result\n``` **Prompt Caching (Claude):** Cache common project context: ```python\n# Cache project structure, type definitions\nCACHED_CONTEXT = """\nProject: MyProject\n[project structure]\n[type definitions]\n[common patterns]\n"""  # Cached by Claude, doesn\'t count toward tokens``` **Result Caching:** Cache generated edits for identical requests. **3) Incremental Updates** - **Problem:** Reparsing entire file on every change. **Solution:** Incremental parser: ```python\nclass IncrementalParser:\n    def __init__(self, file_content):\n        self.ast = parse(file_content)\n        self.lines = file_content.split("\\n")\n    \n    def update(self, start_line, end_line, new_content):\n        # Only reparse changed section\n        affected_nodes = find_nodes_in_range(self.ast, start_line, end_line)\n        \n        # Reparse only affected nodes\n        new_nodes = parse(new_content)\n        \n        # Update AST incrementally\n        self.ast.replace_nodes(affected_nodes, new_nodes)``` **4) Async Processing** - **Problem:** UI blocks during generation. **Solution:** Background generation: ```python\nasync def process_request_async(request):\n    # Show immediate feedback\n    ui.show_status("Generating...")\n    \n    # Generate in background\n    result = await generate_in_background(request)\n    \n    # Update UI when ready\n    ui.show_preview(result)\n\n# User can continue editing while generation happens\n``` **5) Lazy Loading** - Don\'t load entire project on startup: ```python\nclass LazyProject:\n    def __init__(self, root):\n        self.root = root\n        self.files = {}  # Lazy-loaded\n    \n    def get_file(self, path):\n        if path not in self.files:\n            self.files[path] = load_and_parse(path)\n        return self.files[path]``` **6) Diff Optimization** - **Problem:** Generating diff for large file is slow. **Solution:** Use efficient diff algorithm: ```python\nfrom diff_match_patch import diff_match_patch\n\ndmp = diff_match_patch()\ndiffs = dmp.diff_main(original, modified)\ndmp.diff_cleanupSemantic(diffs)  # O(n) cleanup\n``` **7) Parallelization** - **Multi-File Edits:** Process files in parallel: ```python\nimport asyncio\n\nasync def edit_multiple_files(files, instruction):\n    tasks = [\n        generate_edit(file, instruction)\n        for file in files\n    ]\n    results = await asyncio.gather(*tasks)\n    return results``` **8) Metrics & Monitoring** - Track: Time to first response, Prompt token count, Generation time, Cache hit rate. **Before Optimization:** Edit large file: 15s (send 1000 lines, generate, parse). **After Optimization:** Edit large file: 2s (send 100 lines context, cache project info, incremental parse, async generation).',
    keyPoints: [
      'Smart context: send only relevant sections, not entire file',
      'Cache: semantic caching for similar requests, prompt caching for project context',
      'Incremental: only reparse changed sections',
      'Async: non-blocking UI, background generation',
    ],
  },
];
