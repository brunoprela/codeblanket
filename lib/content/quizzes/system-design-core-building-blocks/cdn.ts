/**
 * Quiz questions for CDN (Content Delivery Network) section
 */

export const cdnQuiz = [
  {
    id: 'q1',
    question:
      'Your website serves users globally. Users in Asia complain about slow image loading (3-5 seconds). Images are served from your origin server in US-East. Propose a solution.',
    sampleAnswer:
      'SOLUTION: IMPLEMENT CDN. PROBLEM ANALYSIS: High latency for Asian users: US-East to Asia: ~250ms network latency (round-trip). Loading 10 images: 10 × 250ms = 2.5 seconds (network time alone). Plus image download time: Total 3-5 seconds. Root cause: Geographic distance between origin and users. PROPOSED SOLUTION: CDN (Content Delivery Network). Setup: Integrate CDN (CloudFront, Cloudflare, Fastly). Point domain to CDN. Configure CDN to pull from origin. Deploy edge servers in Asia (Tokyo, Singapore, Mumbai). IMPLEMENTATION: Step 1: Sign up for CDN provider. Step 2: Configure origin: Origin URL: your-origin-server.com. Step 3: Update DNS: Old: images.yoursite.com → Origin IP. New: images.yoursite.com → CDN endpoint (d1234.cloudfront.net). Step 4: CDN routes users: Asian users → Asian edge servers. US users → US edge servers. BENEFITS: Latency reduction: Before: Asia → US-East: 250ms. After: Asia → Tokyo edge: 10-20ms. Result: 12× faster (250ms → 20ms). Page load time: Before: 3-5 seconds. After: 300-500ms. 10× improvement! Origin load: Before: Origin serves all image requests. After: CDN serves 90% (only cache misses hit origin). Bandwidth: 90% reduction in origin bandwidth (cost savings). COST ANALYSIS: CDN cost: ~$0.085 per GB (CloudFront Asia). 100 GB/month: $8.50. Origin bandwidth savings: Was paying $0.12 per GB origin bandwidth. Now: 10 GB origin (90% reduction): $1.20. Net: $8.50 (CDN) - $10.80 (savings) = Save $2.30/month. Plus: Faster UX (more users, more revenue). MONITORING: Track metrics: Cache hit rate (target: >90%). Latency by region (should be <50ms). Origin requests (should decrease 90%). Alert if: Cache hit rate <80% (investigate). Latency >100ms in any region.',
    keyPoints: [
      'CDN caches images on edge servers worldwide (reduce latency 12×)',
      'Asian users fetch from Asian edge servers (10-20ms vs 250ms)',
      '90% cache hit rate → 90% less origin bandwidth',
      'Page load time: 3-5 seconds → 300-500ms (10× improvement)',
      'Setup: Configure CDN, update DNS to CDN endpoint, monitor hit rate',
    ],
  },
  {
    id: 'q2',
    question:
      'Explain the difference between Pull CDN and Push CDN. When would you use each?',
    sampleAnswer:
      "PULL CDN (ORIGIN PULL): How it works: Edge server fetches content from origin on first request (lazy loading). Flow: (1) User in Tokyo requests /logo.png. (2) Tokyo edge server: Check cache. (3) Cache miss (first request). (4) Edge fetches from origin (US-East). (5) Edge caches logo.png locally. (6) Edge returns logo to user. (7) Next user in Tokyo: Cache hit (served from Tokyo edge immediately). Characteristics: Automatic: No manual action needed. On-demand: Only requested files cached. Efficient: Popular content cached, unpopular not. PROS: Simple setup: Just point CDN to origin. Automatic: CDN handles caching logic. Storage efficient: Only popular files cached. Dynamic: New content automatically cached when requested. CONS: First request slow: Cache miss hits origin. Unpredictable: Can't guarantee what's cached. Origin dependency: Cache misses require origin to be healthy. WHEN TO USE PULL CDN: Most common use case. Dynamic websites with many pages/images. Content changes frequently. Don't know which content will be popular. Examples: E-commerce sites, blogs, news sites. PUSH CDN: How it works: You proactively upload content to CDN before users request it. Flow: (1) You upload logo.png to CDN (via API/dashboard). (2) CDN distributes to ALL edge servers worldwide. (3) User in Tokyo requests /logo.png. (4) Tokyo edge: Cache hit immediately (already there). (5) No origin request ever needed. Characteristics: Proactive: You control what's cached. Predictable: All content available immediately. Manual: Requires you to push updates. PROS: No cache misses: Content always cached. Predictable performance: Consistent fast loads. No origin dependency: Can work even if origin down. Instant global availability: All edges have content immediately. CONS: Manual effort: Must push every file/update. Storage waste: All content cached even if unpopular. Slower deployments: Time to propagate to all edges (minutes). Management overhead: Track what's pushed, purge old versions. WHEN TO USE PUSH CDN: Static websites (rarely change). Large files (videos, software downloads). Product launches (know traffic spike coming). Marketing campaigns (predictable content). Mobile app binaries. Examples: Static documentation sites, video platforms, software distribution. COMPARISON TABLE: Aspect / Pull CDN / Push CDN: Caching: On-demand (first request) / Proactive (before request). Setup: Automatic / Manual. Popular content: Cached / Cached. Unpopular content: Not cached (efficient) / Cached (wasteful). First request: Slow (cache miss) / Fast (cache hit). Content updates: Automatic (via TTL) / Manual (re-push). Storage: Efficient / Wasteful. Use case: Dynamic sites / Static sites, predictable traffic. HYBRID APPROACH: Many sites use both. Example: Push CDN: Homepage, key landing pages (always fast). Pull CDN: User-generated content, long-tail pages (on-demand). Result: Best of both (fast for important content, efficient for rest). REAL-WORLD EXAMPLES: PULL CDN: Facebook: Billions of user photos (can't push all). Amazon: Millions of product images (pulls on demand). PUSH CDN: Apple: macOS updates (push to all edges before launch). Netflix: New movie releases (push before premiere). VERSIONING WITH PUSH CDN: Problem: Push logo.png, then update it. Old version still cached. Solution: Version URLs: /logo-v1.png, /logo-v2.png. Or query string: /logo.png?v=2. Result: Each version has unique URL, no cache collision. FINAL RECOMMENDATION: Default to Pull CDN (simpler, most flexible). Use Push CDN for: Static sites, predictable traffic, large files. Hybrid: Combine both for optimal performance.",
    keyPoints: [
      'Pull CDN: fetches from origin on first request (lazy, automatic, most common)',
      'Push CDN: you upload content before requests (proactive, manual, no cache misses)',
      'Use Pull for: dynamic sites, unpredictable traffic, many pages',
      'Use Push for: static sites, product launches, large files, predictable traffic',
      'Hybrid approach: Push for critical pages, Pull for long-tail content',
    ],
  },
  {
    id: 'q3',
    question:
      'You updated your logo.png on the origin server, but users still see the old logo (cached on CDN). Walk through 3 solutions to fix this.',
    sampleAnswer:
      'PROBLEM: STALE CACHE. Scenario: Updated logo.png on origin server. CDN edge servers still have old version cached. Users see old logo. Need to force CDN to serve new version. SOLUTION 1: CACHE PURGE (INVALIDATION). How it works: Manually delete cached file from CDN edge servers. Implementation: API call or dashboard: "Purge /logo.png". CDN broadcasts purge command to ALL edge servers. Edge servers delete cached logo.png. Next user request: Cache miss → Fetch from origin → Cache new version. Timing: Purge propagation: 1-5 minutes (all edges updated). User sees new logo: Within 5 minutes. PROS: Immediate effect: All users see new version soon. Works for emergency updates. CONS: Not instant: Takes 1-5 minutes to propagate. Costs money: Some CDNs charge per purge. Can cause traffic spike: All edges refetch simultaneously. Requires action: Must remember to purge on every update. WHEN TO USE: Emergency fixes (wrong logo uploaded). Infrequent updates. Small number of files. SOLUTION 2: VERSIONED URLs (CACHE BUSTING). How it works: Change URL when content changes. Edge servers see new URL → Cache miss → Fetch new version. Implementation OPTIONS: Option A: Query string versioning: Old: /logo.png. New: /logo.png?v=2 (or /logo.png?v=1234567890 timestamp). Option B: Filename versioning: Old: /logo.png. New: /logo-v2.png or /logo-20231015.png. Option C: Path versioning: Old: /assets/logo.png. New: /assets/v2/logo.png. Code example: HTML before: img src="/logo.png". HTML after: img src="/logo.png?v=2". Build process: Automatically append hash of file content. Result: /logo.png?v=abc123 (changes when file changes). PROS: INSTANT: Users see new version immediately (no cache, new URL). FREE: No purge costs. AUTOMATIC: Build tools handle versioning. ZERO DOWNTIME: Old and new versions coexist (gradual rollout). CONS: URL management: Must update all references to file. HTML changes: Need to deploy new HTML with new URLs. Best practice: Automate with build tools (Webpack, Vite). WHEN TO USE: BEST PRACTICE: Use this by default. Frequent updates. Critical for: JavaScript, CSS (breaking changes). SOLUTION 3: REDUCE TTL (TIME TO LIVE). How it works: Set short cache expiration time. After TTL expires, edge refetches from origin. Implementation: HTTP headers from origin: Before: Cache-Control: public, max-age=31536000 (1 year). After: Cache-Control: public, max-age=300 (5 minutes). Result: Edge servers cache for only 5 minutes. After 5 minutes: Edge refetches from origin. Max staleness: 5 minutes. PROS: Automatic: No manual purge needed. Predictable: Know exactly how long until update. CONS: Increased origin load: More frequent refetches. Slower for users: More cache misses. Not suitable for static content (defeats purpose of CDN). WHEN TO USE: Dynamic content: API responses, frequently changing pages. Acceptable staleness: Content can be 5 minutes old. Trade-off: Lower cache hit rate for fresher content. COMPARISON TABLE: Method / Speed / Cost / Effort / Best for: Purge: 1-5 min / Costs $ / Manual / Emergency. Versioned URLs: Instant / Free / Automated / Best practice. Short TTL: Minutes / Free / Automatic / Dynamic content. RECOMMENDED APPROACH: COMBINATION. For static assets (logo, CSS, JS): Use versioned URLs: /logo.png?v=abc123. Long TTL: Cache for 1 year (immutable). Build tool: Automatically append hash (Webpack, Vite). Result: Instant updates, maximum cache hit rate, free. For dynamic content: Short TTL: 5-60 seconds. Pull CDN: On-demand caching. Result: Fresh content, some caching benefit. For emergencies: Purge API: Available as fallback. Use rarely (only for mistakes). REAL-WORLD EXAMPLE: FACEBOOK: Versioned URLs for static assets: /static/logo.abc123.png. Long TTL: 1 year (immutable). Build: Automated hash generation. Purge: Only for emergencies (privacy issues, DMCA). IMPLEMENTATION WITH WEBPACK: webpack.config.js: output: { filename: \'[name].[contenthash].js\',  // Auto-versioning. }. Result: main.abc123.js, logo.def456.png. HTML: Automatically updated by HtmlWebpackPlugin. Deployment: Upload new files → Deploy new HTML → Instant updates. FINAL RECOMMENDATION: USE VERSIONED URLS as primary strategy. Automate with build tools (zero manual effort). Set long TTL for static assets (max cache hit rate). Keep purge API for emergencies only. Educate team: Always version URLs, never purge.',
    keyPoints: [
      'Solution 1: Purge (delete cached file, 1-5 min propagation, costs money)',
      'Solution 2: Versioned URLs (change URL, instant, free, BEST PRACTICE)',
      'Solution 3: Short TTL (auto-expire cache, increased origin load)',
      'Recommended: Versioned URLs + long TTL for static assets',
      'Automate versioning with build tools (Webpack contenthash)',
    ],
  },
];
