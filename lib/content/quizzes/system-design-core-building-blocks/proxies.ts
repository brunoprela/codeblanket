/**
 * Quiz questions for Proxies (Forward & Reverse) section
 */

export const proxiesQuiz = [
  {
    id: 'q1',
    question:
      'Explain the difference between Forward Proxy and Reverse Proxy. Give a real-world example of each.',
    sampleAnswer:
      "FORWARD PROXY VS REVERSE PROXY: FORWARD PROXY (CLIENT-SIDE): Definition: Proxy sits between clients and the internet, forwarding client requests to external servers. Who it serves: Clients (hides client identity from servers). Location: Client's network (corporate network, home network). Client awareness: Clients know proxy exists (configured in browser). Server awareness: Servers don't know client (sees proxy IP). Purpose: Anonymity, content filtering, bypass restrictions. REAL-WORLD EXAMPLE: CORPORATE PROXY. Scenario: Company with 1000 employees. Setup: All employee internet traffic routed through company proxy (proxy.company.com). Proxy configuration: Employees configure browser: HTTP Proxy: proxy.company.com:8080. Or: Automatic via network settings (PAC file). Flow: (1) Employee visits facebook.com. (2) Browser sends request to proxy: GET facebook.com. (3) Proxy checks policy: Is facebook.com allowed? (4) Proxy blocks: Return \"Access Denied\" page. (5) Employee visits work-related site (allowed). (6) Proxy forwards request to external site. (7) External site sees proxy IP (not employee IP). (8) Proxy receives response, forwards to employee. Use cases: Content filtering: Block social media, gambling, adult sites. Logging: Track all employee web access (compliance, security). Bandwidth savings: Cache common resources (OS updates, popular sites). Security: Scan for malware in downloads. Compliance: Ensure employees don't access illegal content. Benefits for company: Productivity: Employees can't waste time on social media. Security: Malware scanned before reaching employee machines. Compliance: Audit trail of all web access. REVERSE PROXY (SERVER-SIDE): Definition: Proxy sits in front of backend servers, forwarding client requests to appropriate servers. Who it serves: Servers (hides server identity from clients). Location: Server's network (in front of backend servers). Client awareness: Clients don't know proxy exists (transparent). Server awareness: Servers know proxy exists (receive proxy requests). Purpose: Load balancing, SSL termination, caching, security. REAL-WORLD EXAMPLE: NGINX FOR E-COMMERCE SITE. Scenario: E-commerce website (example.com) with 10 backend servers. Setup: NGINX reverse proxy in front of backend servers. Client requests go to NGINX first. Architecture: Client → NGINX (reverse proxy) → Backend servers (app1, app2, ..., app10). Flow: (1) Client visits example.com. (2) DNS resolves to NGINX IP (not backend servers). (3) Client sends: GET /products/123 (HTTPS). (4) NGINX receives request. (5) NGINX: SSL termination (decrypt HTTPS → HTTP). (6) NGINX: Check cache. If cached: Return immediately (fast). If not: Forward to backend server. (7) NGINX: Load balance (choose backend server via round-robin). (8) NGINX forwards to backend1: GET http://backend1:8080/products/123. (9) Backend1 processes request (fetch product from database). (10) Backend1 returns response to NGINX. (11) NGINX caches response (for future requests). (12) NGINX encrypts response (HTTP → HTTPS). (13) NGINX sends response to client. Use cases: Load balancing: Distribute traffic across 10 backends. SSL termination: NGINX handles SSL (backends don't need to). Caching: Static content cached at NGINX (images, CSS, JS). Static files: NGINX serves directly (no backend hit). Security: Hide backend IPs (only NGINX exposed). Compression: NGINX compresses responses (gzip). Benefits for site: Performance: SSL offloaded from backends (CPU-intensive). Scalability: Easy to add more backend servers. Security: Backend servers not directly exposed (attack surface reduced). Simplified backends: Backends don't handle SSL/caching (focus on business logic). High availability: If backend crashes, NGINX routes to healthy servers. COMPARISON TABLE: Aspect / Forward Proxy / Reverse Proxy: Serves: Clients / Servers. Location: Client network / Server network. Client knows: Yes (configured) / No (transparent). Server knows: No (sees proxy IP) / Yes (receives from proxy). Purpose: Anonymity, filtering / Load balancing, caching. Example: Corporate proxy, VPN / NGINX, Cloudflare. WHEN TO USE FORWARD PROXY: Corporate network: Content filtering, logging. Privacy: Hide IP address (VPN, Tor). Bypass restrictions: Access geo-blocked content. Bandwidth: Cache common resources. WHEN TO USE REVERSE PROXY: Web applications: Load balancing, SSL termination. Microservices: Single entry point (like API Gateway). High traffic: Caching, compression. Security: Hide backend servers, DDoS protection. BOTH TOGETHER: Some architectures use both. Example: Corporate employee (behind forward proxy) accesses website (behind reverse proxy). Flow: Employee → Forward Proxy (corporate) → Internet → Reverse Proxy (website) → Backend Server. FINAL RECOMMENDATION: Forward Proxy: Use for client-side needs (filtering, anonymity). Reverse Proxy: Use for server-side needs (load balancing, caching). Most web applications use reverse proxy (NGINX, Cloudflare). Some enterprises use forward proxy (content filtering).",
    keyPoints: [
      'Forward Proxy: serves clients, hides client IP from servers (corporate proxy, VPN)',
      'Reverse Proxy: serves servers, hides server IP from clients (NGINX, load balancer)',
      'Forward: clients know proxy exists (configured in browser)',
      "Reverse: clients don't know proxy exists (transparent)",
      'Use forward for: content filtering, anonymity; Use reverse for: load balancing, SSL termination',
    ],
  },
  {
    id: 'q2',
    question:
      'Your backend servers are overwhelmed with SSL encryption/decryption (high CPU usage). Propose a solution using a reverse proxy.',
    sampleAnswer:
      "SOLUTION: SSL TERMINATION AT REVERSE PROXY. PROBLEM ANALYSIS: Backend servers handling SSL/TLS: Each HTTPS request: (1) TCP handshake: 1 round trip. (2) TLS handshake: 2-3 round trips (negotiate cipher, exchange keys). (3) Decrypt request: CPU-intensive. (4) Process request: Business logic. (5) Encrypt response: CPU-intensive. SSL overhead: CPU: 10-15% per connection (encryption/decryption). Latency: 100-300ms for TLS handshake. Certificate management: Each backend needs SSL certificate. Impact: Backend servers at 80-90% CPU (SSL overhead). Can't handle more traffic (CPU bottleneck). Slow response times (encryption overhead). PROPOSED SOLUTION: SSL TERMINATION AT NGINX REVERSE PROXY. Architecture: Client → NGINX (HTTPS) → Backend (HTTP, internal network). IMPLEMENTATION: STEP 1: Deploy NGINX reverse proxy in front of backends. STEP 2: Configure NGINX for SSL termination. Install SSL certificate on NGINX (Let's Encrypt, commercial cert). NGINX config: server { listen 443 ssl; ssl_certificate /etc/nginx/ssl/cert.pem; ssl_certificate_key /etc/nginx/ssl/key.pem; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://backend-servers; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Proto https; } }. STEP 3: Backend servers accept HTTP only (port 8080). Remove SSL config from backends. Backends trust NGINX (internal network). BENEFITS: Backend CPU reduction: Before: 80-90% CPU (SSL overhead). After: 50-60% CPU (no SSL). Savings: 30% CPU freed (can handle more traffic). Simplified backends: No SSL configuration needed. Focus on business logic (not encryption). Certificate management: Centralized: One certificate on NGINX (not 10 certificates on backends). Easy renewal: Update NGINX only (not all backends). Performance: SSL handshake: Done once at NGINX (not per backend). Reuse: NGINX reuses SSL sessions (TLS session resumption). Latency: Reduced (fewer handshakes). Scalability: Backends scale independently (add more backends easily). No SSL overhead per backend. DETAILED FLOW: BEFORE (NO PROXY): Client → Backend Server (HTTPS): (1) TCP handshake: 50ms. (2) TLS handshake: 150ms. (3) Decrypt request: 10ms CPU. (4) Process: 50ms. (5) Encrypt response: 10ms CPU. Total: 270ms + CPU overhead. AFTER (WITH SSL TERMINATION): Client → NGINX (HTTPS): (1) TCP handshake: 50ms. (2) TLS handshake: 150ms (once). NGINX → Backend (HTTP, internal): (3) HTTP request: 5ms (no encryption). (4) Process: 50ms. (5) HTTP response: 5ms (no encryption). Total: 260ms (slightly faster). CPU on backend: 70% reduction in SSL CPU (10ms → 0ms per request). SECURITY CONSIDERATIONS: Internal network encryption: NGINX → Backend is HTTP (unencrypted). Risk: If internal network compromised, traffic visible. Mitigation: (1) Use private network/VPC (isolated). (2) Or: Use mTLS (mutual TLS) between NGINX and backends (added complexity). Recommendation: HTTP internally is standard practice (AWS, Google, Netflix do this). Trust model: Backends trust NGINX (NGINX authenticates clients). NGINX forwards user context: Headers: X-Forwarded-For (client IP), X-Forwarded-Proto (https), X-User-ID (if authenticated). NGINX OPTIMIZATIONS: SSL session caching: ssl_session_cache shared:SSL:10m;. ssl_session_timeout 10m;. Reuse: TLS sessions reused for returning clients (skip handshake). Hardware acceleration: Use SSL acceleration (Intel AES-NI, hardware offload). OCSP stapling: ssl_stapling on;. Reduces client-side OCSP lookups. HTTP/2: http2 on;. Multiplexing: Multiple requests over one connection. COST ANALYSIS: NGINX instance: Medium server: $100/month. Handles: 10K concurrent connections. Backend savings: Before: 10 backends at 80% CPU → Need 15 backends (scale up). After: 10 backends at 50% CPU → Keep 10 backends. Savings: 5 backends × $100/month = $500/month. Net: $100 (NGINX) - $500 (savings) = Save $400/month. Plus: Simplified operations (one certificate, not 10). MONITORING: Track metrics: NGINX CPU: Should be <70% (SSL load). Backend CPU: Should decrease 30% (SSL offloaded). SSL handshake time: <200ms. TLS session reuse rate: >80% (caching working). Alert if: NGINX CPU >80% (need to scale NGINX). Backend CPU not reduced (misconfiguration). MIGRATION STRATEGY: Phase 1: Deploy NGINX with SSL termination (in parallel). Phase 2: Route 10% traffic through NGINX (canary). Phase 3: Monitor backend CPU (should drop). Phase 4: Gradually increase to 100%. Phase 5: Remove SSL from backends (simplify config). REAL-WORLD EXAMPLES: NETFLIX: SSL termination at ELB (AWS Load Balancer). Backends: HTTP only. Result: Simplified backends, better performance. CLOUDFLARE: Global SSL termination at edge. Origin servers: HTTP (Cloudflare encrypts). Result: Free SSL for customers, offloaded SSL. FINAL RECOMMENDATION: Implement NGINX reverse proxy with SSL termination. Backends accept HTTP only (internal network). Monitor backend CPU reduction (30% expected). Scale NGINX horizontally if needed (multiple NGINX instances). Expected outcome: Backend CPU: 80% → 50% (30% reduction). Simplified backends (no SSL config). Centralized certificate management (easy renewals). Can handle 50% more traffic (CPU freed).",
    keyPoints: [
      'SSL Termination: NGINX handles SSL, backends use HTTP (internal)',
      'Backend CPU reduction: 30% (SSL offloaded to NGINX)',
      'Centralized certificates: One cert on NGINX (not 10 on backends)',
      'Internal HTTP acceptable: Private network/VPC (industry standard)',
      'Result: 50% more traffic capacity, simplified backend configuration',
    ],
  },
  {
    id: 'q3',
    question:
      'A company wants employees to be unable to access social media during work hours. Design a solution using a forward proxy.',
    sampleAnswer:
      'SOLUTION: CORPORATE FORWARD PROXY WITH CONTENT FILTERING. REQUIREMENTS: Block: Social media sites (Facebook, Twitter, Instagram, TikTok). Allow: Work-related sites (email, productivity tools, research). Time-based: Block during work hours (9am-5pm), allow after hours. Logging: Track all employee web access (compliance). Exceptions: Marketing team needs social media access (whitelist). ARCHITECTURE: All employee traffic → Forward Proxy → Internet. No direct internet access (firewall blocks). Proxy is bottleneck (all traffic goes through). IMPLEMENTATION: STEP 1: DEPLOY PROXY SERVER. Software: Squid Proxy (open-source, widely used). Or: Blue Coat ProxySG (commercial, advanced features). Or: Cloud-based: Zscaler, Cisco Umbrella. Server: Medium instance (4 CPUs, 8GB RAM). Handles: 1000 concurrent employees. STEP 2: CONFIGURE PROXY SETTINGS. Network configuration: Firewall blocks direct internet (force proxy usage). DHCP: Automatically configure employee devices: HTTP Proxy: proxy.company.com:8080. HTTPS Proxy: proxy.company.com:8080. Or: PAC file (Proxy Auto-Config): Auto-detect corporate network, apply proxy. Employee devices: Browsers configured automatically. No manual configuration needed. STEP 3: CONFIGURE BLOCKED SITES. Blocklist: facebook.com, twitter.com, instagram.com, tiktok.com, youtube.com (entertainment), reddit.com, pinterest.com. Wildcard: *.facebook.com (blocks all Facebook subdomains). m.facebook.com, www.facebook.com, etc. Categories: Social media, entertainment, gambling, adult content. Use pre-built lists: Squid blacklists (community-maintained). Commercial feeds (Blue Coat, Symantec). STEP 4: CONFIGURE TIME-BASED RULES. Work hours (9am-5pm): Block social media. Allow work sites. After hours (5pm-9am): Allow all sites (personal use OK). Weekends: Allow all sites. Squid config: acl work_hours time MTWHF 09:00-17:00. acl social_media dstdomain .facebook.com .twitter.com. http_access deny social_media work_hours. http_access allow all. STEP 5: CONFIGURE WHITELIST (EXCEPTIONS). Marketing team: Needs social media access (Facebook, Twitter for campaigns). Implementation: Create group: marketing_team. Members: User IDs of marketing employees. Rule: Allow social_media for marketing_team (even during work hours). Squid config: acl marketing_team src 10.0.1.0/24 # Marketing subnet. http_access allow social_media marketing_team. STEP 6: CONFIGURE LOGGING. Log all requests: Timestamp, user ID, URL, action (allow/block), bytes transferred. Store logs: Centralized logging server (Splunk, ELK). Retention: 90 days (compliance). Analysis: Generate reports: Top blocked sites, top users by bandwidth, policy violations. BENEFITS: Productivity: Employees can\'t waste time on social media. Bandwidth: Reduce non-work traffic (save bandwidth costs). Security: Block malicious sites (malware, phishing). Compliance: Audit trail of all web access. Policy enforcement: Automatic (no manual monitoring). EXAMPLE BLOCKED REQUEST: Scenario: Employee tries to access facebook.com during work hours. Flow: (1) Employee browser: GET facebook.com. (2) Browser sends to proxy: GET http://facebook.com. (3) Proxy checks rules: URL: facebook.com. Time: 2pm (work hours). User: john@company.com (not marketing team). (4) Proxy finds match: social_media + work_hours → BLOCK. (5) Proxy returns: HTTP 403 Forbidden. Body: "Access to social media blocked during work hours. Contact IT for exceptions.". (6) Employee sees block page. (7) Proxy logs: 2024-10-15 14:00:00, john@company.com, facebook.com, BLOCKED. EXAMPLE ALLOWED REQUEST: Scenario: Employee accesses work email (gmail.com). Flow: (1) Employee: GET gmail.com. (2) Proxy checks rules: URL: gmail.com (not in blocklist). (3) Proxy: ALLOW. (4) Proxy forwards to gmail.com: GET http://gmail.com (on behalf of employee). (5) Gmail responds to proxy. (6) Proxy forwards response to employee. (7) Proxy logs: 2024-10-15 14:00:00, john@company.com, gmail.com, ALLOWED. BYPASS PREVENTION: Employees try to bypass: VPN: Proxy blocks VPN sites (openvpn.com, nordvpn.com). Tor: Proxy blocks Tor (torproject.org). Proxy websites: Proxy blocks proxy sites (hidemyass.com). HTTPS: Proxy does SSL inspection (decrypt, inspect, re-encrypt). Caution: Privacy concerns (inspect personal data). Recommendation: Warn employees (acceptable use policy). Mobile hotspot: Employee uses phone as hotspot (bypass corporate network). Prevention: Require VPN for remote work (force traffic through proxy). MONITORING & REPORTING: Daily reports: Top blocked sites (understand employee behavior). Top bandwidth users (identify heavy users). Policy violations (repeated access attempts). Monthly reports: Compliance: All web access logged. Trends: Popular sites, bandwidth usage. Alerts: Unusual activity: Employee accesses 100 blocked sites/hour (malware?). Bandwidth spike: Employee downloads 10GB (investigation). EMPLOYEE COMMUNICATION: Acceptable use policy: Document: "Social media blocked during work hours. Exceptions for marketing team. Violations logged.". Training: Explain policy, consequences. Transparency: Employees know proxy exists (not secret). COST: Proxy server: Medium instance: $200/month. Or: Cloud-based (Zscaler): $5/user/month × 1000 = $5000/month. Software: Squid: Free (open-source). Blue Coat: $10K/year (commercial). Maintenance: IT admin: 10 hours/month × $50/hour = $500/month. Total: ~$700/month (self-hosted). Benefits: Productivity: Hard to quantify, but significant. Bandwidth: 20-30% reduction (social media blocked). Compliance: Audit trail (avoid fines). ALTERNATIVES CONSIDERED: DNS filtering: Block social media at DNS level (cloudflare-gateway.com). Pros: Simple, no proxy needed. Cons: Easy to bypass (change DNS), no logging. Verdict: Proxy better (can\'t bypass, detailed logs). Endpoint software: Install agent on employee devices (block sites locally). Pros: Works off-network (remote employees). Cons: Can be disabled by employee, maintenance burden. Verdict: Use both (proxy on-network, agent for remote). FINAL RECOMMENDATION: Deploy Squid forward proxy on corporate network. Block social media during work hours (9am-5pm). Whitelist marketing team (exceptions). Log all requests (90-day retention). Prevent bypasses (block VPN, Tor, proxy sites). Communicate policy to employees (transparency). Expected outcome: 30-40% reduction in non-work web traffic. Improved productivity. Compliance with acceptable use policy.',
    keyPoints: [
      'Forward proxy filters content: block social media during work hours (9am-5pm)',
      'Network enforced: firewall blocks direct internet, all traffic goes through proxy',
      'Time-based rules: block during work hours, allow after hours',
      'Whitelist exceptions: marketing team needs social media access',
      'Logging: track all employee web access for compliance (90-day retention)',
    ],
  },
];
