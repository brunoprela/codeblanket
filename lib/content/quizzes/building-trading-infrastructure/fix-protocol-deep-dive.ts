export const fixProtocolDeepDiveQuiz = [
  {
    id: 'fix-protocol-deep-dive-q-1',
    question:
      'Design a "FIX session manager" that maintains reliable connectivity with a broker. Include: (1) Logon/logout flow with credentials, (2) Sequence number management (detect gaps, request resend), (3) Heartbeat monitoring (send/receive within interval), (4) Automatic reconnection on disconnect, (5) Message queueing during disconnection, (6) Session persistence (restore sequence numbers after restart).',
    sampleAnswer:
      "FIX Session Manager Design: **Logon Flow**: Connect TCP socket to broker (host:port). Send Logon (35=A): BeginString=FIX.4.2, MsgType=A, SenderCompID=CLIENT1, TargetCompID=BROKER1, MsgSeqNum=1 (reset on new session), HeartBtInt=30 (heartbeat every 30s), EncryptMethod=0 (none), Username/Password (tags 553/554 if required). Receive Logon response from broker: If accepted: MsgType=A (broker logged on), start heartbeat monitoring. If rejected: MsgType=5 (Logout) with Text=58 (reason), retry with correct credentials. **Sequence Number Management**: Outgoing: Start at 1, increment for each message sent (including heartbeats). Track: outgoing_seq_num = 1, each send: msg.MsgSeqNum = outgoing_seq_num++. Incoming: Expect sequential numbers from broker, track: incoming_seq_num = 1, each receive: check msg.MsgSeqNum == incoming_seq_num. Gap Detection: If received seq > expected (e.g., receive 15 but expect 10) → gap of 5 messages. Send ResendRequest (35=2): BeginMsgSeqNo=10, EndMsgSeqNo=14 (or 0 for all). Broker resends missing messages with PossDupFlag=Y (tag 43). Duplicate Detection: If received seq < expected → already processed. Ignore (broker may resend after reconnect). **Heartbeat Monitoring**: Send heartbeat every HeartBtInt seconds: If no message sent in last 30s → send Heartbeat (35=0). Receive heartbeat or any message: Reset receive timer. If no message received in 2 × HeartBtInt (60s) → connection dead. TestRequest: If 1.5 × HeartBtInt with no message → send TestRequest (35=1) with TestReqID=123. Expect Heartbeat (35=0) with TestReqID=123 within 10s. If no response → disconnect and reconnect. **Automatic Reconnection**: On disconnect detection: Close socket. Wait 5 seconds (backoff). Reconnect and send Logon. Continue from last sequence number (ResetSeqNumFlag=N). Or reset sequence (ResetSeqNumFlag=Y) if new trading day. Example: Session 1: Sent seq 1-100, received 1-100. Disconnect at 10:30am. Reconnect at 10:31am. Send Logon with MsgSeqNum=101 (continue). Broker responds with seq 101 (continues). **Message Queueing**: During disconnection, queue outbound messages: Maintain in-memory queue (or persistent DB). On reconnect, flush queue in order. Example: Disconnect with 3 pending orders. Queue: [Order A, Order B, Order C]. Reconnect successful. Send Order A (seq 101), Order B (seq 102), Order C (seq 103) in order. **Session Persistence**: Store state to disk/database: outgoing_seq_num, incoming_seq_num, last_login_time, pending_messages. On restart: Read state from disk. If same trading day AND <15 minutes ago → continue session (send seq 101). If new day OR >15 minutes → reset session (send seq 1 with ResetSeqNumFlag=Y). Example persistence (Redis): SET fix_session:CLIENT1:outgoing_seq 101, SET fix_session:CLIENT1:incoming_seq 101, GET on restart → resume at 101. **Edge Cases**: Broker ahead: Broker sends seq 101 but we expect 100 → we missed one. Send ResendRequest for 100. We ahead: We send seq 102 but broker expects 101 → broker rejects. Reset and resend from broker's expected seq. Mutual disconnect: Both disconnect, both reconnect with different seq expectations. Use SequenceReset (35=4) to synchronize (GapFill mode). **Implementation**: class FIXSessionManager: def __init__(self, sender, target, host, port): self.outgoing_seq = 1, self.incoming_seq = 1, self.heartbeat_interval = 30, self.last_send_time = now(), self.last_recv_time = now(), self.is_connected = False, async def connect(): await open_socket(host, port), await send_logon(), self.is_connected = True, start_heartbeat_monitor(), async def send_message(msg): msg.MsgSeqNum = self.outgoing_seq, self.outgoing_seq += 1, await socket.send(msg), self.last_send_time = now(), async def receive_message(): msg = await socket.recv(), if msg.MsgSeqNum != self.incoming_seq: handle_sequence_gap(msg.MsgSeqNum), self.incoming_seq = msg.MsgSeqNum + 1, self.last_recv_time = now(), return msg, async def heartbeat_monitor(): while self.is_connected: if (now() - self.last_send_time) > heartbeat_interval: await send_heartbeat(), if (now() - self.last_recv_time) > heartbeat_interval × 2: await reconnect().",
    keyPoints: [
      'Logon: Send MsgType=A with SenderCompID, HeartBtInt=30; receive acceptance or rejection; start heartbeat monitoring',
      'Sequence numbers: Outgoing starts at 1, increment each message; incoming must be sequential; detect gaps and send ResendRequest',
      'Heartbeats: Send every 30s if no message; receive within 60s or TestRequest; disconnect if 2× interval with no response',
      'Reconnection: Auto-reconnect on disconnect; continue from last seq (ResetSeqNumFlag=N) or reset (=Y) for new day',
      'Persistence: Store outgoing_seq, incoming_seq to Redis/disk; restore on restart if <15min and same day',
    ],
  },
  {
    id: 'fix-protocol-deep-dive-q-2',
    question:
      'Implement a "FIX message parser and builder" that handles: (1) Parsing raw FIX strings into message objects, (2) Building FIX messages with proper formatting (SOH separators, checksum), (3) Field validation (required vs optional), (4) Checksum calculation and verification, (5) Handling repeating groups (multi-leg orders), (6) Performance optimization (avoid string concatenation, use byte arrays).',
    sampleAnswer:
      'FIX Message Parser and Builder: **Parsing Raw FIX String**: Input: "8=FIX.4.2\\x019=100\\x0135=D\\x0149=CLIENT1\\x01...10=123\\x01". Step 1: Split by SOH (\\x01): parts = message.split("\\x01"). Step 2: Parse tag=value pairs: for part in parts: if "=" in part: tag, value = part.split("=", 1), fields[int(tag)] = value. Step 3: Extract msg_type from tag 35: msg_type = fields[35]. Step 4: Verify checksum: calculated = sum(ord(c) for c in message[:-7]) % 256, checksum_str = fields[10], assert calculated == int(checksum_str). Step 5: Build message object: return FIXMessage(msg_type=msg_type, fields=fields). **Building FIX Messages**: Input: Create NewOrderSingle (35=D). Step 1: Set required fields: fields[8] = "FIX.4.2", fields[35] = "D", fields[49] = "CLIENT1", fields[56] = "BROKER1", fields[34] = str(seq_num), fields[52] = timestamp, fields[11] = cl_ord_id, fields[55] = symbol, fields[54] = side, fields[38] = qty. Step 2: Sort fields by tag number (FIX requirement): sorted_tags = sorted(fields.keys()). Step 3: Build body string: body = "\\x01".join(f"{tag}={fields[tag]}" for tag in sorted_tags if tag not in [8,9,10]) + "\\x01". Step 4: Calculate body length: body_length = len(body). Step 5: Build header: header = f"8={fields[8]}\\x019={body_length}\\x01". Step 6: Build message without checksum: message = header + body. Step 7: Calculate checksum: checksum = sum(ord(c) for c in message) % 256. Step 8: Append checksum: complete = message + f"10={checksum:03d}\\x01". **Field Validation**: Define message specs (per FIX standard): NewOrderSingle (35=D) requires: ClOrdID (11), Symbol (55), Side (54), OrderQty (38), OrdType (40). Optional: Price (44) if OrdType=Limit, Account (1). Validate on build: for tag in required_tags: if tag not in fields: raise ValueError(f"Missing required field: {tag}"). Validate on parse: Check msg_type is valid, check required fields present. **Checksum Calculation**: Formula: Sum of ASCII values of all characters (except checksum field) mod 256. Example: Message: "8=FIX.4.2\\x019=50\\x0135=0\\x01". Bytes: [56, 61, 70, 73, 88, 46, 52, 46, 50, 1, 57, 61, 53, 48, 1, 51, 53, 61, 48, 1]. Sum: 1234 (example). Checksum: 1234 % 256 = 210. Format: "10=210\\x01" (padded to 3 digits: "210"). Verification: On receive, recalculate checksum excluding "10=xxx\\x01", compare with received value. **Repeating Groups**: Example: Multi-leg order (options spread). NoLegs (555) = 2 (number of legs). Leg 1: LegSymbol (600) = "AAPL", LegSide (624) = "1", LegQty (623) = "100". Leg 2: LegSymbol (600) = "AAPL", LegSide (624) = "2", LegQty (623) = "100". Parsing: Count = fields[555], legs = [], for i in range(count): leg = {600: fields[600+i*offset], 624: fields[624+i*offset], 623: fields[623+i*offset]}, legs.append(leg). Building: Set NoLegs = 2, add fields for each leg sequentially. **Performance Optimization**: Problem: String concatenation creates new objects (slow). Solution 1: Use bytearray (mutable): buf = bytearray(), buf.extend(b"8=FIX.4.2\\x01"), buf.extend(b"9=100\\x01"), ..., return bytes(buf). Solution 2: Pre-allocate buffer: Estimate message size (~200 bytes typical), allocate: buf = bytearray(200), write fields directly. Solution 3: Caching: Cache common fields (BeginString, SenderCompID), reuse strings. Benchmark: String concat: 10,000 messages = 500ms. Bytearray: 10,000 messages = 50ms (10× faster). **Implementation**: class FIXParser: @staticmethod, def parse(fix_string: str) -> FIXMessage: fields = {}, parts = fix_string.split("\\x01"), for part in parts: if "=" in part: tag, value = part.split("=", 1), fields[int(tag)] = value, verify_checksum(fix_string, fields[10]), return FIXMessage(fields[35], fields), class FIXBuilder: def build(self, msg_type, fields) -> bytes: validate_required_fields(msg_type, fields), sorted_fields = sort_by_tag(fields), body = build_body(sorted_fields), header = build_header(len(body)), message = header + body, checksum = calculate_checksum(message), return message + f"10={checksum:03d}\\x01".encode().',
    keyPoints: [
      'Parsing: Split by SOH (\\x01), parse tag=value pairs, extract msg_type from tag 35, verify checksum matches',
      'Building: Set fields, sort by tag number, build body, calculate body length (tag 9), build header (tags 8,9), calculate checksum (tag 10)',
      'Validation: Check required fields per message type (e.g., NewOrderSingle needs tags 11,55,54,38,40); raise error if missing',
      'Checksum: Sum of ASCII values of all chars (except checksum field) mod 256; format as 3-digit padded string',
      'Performance: Use bytearray instead of string concat (10× faster); pre-allocate buffer; cache common fields',
    ],
  },
  {
    id: 'fix-protocol-deep-dive-q-3',
    question:
      'Design a "FIX order flow" from client to exchange with proper error handling. Include: (1) Client sends NewOrderSingle, (2) Broker sends ack (ExecType=0), (3) Exchange accepts (ExecType=0) or rejects (ExecType=8), (4) Fills (ExecType=F), (5) Client cancels (OrderCancelRequest), (6) Handling rejections, partial fills, and timeouts.',
    sampleAnswer:
      'FIX Order Flow Design: **Step 1: Client Sends NewOrderSingle (35=D)**: Client creates order: ClOrdID=ORD-12345 (unique), Symbol=AAPL, Side=1 (Buy), OrderQty=100, OrdType=2 (Limit), Price=150.00. Send to broker via FIX: 35=D|11=ORD-12345|55=AAPL|54=1|38=100|40=2|44=150.00|59=0 (Day order). **Step 2: Broker Acknowledges (ExecType=0)**: Broker receives order, validates: Account has buying power? Symbol is tradable? Price within limits? If valid, send Execution Report (35=8): OrderID=12345 (broker assigns), ClOrdID=ORD-12345 (echo client ID), ExecType=0 (New), OrdStatus=0 (New), LeavesQty=100 (none filled yet), CumQty=0. Client receives ack: Order accepted by broker, OrderID=12345 for tracking. **Step 3: Exchange Processing**: Broker routes to exchange (via FIX or exchange API). Exchange validates: Symbol valid? Within price collar? Market open? Option A: Accepted, Exchange sends ExecutionReport: ExecType=0 (New), OrdStatus=0 (New), order enters order book. Option B: Rejected, Exchange sends ExecutionReport: ExecType=8 (Rejected), OrdStatus=8 (Rejected), Text="Price outside limits" (tag 58), order dies. Broker forwards rejection to client: ExecType=8, Text="Rejected by exchange: Price outside limits". **Step 4: Partial Fill (ExecType=F)**: Order in book, partial match occurs: Fill 50 shares at $150.00. Exchange sends ExecutionReport: ExecID=EXEC-001 (unique), ExecType=F (Trade/Fill), OrdStatus=1 (PartiallyFilled), LastQty=50 (this fill), LastPx=150.00 (this fill price), CumQty=50 (total filled), LeavesQty=50 (remaining), AvgPx=150.00 (average so far). Client receives fill: Update position: +50 AAPL, track: 50 filled, 50 remaining. **Step 5: Final Fill**: Remaining 50 shares fill at $150.01. Exchange sends ExecutionReport: ExecID=EXEC-002, ExecType=F, OrdStatus=2 (Filled completely), LastQty=50, LastPx=150.01, CumQty=100, LeavesQty=0, AvgPx=150.005 (weighted average). Client receives final fill: Order complete, total: 100 shares @ $150.005 avg. **Step 6: Client Cancels (35=F)**: Assume order not yet filled, client wants to cancel. Send OrderCancelRequest (35=F): OrigClOrdID=ORD-12345 (original order), ClOrdID=ORD-12345-C1 (new ID for cancel request), Symbol=AAPL, Side=1, OrderQty=100 (original qty). Exchange processes cancel: Option A: Cancel Accepted, Send ExecutionReport: ExecType=4 (Canceled), OrdStatus=4 (Canceled), LeavesQty=0, CumQty=0 (if no fills), Text="Canceled per request". Option B: Cancel Rejected (too late, already filled), Send OrderCancelReject (35=9): CxlRejReason=0 (Too late to cancel), OrdStatus=2 (Filled), Text="Order already filled". **Error Handling Scenarios**: Timeout: Client sends order, no ack within 5 seconds. Action: Resend with PossDupFlag=Y (tag 43=Y), or send OrderStatusRequest (35=H) to query. Duplicate ClOrdID: Broker receives order with ClOrdID already used. Reject: ExecType=8, Text="Duplicate ClOrdID". Network disconnect during fill: Fills occurred but not received. On reconnect: Send OrderMassStatusRequest (35=AF) to get all order statuses. Reconcile fills from broker report. Partial fill then cancel: 50 filled, client cancels remaining 50. Exchange: Cancel accepted for remaining 50. Final ExecutionReport: OrdStatus=4 (Canceled), CumQty=50 (partial fill kept), LeavesQty=0. **State Machine**: NEW → PENDING_NEW (sent to exchange) → NEW (accepted) or REJECTED. NEW → PARTIALLY_FILLED (first fill) → FILLED (complete) or CANCELED (cancel rest). PARTIALLY_FILLED → FILLED (more fills) or CANCELED. Any state → REJECTED (error). **Implementation**: class OrderFlowHandler: async def send_new_order(cl_ord_id, symbol, side, qty, price): msg = build_new_order_single(cl_ord_id, symbol, side, qty, price), await session.send(msg), orders[cl_ord_id] = {"status": "PENDING_NEW", "filled": 0}, async def on_execution_report(msg): cl_ord_id = msg.get_field(11), exec_type = msg.get_field(150), ord_status = msg.get_field(39), if exec_type == "0": print(f"Order {cl_ord_id} accepted"), orders[cl_ord_id]["status"] = "NEW", elif exec_type == "F": last_qty = int(msg.get_field(32)), cum_qty = int(msg.get_field(14)), print(f"Fill: {last_qty} shares, total: {cum_qty}"), orders[cl_ord_id]["filled"] = cum_qty, if ord_status == "2": print(f"Order {cl_ord_id} FILLED"), elif exec_type == "8": text = msg.get_field(58), print(f"Order {cl_ord_id} REJECTED: {text}"), orders[cl_ord_id]["status"] = "REJECTED".',
    keyPoints: [
      'Order flow: Client sends NewOrderSingle → Broker acks (ExecType=0) → Exchange accepts/rejects → Fills (ExecType=F) with LastQty/CumQty',
      'Cancel flow: Send OrderCancelRequest → Exchange responds with Canceled (ExecType=4) or OrderCancelReject if too late',
      'Execution Report states: New (0), PartiallyFilled (1), Filled (2), Canceled (4), Rejected (8); track CumQty and LeavesQty',
      'Error handling: Timeout → resend with PossDupFlag=Y; disconnect → OrderMassStatusRequest on reconnect; duplicate ID → reject',
      'Fill tracking: LastQty (this fill), CumQty (total filled), LeavesQty (remaining), AvgPx (weighted average price across fills)',
    ],
  },
];
