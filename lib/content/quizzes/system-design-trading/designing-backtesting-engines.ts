export const designingBacktestingEnginesQuiz = [
  {
    id: 'dbe-q-1',
    question:
      'Compare vectorized vs event-driven backtesting approaches. For each: (1) explain the implementation approach, (2) discuss advantages and disadvantages, (3) identify potential biases and how each approach handles them, (4) provide latency/performance characteristics. When would you use each approach? Include specific examples of lookahead bias in vectorized backtesting.',
    sampleAnswer:
      "Vectorized vs Event-Driven: (1) Vectorized (pandas): Load entire dataset into memory as DataFrame. Calculate indicators using vectorized operations (df['ma'] = df['close'].rolling(20).mean()). Generate signals for all time periods at once. Calculate returns: df['returns'] = df['signal'].shift(1) * df['close'].pct_change(). Advantages: Very fast (NumPy vectorization), simple code, easy to prototype. Disadvantages: Easy to introduce lookahead bias (forget .shift()), entire dataset in memory (memory intensive), doesn't simulate real-time execution, hard to model complex order types. Example lookahead bias: df['signal'] = (df['close'] > df['close'].shift(-1)) creates signal based on tomorrow's price! Correct: df['signal'] = (df['close'] > df['close'].shift(1)). (2) Event-Driven: Process data chronologically, one event at a time (tick, bar, order fill). Strategy sees only past data at each timestamp. Order execution simulated with realistic delay. Advantages: No lookahead bias by design (only past data accessible), simulates real-time trading accurately, can model complex execution (partial fills, order types), memory efficient (stream processing). Disadvantages: Slower than vectorized (loop through events), more complex code, harder to debug. Performance: Vectorized = 10-1000x faster for simple strategies. Event-driven = 100ms to 10s for year of daily bars. Event-driven = 1-10 minutes for year of minute bars. Can parallelize for speed (split by symbol). When to use: Vectorized: Quick prototyping, simple strategies, research phase. Event-driven: Final validation, production strategies, complex execution, any strategy going to live trading. Critical: Always validate vectorized backtests with event-driven before live trading. Lookahead bias examples: (a) Using entire rolling window without shift: df['ma'] = df['close'].rolling(20).mean() includes current bar (lookahead!). Correct: Calculate MA at bar i using bars i-20 to i-1. (b) Forward-filling gaps: df.fillna (method='bfill') uses future data. Correct: Use method='ffill' (forward fill only past). (c) Normalizing with full dataset statistics: scaler.fit(X) uses future data. Correct: Fit scaler only on training data.",
    keyPoints: [
      'Vectorized: fast (10-1000x), simple, but easy lookahead bias, entire data in memory',
      'Event-driven: slower, complex, but no lookahead by design, simulates real trading',
      'Lookahead examples: forgetting .shift(), bfill, fitting on future data',
      'Use vectorized for prototyping, event-driven for validation and production',
      'Always validate vectorized results with event-driven before live trading',
    ],
  },
  {
    id: 'dbe-q-2',
    question:
      'Design a comprehensive strategy validation framework that prevents overfitting. Address: (1) data splitting (train/validation/test), (2) walk-forward optimization, (3) Monte Carlo simulation for robustness testing, (4) multiple metrics to evaluate (not just Sharpe), (5) statistical significance testing. How would you detect if a strategy is overfit vs genuinely profitable?',
    sampleAnswer:
      "Overfitting prevention framework: (1) Data splitting: Three-way split: Train (2000-2015), Validation (2016-2019), Test (2020-2024). Develop strategy on Train only. Hyperparameter tuning on Validation (intermediate out-of-sample). Final evaluation on Test (never touched during development). Time-based splitting critical (never random split for time series). Alternative: K-fold cross-validation with time series (TimeSeriesSplit in sklearn). Train on 2000-2005, test on 2006. Train on 2000-2006, test on 2007. Etc. (2) Walk-forward optimization: Mimics real trading where you periodically re-optimize. Process: Train on 1 year, test on next 3 months. Slide window forward 3 months, re-train. Collect all out-of-sample results. If strategy requires frequent re-optimization (every month), it's likely overfit to noise. Robust strategies work with parameters optimized years ago. (3) Monte Carlo robustness: Perturb strategy parameters ±10% and re-run backtest. Example: If optimal fast_ma=20, test [18, 19, 20, 21, 22]. Plot performance surface. Overfit strategies show sharp peak (only works at exact parameter). Robust strategies show plateau (works across parameter range). Randomize trade order to test if P&L depends on specific execution sequence. Bootstrap historical returns (sample with replacement) and re-calculate Sharpe. If 95% CI includes Sharpe < 1, strategy is fragile. (4) Multiple evaluation metrics: Sharpe ratio (risk-adjusted return), Max Drawdown (worst peak-to-trough), Calmar ratio (return / max drawdown), Win rate (% profitable trades), Profit factor (gross profit / gross loss), Avg win / Avg loss ratio, Time to recovery (from drawdowns), Sortino ratio (only penalize downside volatility), Tail ratio (95th percentile gain / 95th percentile loss). No single metric sufficient. Strategy may have high Sharpe but unacceptable 50% drawdown. Prefer: Sharpe > 1, Max DD < 20%, Calmar > 1, Win rate > 45%. (5) Statistical significance: Null hypothesis: Strategy has zero Sharpe (no skill). Calculate t-statistic: t = Sharpe * sqrt(N) where N = number of trades. If t > 2, reject null at 95% confidence (strategy likely has edge). Permutation test: Randomly shuffle trade P&Ls 1000 times. If actual P&L in top 5%, significant at 95% confidence. Warning: High Sharpe on 10 trades = not significant. Need 100+ trades for confidence. Detecting overfit: (a) Train Sharpe >> Test Sharpe (e.g., train=3.0, test=0.5): Classic overfit. (b) Performance degrades rapidly in walk-forward: Fit to noise. (c) Parameter sensitivity: Changing fast_ma=20 to fast_ma=21 kills strategy: Overfit. (d) Too many parameters: >5 parameters with 1000 bars = risk of overfitting. Rule of thumb: Need 20x more data points than parameters. (e) Performance not robust to different time periods: Works 2010-2015 but fails 2016-2020: Regime-specific, not generalizable. (f) Exceptional performance (Sharpe > 3): Be skeptical. Most real strategies have Sharpe 1-2. Sharpe > 3 often means bugs, lookahead bias, or overfitting. Genuine profitability indicators: (a) Consistent across time periods (bull, bear, sideways markets). (b) Robust to parameter changes (plateau, not peak). (c) Statistically significant with t > 2. (d) Logical economic rationale (not just data mining). (e) Works out-of-sample (test set never touched). (f) Multiple uncorrelated strategies show similar results. Final check: Paper trade for 3-6 months before live capital.",
    keyPoints: [
      'Data split: Train (develop), Validation (tune), Test (evaluate), time-based never random',
      'Walk-forward: re-optimize periodically, frequent re-optimization = likely overfit',
      'Monte Carlo: perturb parameters ±10%, robust strategies show plateau not sharp peak',
      'Multiple metrics: Sharpe, Max DD, Calmar, win rate, profit factor—no single metric sufficient',
      'Overfit signs: train>>test performance, parameter sensitivity, Sharpe>3, not robust across time',
    ],
  },
  {
    id: 'dbe-q-3',
    question:
      'Design a realistic transaction cost model for backtesting. Address: (1) commission structures (fixed, tiered, maker/taker), (2) slippage modeling based on order size and liquidity, (3) market impact for large orders, (4) overnight funding costs for leveraged positions, (5) exchange fees and regulatory fees. How do transaction costs affect strategy viability? Provide specific examples.',
    sampleAnswer:
      "Transaction cost model: (1) Commission structures: Fixed per share: $0.005/share (Interactive Brokers). For 100 shares: $0.50 commission. Tiered: Volume-based. <100K shares/month = $0.005/share, >100K = $0.003/share, >1M = $0.001/share. Maker/taker (crypto): Maker (add liquidity) = -0.01% rebate, Taker (remove liquidity) = +0.04% fee. Limit orders (maker) cheaper than market orders (taker). Percentage-based: 0.1% of trade value (common for retail). $10,000 trade = $10 commission. Model: Use tiered structure. Track monthly volume, adjust commission rate. Code: commission = quantity * price * commission_pct + fixed_fee. (2) Slippage modeling: Fixed slippage: All market orders: price * (1 + slippage_pct). Buy: +0.05%, Sell: -0.05%. Too simplistic—doesn't account for order size. Volume-based slippage: Small order (<1% of bar volume): 0.01% slippage. Medium (1-5%): 0.05% slippage. Large (>5%): 0.10% slippage + potential partial fill. Example: Bar volume = 1M shares. Order 10K shares (1%) → 0.01% slippage. Order 100K shares (10%) → 0.10% slippage + might only fill 50K. Code: slippage_pct = min(0.10, 0.01 * (order_size / bar_volume)). Bid-ask spread: Use half-spread as minimum slippage. SPY: spread = $0.01, half = $0.005 = 0.0001% at $500. TSLA: spread = $0.05, half = $0.025 = 0.01% at $250. Illiquid stocks: spread can be 0.5-2%. (3) Market impact (large orders): Square-root model: impact = α * σ * sqrt (order_size / daily_volume). α = impact coefficient (0.1-0.5), σ = volatility. Example: Order 100K shares, daily volume = 10M, σ = 2%. Impact = 0.3 * 0.02 * sqrt(100K / 10M) = 0.3 * 0.02 * 0.1 = 0.0006 = 0.06%. For $10M order: 0.06% = $6,000 impact. Linear impact: impact_pct = (order_size / daily_volume) * impact_factor. Order 5% of daily volume with impact_factor=0.5 → 2.5% impact. Huge for HFT strategies. Implementation: Calculate impact per order. Adjust fill price: fill_price = market_price * (1 + impact_pct + slippage_pct). Reject orders exceeding impact threshold (e.g., >10% of daily volume). (4) Overnight funding (leverage): Crypto perpetual swaps: Funding rate = ±0.01% every 8 hours. Long position: pay funding if rate positive. Example: $100K position, 0.01% funding → $10 every 8 hours = $30/day. Annualized: 11% cost! Stock margin: Borrow rate = 3-8% annually. $100K position with 8% rate → $8K/year = $22/day. Implementation: Track open positions overnight. Charge funding: daily_cost = position_size * funding_rate / 365. Critical for carry trades and long-term positions. (5) Exchange and regulatory fees: SEC fee (US stocks): $0.00008 per dollar sold ($8 per $100K). FINRA TAF: $0.000145 per share sold (max $7.27 per trade). Exchange fees: Data fees ($50-200/month), connectivity ($500-2000/month for co-location). Total fees: Can add 0.01-0.05% per trade. Impact on strategy viability: High-frequency: 100 trades/day, 0.1% cost per trade → 10% daily cost = 2500% annual cost. Impossible without maker rebates (<0.01% cost). Medium-frequency: 1 trade/day, 0.1% cost → 25% annual cost. Need >40% annual return to profit (Sharpe ~1.5 required). Low-frequency: 1 trade/month, 0.1% cost → 1.2% annual cost. Achievable with >5% annual return (Sharpe ~0.5 sufficient). Example: MA crossover strategy: 50 trades/year, $100K portfolio. Without costs: 15% return, Sharpe = 1.2. With 0.1% commission + 0.05% slippage = 0.15% per trade. Total costs: 50 * $100K * 0.0015 = $7,500 = 7.5% drag. After costs: 7.5% return, Sharpe = 0.6. Not viable (Sharpe < 1). Lesson: Transaction costs kill most high-frequency strategies. Low-frequency, high-Sharpe strategies more robust. Critical: Underestimating transaction costs is #1 reason backtests fail in live trading. Use realistic costs: 0.1-0.2% per round trip (buy + sell) minimum.",
    keyPoints: [
      'Commissions: fixed, tiered (volume-based), maker/taker (crypto), model realistically per strategy',
      'Slippage: volume-based (0.01-0.10% based on order_size/bar_volume), bid-ask spread, illiquid stocks higher',
      'Market impact: square-root model, large orders (>5% daily volume) have significant impact (0.1-1%)',
      'Costs kill HF strategies: 100 trades/day with 0.1% cost = 2500% annual drag, need maker rebates',
      'Realistic estimate: 0.1-0.2% per round trip minimum, include overnight funding, exchange fees',
    ],
  },
];
