export const distributedTradingSystemsQuiz = [
  {
    id: 'dts-q-1',
    question:
      'Design a multi-region trading system that operates across US, Europe, and Asia. Address: (1) choosing between active-active vs active-passive architecture, (2) handling clock synchronization across regions, (3) order state replication strategy, (4) dealing with network partitions, (5) regulatory compliance per region. How do you ensure orders are never duplicated or lost during failover?',
    sampleAnswer:
      "Multi-region trading system design: (1) Architecture choice: Active-active for global reach and low latency. Each region handles orders for nearby exchanges independently. US region → NYSE/NASDAQ (1ms latency), Europe region → LSE/Eurex (1ms latency), Asia region → TSE/HKEX (1ms latency). Cross-region orders (e.g., US client buying on LSE) routed through nearest region then to exchange (80-150ms added latency acceptable for cross-market trades). Trade-offs: Active-active pros: Low latency in each region, high availability (multiple active systems), horizontal scalability. Active-active cons: Complex consistency (eventual consistency model), conflict resolution needed, more expensive ($3M+ vs $1M for active-passive). Active-passive pros: Single source of truth (strong consistency), simpler operations, lower cost. Active-passive cons: Higher latency for non-primary regions, single point of failure until failover, wasted capacity. Decision: Use active-active for institutional trading ($millions in infrastructure justified by business value). Use active-passive for smaller firms (<$10M AUM, simpler cheaper). (2) Clock synchronization: Use PTP (Precision Time Protocol) within each region for <1μs accuracy. GPS-synchronized grandmaster clock in each datacenter. PTP over Ethernet to all trading servers. Hardware-timestamped network cards ($500-2000 each). Cross-region: Use NTP for coarse sync across regions (1-50ms accuracy sufficient for cross-region coordination). Don't need microsecond precision between US and Europe (network latency dominates at 80ms). Monitoring: Alert if offset >10μs within region, >100ms across regions. Automated adjustment via PTP daemon. Importance: Order timestamps determine priority in exchange matching engines. 1μs clock error can cause order to lose priority vs competitor. (3) Order state replication: Two-tier strategy: Critical state (open orders, positions, cash): Synchronous replication. Write to local region + replicate to quorum (2 of 3 regions). Block order submission until confirmed. Latency: 80-150ms added (cross-region network), acceptable for order submission. Non-critical state (completed orders, analytics): Asynchronous replication. Write to local, queue replication to other regions. No blocking, eventual consistency. Implementation: Use Raft consensus for critical state. Leader in each region for local orders. Cross-region coordination via quorum votes. Use Kafka for async replication of historical data. Conflict resolution: Timestamp-based ordering. If two regions process conflicting orders (same account, insufficient capital), timestamp wins. Loser region rolls back and notifies client. (4) Network partitions: Quorum-based approach prevents split-brain. 3 regions → quorum = 2. If partition: US + Europe (2) vs Asia (1) → US+Europe can make progress (have quorum), Asia rejects new orders (safety first). Graceful degradation: If Asia partitioned, continue trading on US/EU exchanges. Asia orders queued until reconnection. Reconciliation: When partition heals, compare order logs. Use Raft log replication to sync missed orders. Detect conflicts (duplicate orders) via order IDs (UUIDs). Testing: Monthly chaos engineering: Deliberately partition regions, verify system handles correctly, measure recovery time (should be <30 seconds). (5) Regulatory compliance: Different rules per region: US: SEC regulations, best execution, order audit trail (7 years), CAT reporting. Europe: MiFID II, systematic internalizer rules, transaction reporting (EMIR). Asia: Local regulations per country (FSA in Japan, SFC in Hong Kong). Implementation: Separate compliance module per region. US orders → US compliance checks (reg NMS, wash sale rules). Europe orders → Europe compliance (MiFID II transparency). Shared: Global risk limits (firm-wide exposure), global positions (aggregate across regions). Data residency: EU data must stay in EU (GDPR). Use region-specific databases. US data can be in US. Cross-region analytics replicated to centralized warehouse (anonymized). Audit trail: Every order logged with: timestamp (PTP-synchronized), user ID, account, order details, exchange, region. Stored immutably (append-only log), 7-10 year retention. Replicated to 3+ regions for durability. (6) Ensuring no duplicates or losses during failover: Idempotency: Every order has unique UUID. Exchange rejects duplicates (same order ID). If failover causes retry, exchange ignores duplicate. At-least-once delivery: Queue orders in persistent queue (Kafka). If primary fails before ack, backup retries from queue. May send twice, but idempotency prevents duplicate execution. State machine replication: Use Raft to replicate order state. All regions see same sequence of orders. On failover, new leader has complete state. Exactly-once semantics: Combine idempotency + at-least-once + deduplication. Order ID + sequence number ensures no gaps or duplicates. Testing: Failover drills monthly. Kill primary region mid-order. Verify: All orders executed exactly once, no losses, no duplicates. Recovery time <1 minute. Audit after drill. Critical: Financial systems must guarantee no order loss or duplication. Cost of mistake: $millions in trading losses or regulatory fines.",
    keyPoints: [
      'Active-active: low latency per region (1ms local), high availability, eventual consistency, $3M+ cost',
      'Clock sync: PTP <1μs within region, NTP 1-50ms across regions, GPS-synchronized grandmasters',
      'Replication: synchronous for critical state (80-150ms latency), asynchronous for historical, Raft consensus',
      'Partitions: quorum (2 of 3), minority rejects orders (safe), reconcile when healed, monthly chaos testing',
      'No duplicates/losses: UUID idempotency, at-least-once delivery, Raft state replication, monthly failover drills',
    ],
  },
  {
    id: 'dts-q-2',
    question:
      'Explain the CAP theorem in the context of trading systems. For each scenario, discuss which two of (Consistency, Availability, Partition tolerance) you would choose and why: (1) order management system, (2) risk system, (3) market data system, (4) compliance system. What are the practical implications of each choice?',
    sampleAnswer:
      'CAP theorem for trading systems: CAP theorem: Can only have 2 of 3: Consistency (all nodes see same data), Availability (system responds to requests), Partition tolerance (works despite network failures). Network partitions will happen (cables cut, switch failure, DDoS). Must choose between CP (consistency + partition tolerance) or AP (availability + partition tolerance). (1) Order Management System: Choose AP (Availability + Partition tolerance) over consistency. Reasoning: Better to keep accepting orders with stale position data than stop trading. Financial cost of downtime: $thousands per minute. Risk: May accept order that slightly exceeds limit (acceptable temporary inconsistency). Mitigation: Pre-trade checks with buffers. Limit = $1M, but block at $900K (10% buffer). If partition causes stale data (actual position = $950K, system thinks $850K), still within buffer. Post-partition: Reconcile positions, close any positions that actually exceeded limits. Alert risk managers. Practical implications: During partition: US region may have position = 1000 shares, Europe thinks 900 shares. Both accept new orders. After partition: Reconcile → actual position = 1200 shares (accumulated during partition). If exceeded hard limit → close position immediately, report to risk. Better than: Rejecting orders during partition (lost revenue, angry clients). Alternative (CP - consistency over availability): Block all orders during partition until resolved. Problem: Could be hours without trading. Unacceptable for most firms. (2) Risk System: Choose CP (Consistency + Partition tolerance) over availability. Reasoning: Must have accurate positions for risk calculations. Cannot make risk decisions on stale data (could approve order that violates limits). Risk: System unavailable during partition. Impact: Cannot accept new orders (but prevents catastrophic loss from bad risk data). Implementation: Risk system runs in single region (master). All orders routed through master for risk check. If partition: Master continues (has quorum), minority partitions reject orders. Practical implications: If master partitions from exchange: Cannot send orders (no risk approval). Lost trading opportunity. Better than: Sending orders with stale risk data → potential $millions loss from limit breach. Example: Knight Capital lost $440M in 45 minutes (2012) from runaway algorithm. Proper CP risk system would have stopped after first breach. Trade-off: Accept occasional unavailability (<1% time) to prevent rare but catastrophic losses (>$millions). (3) Market Data System: Choose AP (Availability + Partition tolerance) over consistency. Reasoning: Market data is time-sensitive. Stale data better than no data (can still trade on delayed prices). Strategies can handle small discrepancies (prices change naturally anyway). Risk: During partition, may see inconsistent prices. US region: AAPL = $150.00, Europe region: AAPL = $150.10 (delayed update). Impact: Minor. Price naturally moves $0.10 in milliseconds. Strategies robust to small delays. Implementation: Each region has local market data feed. Replicate asynchronously (no blocking). If partition: Use local data (may be stale but usable). Practical implications: During partition: US trades on US data, Europe on Europe data. Slightly different prices but both valid (market moves fast). After partition: No reconciliation needed (market data is ephemeral, past prices irrelevant). Better than: No data during partition → cannot trade at all. Alternative (strong consistency): Wait for all regions to agree on price. Problem: 80-150ms latency added (cross-region sync). Unacceptable for HFT. (4) Compliance System: Choose CP (Consistency + Partition tolerance) over availability. Reasoning: Audit trail must be complete and consistent. Cannot have gaps or inconsistencies in trade logs (regulatory requirement). Missing even one trade → regulatory fine + reputational damage. Risk: System unavailable during partition. Impact: Cannot log trades → must stop trading (cannot trade without audit trail). Implementation: Compliance log in strongly consistent database (PostgreSQL with synchronous replication). Append-only log, never delete. Write to multiple replicas before ack. If partition: Master + majority can continue. Minority stops logging → must stop trading. Practical implications: If compliance system partitions: Majority partition continues trading (has audit trail). Minority stops all trading (cannot log trades). Alert compliance team immediately. After partition: Verify no gaps in log. Audit sequence numbers (should be contiguous). Better than: Logging with eventual consistency → gaps possible → regulatory violation. Example: Must prove to SEC that all trades logged. Any gap or inconsistency → failed audit → fine ($millions) + restrictions. Trade-off: Rare unavailability (<0.1% time) vs regulatory compliance (mandatory). Summary table: System | Choice | Reasoning | Partition behavior: OMS | AP | Keep trading | Stale positions (temporary). Risk | CP | Accurate limits | Minority stops, master continues. Market Data | AP | Low latency | Local data (slightly stale). Compliance | CP | Audit trail | Minority stops trading. Key insight: No one-size-fits-all. Each system has different priorities. Use hybrid approach: CP for critical safety (risk, compliance), AP for revenue-generating (OMS, market data).',
    keyPoints: [
      'OMS: AP (availability over consistency), stale positions acceptable, keep trading during partition, reconcile after',
      'Risk: CP (consistency over availability), accurate limits critical, minority stops to prevent catastrophic losses',
      'Market Data: AP, stale prices acceptable (better than no data), local feeds with async replication',
      'Compliance: CP, audit trail must be complete (regulatory requirement), minority stops trading if partitioned',
      'Hybrid approach: CP for safety systems (risk, compliance), AP for revenue systems (OMS, market data)',
    ],
  },
  {
    id: 'dts-q-3',
    question:
      'Design a global order routing system that selects the best exchange for each order. Address: (1) factors to consider (latency, fees, liquidity, spreads), (2) dynamic routing based on real-time conditions, (3) handling exchange outages, (4) smart order types (IOC, FOK, iceberg), (5) regulatory requirements (best execution). How do you measure and prove best execution to regulators?',
    sampleAnswer:
      "Global order routing system: (1) Factors to consider: Latency: Network latency to exchange. Measure: Ping time from server to exchange. US client → NYSE: 1ms, → LSE: 80ms, → TSE: 150ms. Lower latency increases fill probability (arrive before others). Weight: 40% for HFT, 10% for institutional. Fees: Exchange fees + broker fees + clearing fees. Example: NYSE: 0.0030 per share ($3 per 1000 shares), NASDAQ: 0.0020 per share (cheaper), LSE: 0.0050 per share (more expensive). Weight: 20% (important but not dominant). Liquidity: Volume available at bid/ask. High liquidity → less market impact. Measure: Order book depth. NYSE: 10,000 shares at bid, NASDAQ: 5,000 shares. For large order (5,000+ shares), NYSE better (less impact). Weight: 30% (critical for large orders). Spreads: Bid-ask spread. Narrow spread → less implicit cost. SPY on NYSE: $0.01 spread (0.002%), Small cap on NASDAQ: $0.10 spread (1%). Weight: 10%. Scoring function: score = 0.40×latency_score + 0.20×fee_score + 0.30×liquidity_score + 0.10×spread_score. Normalize each score 0-100 (best exchange = 100). (2) Dynamic routing: Real-time conditions change: NYSE liquidity 10,000 → 1,000 shares (large order filled). NYSE latency 1ms → 50ms (network congestion). Update routing every second (or on order book change). Implementation: class SmartRouter: def route_order(self, order): candidates = self.get_exchanges_for_symbol(order.symbol). scores = {}. for exchange in candidates: latency = self.measure_latency(exchange) # Recent pings. liquidity = self.get_order_book_depth(exchange, order.side). fees = self.get_fees(exchange). spread = self.get_spread(exchange). scores[exchange] = self.calculate_score(latency, liquidity, fees, spread). best = max(scores, key=scores.get). return best. Cache: Cache scores for 1 second (avoid recalculating per order). Invalidate on market data update (order book change). (3) Handling exchange outages: Detect outages: Heartbeat monitoring (ping every second). No response for 5 seconds → mark exchange as down. Connection refused → immediate down. Fallback: If primary exchange down, route to backup. Example: NYSE down → route to NASDAQ. Maintain ranking of exchanges (primary, secondary, tertiary). Alert: PagerDuty alert when exchange down. Manual review if down >5 minutes. Resume: When exchange reconnects, wait 30 seconds (ensure stable), verify with test order, resume routing. Track: Log all outages (duration, impact, orders rerouted). Monthly report on exchange reliability. (4) Smart order types: IOC (Immediate or Cancel): Execute immediately, cancel unfilled portion. Use for: Aggressive orders, don't want to leave resting order. Routing: Send to exchange with best immediate liquidity. FOK (Fill or Kill): Execute fully or cancel entire order. Use for: Large orders, all-or-nothing. Routing: Only send to exchanges with sufficient liquidity (depth >= order size). Iceberg: Show small portion, hide remaining. Use for: Large orders, minimize market impact. Routing: Send to exchange with best total liquidity (not just top-of-book). Implementation: if order.type == 'FOK': exchanges = [e for e in candidates if self.get_depth(e) >= order.quantity]. if not exchanges: return None  # Cannot fill fully anywhere. elif order.type == 'ICEBERG': # Send in chunks. chunk_size = order.display_quantity. for chunk in split_order(order, chunk_size): self.route_order(chunk). (5) Regulatory requirements (Best Execution): SEC Rule 605/606 (US): Brokers must disclose order routing practices. Quarterly report: Where orders sent, fill rates, speed. MiFID II (Europe): Best execution obligation. Must consider: price, costs, speed, likelihood of execution. Annual report to clients on execution quality. Proving best execution: Measurement: Track every order: exchange sent to, price achieved, fees paid, latency. Quarterly analysis: Compare actual execution vs alternatives. Metric: Price improvement. Example: Order to buy 1000 AAPL. Routed to NYSE, filled @ $150.01. Analyze: Could have filled on NASDAQ @ $150.02 (worse). → Decision justified. Statistics: Calculate average price improvement across all orders. Report: Top exchanges by fill rate, average latency, price improvement. If consistently worse than alternatives → investigate and fix. Independent verification: Third-party TCA (Transaction Cost Analysis). Company like Abel Noser analyzes execution quality. Annual audit: Regulators review routing logic and results. Documentation: Maintain audit trail: routing decision rationale, scores for each exchange, why chosen exchange selected. If challenged: \"We routed to NYSE because: latency 1ms (vs NASDAQ 1.2ms), liquidity 10K shares (vs 5K), spread $0.01 (same), total score 92 (vs 88).\" Testing: Backtest routing algorithm on historical data. Prove it achieves better execution than alternatives. A/B testing: Route 10% of orders to algorithm A, 90% to algorithm B. Compare results. If B significantly better → switch to B. Continuous improvement: Monthly review of routing performance. Identify underperforming exchanges or edge cases. Update scoring function weights based on results. Example report for regulators: \"Q4 2024: Routed 1.2M orders across 5 exchanges. Average fill rate: 98.5%. Average price improvement: $0.015 per share ($18K total savings). NYSE: 60% of orders (best latency + liquidity). NASDAQ: 30% (lower fees). Arca: 10% (alternative for liquidity).\" Conclusion: Best execution is measurable and provable. Combination of: Smart routing (consider all factors), monitoring (track every decision), reporting (prove to regulators), continuous improvement (update based on results).",
    keyPoints: [
      'Factors: latency (40%), liquidity (30%), fees (20%), spreads (10%), dynamic scoring updated every second',
      'Routing: calculate scores per exchange, select best, cache 1s, invalidate on order book changes',
      'Outages: heartbeat monitoring, automatic fallback to backup exchange, 30s stabilization before resume',
      'Smart types: FOK (check depth first), IOC (best immediate liquidity), Iceberg (split into chunks)',
      'Best execution: track every order, quarterly analysis vs alternatives, price improvement metrics, TCA audit, prove to regulators',
    ],
  },
];
