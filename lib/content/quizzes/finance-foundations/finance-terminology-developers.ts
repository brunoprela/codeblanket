export const financeTerminologyDevelopersQuiz = [
    {
        id: 'ftd-q-1',
        question:
            'Build a comprehensive portfolio analytics system that calculates: (1) Alpha and Beta (using CAPM model against S&P 500 benchmark), (2) Sharpe ratio (annualized, risk-free rate 2%), (3) Maximum drawdown (peak-to-trough decline), (4) Volatility (annualized standard deviation), (5) Information ratio (alpha / tracking error). Include: daily returns processing, rolling window calculations (30-day, 90-day, 1-year), comparative analytics (portfolio vs benchmark), visualization (equity curve, drawdown chart). Handle edge cases: insufficient data (< 30 days), extreme outliers (flash crash days), negative Sharpe ratios. How do you optimize performance for real-time calculation on 10K+ portfolios?',
        sampleAnswer: `Portfolio analytics system design: Data pipeline ingests daily returns from positions table (calculate portfolio_return = sum(position_weight × asset_return)), store in timeseries database (InfluxDB or TimescaleDB for fast range queries), CAPM calculation: beta = covariance(portfolio_returns, market_returns) / variance(market_returns), alpha = mean(portfolio_return) - (risk_free_rate + beta × (mean(market_return) - risk_free_rate)), use numpy vectorized operations (avoid loops), Sharpe ratio: excess_returns = returns - risk_free_rate/252, sharpe = mean(excess_returns) / std(excess_returns) × sqrt(252) for annualization, max drawdown: cumulative_returns = cumprod(1 + returns), running_max = maximum.accumulate(cumulative_returns), drawdown = (cumulative_returns - running_max) / running_max, max_dd = min(drawdown), volatility: annualized_vol = std(returns) × sqrt(252), information ratio: tracking_error = std(portfolio_returns - benchmark_returns), IR = alpha / tracking_error, rolling calculations: use pandas rolling windows (df.rolling(30).apply(lambda x: calculate_sharpe(x))), cache results in Redis (key: portfolio_id:metric:window, TTL: 1 hour), edge cases: <30 days return None or NaN (insufficient data), extreme outliers filter using winsorization (cap returns at ±3 sigma), negative Sharpe okay (means lost money or took on too much risk), performance optimization: batch processing (calculate 10K portfolios in single numpy array operation instead of loops), materialize daily (pre-calculate metrics at market close, serve from cache during day), incremental updates (only recalculate when new data arrives, not full history), distributed processing (Celery workers for parallel calculation if >100K portfolios), database indexing (index on portfolio_id + date for fast range scans).`,
        keyPoints: [
            'CAPM metrics: Beta = cov(portfolio, market) / var(market), Alpha = actual - expected return, use numpy vectorized ops for speed',
            'Sharpe ratio: (mean_return - risk_free) / std_return × sqrt(252) for annualization, >2 excellent, >1 good, <0 bad',
            'Max drawdown: Track running max of cumulative returns, drawdown = (current - running_max) / running_max, min = MDD',
            'Rolling windows: Use pandas .rolling(30).apply() for 30/90/365 day metrics, cache results in Redis with 1-hour TTL',
            'Performance: Batch processing (10K portfolios in single array), materialize daily (pre-calculate at close), incremental updates only',
        ],
    },
    {
        id: 'ftd-q-2',
        question:
            'Design a real-time P&L tracking system for day traders: (1) Track open positions (unrealized P&L = current_price - entry_price), (2) Track closed trades (realized P&L), (3) Calculate intraday highs/lows (best unrealized P&L, worst drawdown), (4) Gross vs net P&L (net = gross - commissions - fees - slippage), (5) Per-strategy attribution (if running multiple strategies). System must update in real-time (<100ms latency) as prices change. Include wash sale detection (sold at loss, repurchased within 30 days = disallowed tax deduction). How do you handle: partial fills (100 share order filled as 50 + 50)? FIFO vs LIFO accounting? Forex trades (profit in pips, position sizing)?',
        sampleAnswer: `Real-time P&L system: Positions table schema: position_id, ticker, strategy_id, entry_timestamp, entry_price, quantity, current_price, unrealized_pnl, Entry point (order filled): create position record with entry_price, quantity, calculate position_value = quantity × entry_price, Price updates (WebSocket market data): receive tick for ticker, update current_price for all open positions with ticker, calculate unrealized_pnl = (current_price - entry_price) × quantity, push update via WebSocket to UI (<100ms total latency), Exit point (close position): calculate realized_pnl = (exit_price - entry_price) × quantity, deduct costs: commissions (typically $0 for stocks, $0.65/contract for options), fees (SEC fee $0.0000278 per dollar, exchange fees ~$0.003/share), slippage (expected_price - actual_price, estimate as half-spread for limit orders), net_pnl = realized_pnl - costs, insert into closed_trades table, Intraday tracking: maintain session_high_pnl (max of all realized + unrealized during day), session_low_pnl (min, tracks max intraday drawdown), reset at market close (4pm ET), strategy attribution: tag each position with strategy_id, aggregate P&L by strategy (SELECT strategy_id, SUM(unrealized_pnl) FROM positions GROUP BY strategy_id), wash sale detection: on close at loss, check if repurchased same ticker within 30 days (SELECT * FROM closed_trades WHERE ticker=X AND close_date BETWEEN exit_date-30 AND exit_date+30 AND pnl < 0), if match found, disallow tax deduction (add to cost_basis of new position instead), edge cases: partial fills create multiple position records (100 share order → position_id=1 qty=50, position_id=2 qty=50), calculate average entry price when displaying, FIFO accounting default (first in first out): close oldest positions first, LIFO optional (last in first out), configurable per strategy, forex trades: P&L in pips (price movements in 4th decimal: 1.2000 → 1.2001 = 1 pip), convert to USD: pnl_usd = pips × pip_value × lot_size (standard lot = 100K units), performance: in-memory cache (Redis) for open positions (updated on every tick), database writes batched (flush every 1 second or 1000 updates), market data WebSocket → position update → P&L calc → UI push entire chain <100ms.`,
        keyPoints: [
            'Unrealized P&L: (current_price - entry_price) × quantity, update on every tick via WebSocket <100ms latency',
            'Realized P&L: Calculate on exit, deduct costs (commissions + fees + slippage), net = gross - costs',
            'Intraday highs/lows: Track session_high_pnl and session_low_pnl (max intraday drawdown), reset at 4pm ET market close',
            'Wash sale: On loss, check if repurchased within 30 days before/after, disallow tax deduction if match (add to new cost basis)',
            'Edge cases: Partial fills = multiple positions (aggregate for display), FIFO default (close oldest first), forex in pips then convert to USD',
        ],
    },
    {
        id: 'ftd-q-3',
        question:
            'Implement a FIX protocol order gateway that: (1) Accepts REST API orders from internal systems, (2) Converts to FIX messages (New Order - tag 35=D), (3) Sends to broker via FIX session, (4) Receives execution reports (tag 35=8), (5) Updates internal order database. Include: FIX session management (logon/logout, heartbeats every 30s, sequence number tracking), message validation (required tags, checksum verification), error handling (reject orders, session disconnects). How do you ensure: no duplicate orders (idempotency)? Orders execute exactly once? Session reconnect without missing executions? Compliance audit trail (log every message for 7 years)?',
        sampleAnswer: `FIX gateway architecture: REST API endpoint receives order JSON, convert to FIX: create FIX message with required tags (8=FIX.4.2 BeginString, 35=D MsgType NewOrder, 49=our_comp_id SenderCompID, 56=broker_comp_id TargetCompID, 11=unique_order_id ClOrdID, 55=ticker Symbol, 54=side 1=Buy 2=Sell, 38=quantity OrderQty, 40=order_type 1=Market 2=Limit, 44=price if limit, 60=timestamp TransactTime), calculate body length (tag 9) and checksum (tag 10 = sum of bytes mod 256), session management: on startup send Logon message (35=A) with credentials, broker responds with Logon, send Heartbeat (35=0) every 30 seconds to keep session alive, track sequence numbers: outbound_seq_num (increment on each message sent), inbound_seq_num (expect from broker), if gap detected (expected seq=100, received=102) send Resend Request (35=2) for missing messages, execution reports: receive FIX message 35=8 with tags (11=ClOrdID, 17=ExecID, 39=OrdStatus 0=New 1=PartialFill 2=Filled, 14=CumQty, 31=LastPx), parse and update orders table SET status=filled, fill_price=31_LastPx, updated_at=NOW() WHERE client_order_id=11_ClOrdID, idempotency: client generates unique client_order_id (UUID), gateway checks if order_id exists in database before sending, if duplicate POST with same order_id, return existing order (don't send new FIX message), exactly-once execution: store (client_order_id, fix_sequence_number) mapping, on session reconnect, resend any orders with status=pending AND no execution report received, session reconnect: detect disconnect (missed heartbeat or TCP connection drop), immediately attempt reconnect with Logon message including last received sequence number, broker will send any missed execution reports during gap, audit trail: log every FIX message sent/received to append-only log table (timestamp, direction send/receive, message_type, raw_fix_message, sequence_number), store in S3 with 7-year retention and WORM (Object Lock) for SEC compliance, performance: use binary FIX parser (not string splitting), connection pool for broker sessions (maintain persistent TCP connection), async I/O (don't block API thread waiting for FIX response).`,
        keyPoints: [
            'FIX message structure: Tags like 35=D (new order), 11=ClOrdID (unique order ID), 55=Symbol, 54=Side, 38=Qty, calculate checksum (tag 10)',
            'Session management: Logon on startup, heartbeat every 30s, track sequence numbers (outbound/inbound), resend request if gap detected',
            'Execution reports: Receive tag 35=8 with order status (39=OrdStatus), parse and update database with fill price/quantity',
            'Idempotency: Client generates UUID for order_id, check if exists before sending, return existing order on duplicate POST',
            'Audit trail: Log every FIX message to append-only table + S3 with 7-year retention and WORM for SEC compliance',
        ],
    },
];

