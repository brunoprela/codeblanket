export const mockingWithUnittestMockQuiz = [
  {
    id: 'mum-q-1',
    question:
      'Design a mocking strategy for testing a payment processing system that integrates with: (1) external payment gateway API (Stripe), (2) fraud detection service, (3) email notification service, (4) database for transaction logging. Address: when to mock vs use real objects, handling API rate limits in tests, mocking async operations, verifying correct error handling, and testing retry logic. Provide specific code examples.',
    sampleAnswer:
      'Payment system mocking strategy: (1) When to mock vs real objects: Mock external services: Stripe API, fraud detection, email (slow, costs money, unreliable). Use real objects: Internal business logic, domain models, in-memory data structures. Example: ```python# payment_processor.pyclass PaymentProcessor:    def __init__(self, stripe_client, fraud_service, email_service, db):        self.stripe = stripe_client        self.fraud = fraud_service        self.email = email_service        self.db = db    def process_payment(self, amount, card_token):        # Check fraud        fraud_result = self.fraud.check(amount, card_token)        if fraud_result[\"risk\"] > 0.8:            return {\"status\": \"declined\", \"reason\": \"fraud\"}        # Charge card        charge_result = self.stripe.charge(amount, card_token)        if charge_result[\"status\"] != \"success\":            return {\"status\": \"failed\", \"reason\": charge_result[\"error\"]}        # Log transaction        self.db.insert_transaction({\"amount\": amount, \"status\": \"success\"})        # Send email        self.email.send_receipt(charge_result[\"id\"])        return {\"status\": \"success\", \"charge_id\": charge_result[\"id\"]}# test_payment_processor.py@patch(\"payment_processor.EmailService\")@patch(\"payment_processor.Database\")@patch(\"payment_processor.FraudService\")@patch(\"payment_processor.StripeClient\")def test_successful_payment(mock_stripe, mock_fraud, mock_db, mock_email):    # Configure mocks    mock_fraud.return_value.check.return_value = {\"risk\": 0.1}    mock_stripe.return_value.charge.return_value = {\"status\": \"success\", \"id\": \"ch_123\"}    processor = PaymentProcessor(mock_stripe(), mock_fraud(), mock_email(), mock_db())    result = processor.process_payment(100.0, \"tok_visa\")    assert result[\"status\"] == \"success\"    mock_stripe().charge.assert_called_once_with(100.0, \"tok_visa\")    mock_db().insert_transaction.assert_called_once()    mock_email().send_receipt.assert_called_once_with(\"ch_123\")``` (2) Handling API rate limits: Problem: Stripe rate limit is 100 req/s. Running 1000 tests would hit limit. Mock API calls: ```python@patch(\"stripe.Charge.create\")def test_payment_no_rate_limit(mock_charge):    mock_charge.return_value = {\"id\": \"ch_123\", \"status\": \"succeeded\"}    # Run 1000 testsâ€”no actual API calls, no rate limit``` Test rate limit handling: ```python@patch(\"stripe.Charge.create\")def test_rate_limit_retry(mock_charge):    # First call: rate limit error    # Second call: success    mock_charge.side_effect = [        stripe.error.RateLimitError(\"Rate limit exceeded\"),        {\"id\": \"ch_123\", \"status\": \"succeeded\"}    ]    result = process_payment_with_retry(100.0, \"tok_visa\")    assert result[\"status\"] == \"success\"    assert mock_charge.call_count == 2  # Verify retry``` (3) Mocking async operations: ```python# Async payment processorasync def process_payment_async(amount, card_token):    async with aiohttp.ClientSession() as session:        async with session.post(\"https://api.stripe.com/charges\", ...) as resp:            result = await resp.json()    return result# Test with mocked async operations@pytest.mark.asyncio@patch(\"aiohttp.ClientSession\")async def test_async_payment(mock_session):    # Mock async context managers    mock_response = AsyncMock()    mock_response.json = AsyncMock(return_value={\"id\": \"ch_123\"})    mock_session.return_value.__aenter__.return_value.post.return_value.__aenter__.return_value = mock_response    result = await process_payment_async(100.0, \"tok_visa\")    assert result[\"id\"] == \"ch_123\"``` (4) Verifying error handling: ```python@patch(\"stripe.Charge.create\")def test_card_declined(mock_charge):    mock_charge.side_effect = stripe.error.CardError(\"Card declined\", param=\"card\", code=\"card_declined\")    result = process_payment(100.0, \"tok_visa\")    assert result[\"status\"] == \"declined\"    assert \"card\" in result[\"reason\"]@patch(\"stripe.Charge.create\")def test_network_error(mock_charge):    mock_charge.side_effect = requests.ConnectionError(\"Network error\")    result = process_payment(100.0, \"tok_visa\")    assert result[\"status\"] == \"error\"    assert \"network\" in result[\"reason\"].lower()``` (5) Testing retry logic: ```pythondef test_retry_logic():    mock_stripe = Mock()    # Fail twice, then succeed    mock_stripe.charge.side_effect = [        Exception(\"Timeout\"),        Exception(\"Timeout\"),        {\"status\": \"success\", \"id\": \"ch_123\"}    ]    processor = PaymentProcessor(mock_stripe, Mock(), Mock(), Mock())    result = processor.process_payment_with_retry(100.0, \"tok_visa\", max_retries=3)    assert result[\"status\"] == \"success\"    assert mock_stripe.charge.call_count == 3def test_retry_exhausted():    mock_stripe = Mock()    mock_stripe.charge.side_effect = Exception(\"Timeout\")    processor = PaymentProcessor(mock_stripe, Mock(), Mock(), Mock())    result = processor.process_payment_with_retry(100.0, \"tok_visa\", max_retries=3)    assert result[\"status\"] == \"failed\"    assert mock_stripe.charge.call_count == 3``` Summary: Mock external: Stripe, fraud, email (fast, no rate limits). Real internal: Business logic, models. Rate limits: Mock API calls, test rate limit handling separately. Async: Use AsyncMock, mock context managers. Errors: side_effect for exceptions, verify handling. Retry: side_effect list, verify call_count.',
    keyPoints: [
      'Mock external: Stripe/fraud/email (slow, costly), use real internal logic (models, business rules)',
      'Rate limits: Mock API calls (avoid limits), test rate limit handling with side_effect RateLimitError',
      'Async mocking: AsyncMock for async functions, mock aiohttp.ClientSession context managers',
      'Error handling: side_effect exceptions (CardError, ConnectionError), verify correct error responses',
      'Retry logic: side_effect list [Exception, Exception, success], verify call_count matches retries',
    ],
  },
  {
    id: 'mum-q-2',
    question:
      'Compare mocking strategies: (1) patch as decorator vs context manager, (2) Mock vs MagicMock, (3) pytest-mock mocker vs unittest.mock patch, (4) spec vs spec_set, (5) return_value vs side_effect. For each, explain when to use, provide code examples, and discuss tradeoffs (readability, flexibility, type safety).',
    sampleAnswer:
      'Mocking strategies comparison: (1) patch decorator vs context manager: Decorator: ```python@patch(\"module.ExternalService\")def test_function(mock_service):    mock_service.return_value.method.return_value = \"result\"    result = function_under_test()    assert result == \"result\"# Pros: Clean, reusable, automatic cleanup# Cons: Adds parameter, multiple patches in reverse order``` Context manager: ```pythondef test_function():    with patch(\"module.ExternalService\") as mock_service:        mock_service.return_value.method.return_value = \"result\"        result = function_under_test()        assert result == \"result\"# Pros: Explicit scope, no parameters, patches in order# Cons: Indentation, less reusable``` When to use: Decorator: Single patch, multiple tests need same mock. Context manager: Scoped mocking, multiple patches in one test, conditional mocking. (2) Mock vs MagicMock: Mock: ```pythonmock = Mock()mock.method.return_value = 10# Does not support magic methods like __len__, __str__``` MagicMock: ```pythonmagic_mock = MagicMock()magic_mock.__len__.return_value = 5len(magic_mock)  # 5magic_mock.__iter__.return_value = iter([1,2,3])list(magic_mock)  # [1,2,3]``` When to use: Mock: Default choice (lighter, faster). MagicMock: Need magic methods (__len__, __iter__, __enter__, etc.). (3) pytest-mock vs unittest.mock: unittest.mock: ```python@patch(\"module.Service\")def test_function(mock_service):    mock_service.return_value = \"result\"    ...``` pytest-mock: ```pythondef test_function(mocker):    mock_service = mocker.patch(\"module.Service\")    mock_service.return_value = \"result\"    ...# Pros: Cleaner, no decorator, integrates with pytest# Cons: Requires pytest-mock plugin``` When to use: unittest.mock: Standard library, no dependencies. pytest-mock: Using pytest (cleaner syntax). (4) spec vs spec_set: spec (read-only): ```pythonmock = Mock(spec=PaymentGateway)mock.charge()  # OKmock.invalid_method()  # AttributeError (catches typos)mock.new_attribute = \"value\"  # OK (can add attributes)``` spec_set (strict): ```pythonmock = Mock(spec_set=PaymentGateway)mock.charge()  # OKmock.new_attribute = \"value\"  # AttributeError (cannot add)``` When to use: spec: Type safety, catch typos. spec_set: Strict enforcement, prevent attribute additions. (5) return_value vs side_effect: return_value (static): ```pythonmock.method.return_value = 42mock.method()  # 42mock.method()  # 42 (always same)``` side_effect (dynamic): ```python# Different values per callmock.method.side_effect = [1, 2, 3]mock.method()  # 1mock.method()  # 2mock.method()  # 3# Raise exceptionmock.method.side_effect = Exception(\"Error\")mock.method()  # Raises Exception# Custom functiondef side_effect_func(arg):    return arg * 2mock.method.side_effect = side_effect_funcmock.method(5)  # 10``` When to use: return_value: Same result every call. side_effect: Different results per call, exceptions, custom logic. Summary: Decorator vs context: Decorator for reusable, context for scoped. Mock vs MagicMock: Mock default, MagicMock for magic methods. pytest-mock vs unittest: pytest-mock cleaner, unittest standard. spec vs spec_set: spec for type safety, spec_set for strict. return_value vs side_effect: return_value static, side_effect dynamic/exceptions.',
    keyPoints: [
      'Decorator vs context: Decorator reusable/clean, context manager scoped/explicit, choose based on test structure',
      'Mock vs MagicMock: Mock default (lighter), MagicMock for __len__/__iter__/__enter__ magic methods',
      'pytest-mock vs unittest: pytest-mock cleaner (mocker fixture), unittest standard library (no deps)',
      'spec vs spec_set: spec catches typos (AttributeError on invalid methods), spec_set strict (no new attributes)',
      'return_value vs side_effect: return_value static same result, side_effect dynamic [1,2,3]/exceptions/functions',
    ],
  },
  {
    id: 'mum-q-3',
    question:
      'Debug a flaky test suite where mocking issues cause intermittent failures: (1) mock object state persisting between tests, (2) patching at wrong import level, (3) missing return_value causing unexpected Mock objects, (4) assertion order mismatches with multiple patches, (5) datetime.now() not properly mocked. For each, explain the symptom, root cause, fix, and prevention strategy.',
    sampleAnswer:
      'Debugging flaky mocking issues: (1) Mock state persisting between tests: Symptom: ```python# Test 1 passesdef test_first(mock_service):    mock_service.method.return_value = \"first\"    result = function()    assert result == \"first\"# Test 2 fails intermittently (uses \"first\" instead of \"second\")def test_second(mock_service):    mock_service.method.return_value = \"second\"    result = function()    assert result == \"second\"  # Fails if test_first ran first``` Root cause: Mock configured at module level or session scope persists. Fix: ```python@pytest.fixture(scope=\"function\")  # Not session/moduledef mock_service():    return Mock()# Or reset mock between testsdef test_second(mock_service):    mock_service.reset_mock()  # Clear previous calls    mock_service.method.return_value = \"second\"    ...``` Prevention: Use function-scoped fixtures (default), avoid module/session mocks. (2) Patching at wrong import level: Symptom: ```python# module_a.pyfrom module_b import ExternalServicedef function():    service = ExternalService()  # Uses module_a.ExternalService# Test (WRONG)@patch(\"module_b.ExternalService\")  # Patches original, not useddef test_function(mock_service):    result = function()  # Uses real ExternalService!    assert ...  # Fails``` Root cause: Patching where defined, not where used. Fix: ```python@patch(\"module_a.ExternalService\")  # Patch where useddef test_function(mock_service):    result = function()  # Uses mocked service    assert ...``` Prevention: Patch where object is imported/used, not where defined. Rule: patch(\"where_its_used.Object\"). (3) Missing return_value causing Mock objects: Symptom: ```python@patch(\"module.Service\")def test_function(mock_service):    mock_service.method = \"result\"  # WRONG    result = function_that_calls_service()    assert result == \"expected\"  # Fails: result is Mock objectfunction:    service = Service()    return service.method()  # Returns Mock, not \"result\"``` Root cause: Assigned string to method instead of return_value. Fix: ```python@patch(\"module.Service\")def test_function(mock_service):    mock_service.return_value.method.return_value = \"result\"  # Correct    result = function_that_calls_service()    assert result == \"expected\"``` Prevention: Always use .return_value or .side_effect. Never assign directly to method. (4) Assertion order with multiple patches: Symptom: ```python@patch(\"module.ServiceC\")@patch(\"module.ServiceB\")@patch(\"module.ServiceA\")def test_function(mock_a, mock_b, mock_c):  # Order confusing    mock_c.method.return_value = \"c\"  # Actually mocks ServiceA!    ...  # Fails``` Root cause: Decorators applied bottom-to-top, arguments top-to-bottom (reverse order). Fix: ```python@patch(\"module.ServiceC\")@patch(\"module.ServiceB\")@patch(\"module.ServiceA\")def test_function(mock_a, mock_b, mock_c):  # a, b, c matches A, B, C    # Arguments match decorator order (top to bottom)    mock_c.return_value.method.return_value = \"c\"  # Correctly mocks C    mock_b.return_value.method.return_value = \"b\"    mock_a.return_value.method.return_value = \"a\"``` Prevention: Use context managers (patches in order) or descriptive parameter names. (5) datetime.now() not properly mocked: Symptom: ```pythondef test_timestamp():    with patch(\"datetime.datetime.now\") as mock_now:        mock_now.return_value = datetime(2024, 1, 1)        result = function_that_uses_datetime()  # Still uses real datetime!``` Root cause: datetime is C extension, special mocking required. Fix: ```pythonfrom unittest.mock import Mockimport datetime@patch(\"module.datetime\")  # Patch entire datetime moduledef test_timestamp(mock_datetime):    fixed_time = datetime.datetime(2024, 1, 1, 12, 0, 0)    mock_datetime.now.return_value = fixed_time    mock_datetime.datetime.now.return_value = fixed_time  # Both    result = function_that_uses_datetime()    assert result.created_at == fixed_time``` Better: Use freezegun library: ```pythonfrom freezegun import freeze_time@freeze_time(\"2024-01-01 12:00:00\")def test_timestamp():    result = function_that_uses_datetime()    assert result.created_at == datetime(2024, 1, 1, 12, 0, 0)``` Prevention: Use freezegun for datetime mocking (handles edge cases), or patch entire datetime module. Summary: Mock persistence: Use function scope, reset_mock() between tests. Wrong import level: Patch where used (module_a.Service), not defined (module_b.Service). Missing return_value: Always .return_value, never direct assignment. Decorator order: Arguments reverse decorator order, use context managers. datetime mocking: Use freezegun or patch entire module, datetime is C extension.',
    keyPoints: [
      'Persistence: Function-scoped fixtures prevent state leakage, reset_mock() clears previous calls',
      'Import level: Patch where used (module_a.Service) not defined (module_b.Service)â€”patch imports',
      'return_value: Always mock.method.return_value = X, never mock.method = X (creates Mock object)',
      'Decorator order: Args reverse decorator order (bottom-to-top), use context manager for clarity',
      'datetime: Use freezegun library or patch entire datetime module (C extension needs special handling)',
    ],
  },
];
