export const marketMicrostructureFundamentalsQuiz = [
  {
    id: 'mmf-q-1',
    question:
      'Design a production-grade order matching engine that: (1) Supports price-time priority matching, (2) Handles market, limit, IOC, FOK, and stop orders, (3) Processes 100,000+ orders per second, (4) Maintains sub-millisecond latency for order acknowledgment, (5) Provides Level 1, 2, and 3 market data feeds, (6) Supports order modifications and cancellations, (7) Handles corporate actions (splits, dividends). Requirements: Thread-safe data structures, lock-free where possible, proper order of operations (match → ack → market data), fair queuing, audit trail for all actions. How do you handle: concurrent order submissions (multiple threads)? Priority inversion (slow operations blocking fast path)? Market data distribution (pub/sub, multicast)? Order book recovery after crash? Tick size constraints? Self-trade prevention?',
    sampleAnswer:
      "Order matching engine design: Architecture: Core components: Order book (in-memory data structures), Matching engine (business logic), Market data publisher (outbound feeds), Order gateway (inbound orders), Persistence layer (audit trail, recovery). Threading model: Single-threaded per symbol (avoid locks, deterministic ordering), Round-robin across symbols (load balancing), Separate thread for market data (don't block matching), IO threads for network (order receipt, market data distribution). Data structures: Order book representation: Price levels: std::map<Price, PriceLevel> (sorted by price), Faster: Custom array-based book (pre-allocated price levels), Each PriceLevel: std::deque<Order*> (FIFO queue for time priority), Order lookup: std::unordered_map<OrderId, Order*> (O(1) cancels/modifies). Lock-free techniques: Single producer, single consumer queues (SPSC) for inter-thread communication, No locks in critical path (matching logic), Memory barriers and atomics for synchronization, Sequence numbers for ordering (Disruptor pattern). Order processing flow: Inbound order: (1) Receive from network (IO thread), (2) Validate (symbol, price, quantity, client limits), (3) Enqueue to matching engine (SPSC queue), (4) Return to IO thread (continue receiving). Matching engine: (5) Dequeue order (batching: process multiple orders per iteration), (6) Match against book (price-time priority algorithm), (7) Generate fills (create Trade objects), (8) Update order book (remove filled orders, add resting), (9) Send ack to client (order accepted, filled, or rejected), (10) Publish market data (trades, book updates). Market data: (11) Separate thread consumes match results, (12) Generates Level 1 (BBO), Level 2 (full book depth), Level 3 (individual orders), (13) Publishes via multicast or WebSocket. Order types implementation: Market order: Matches immediately against all available liquidity, Walks the book until fully filled or book empty, No resting: Never added to book. Limit order: Matches against contra side if price acceptable (buy limit ≥ ask, sell limit ≤ bid), Unmatched quantity: Add to book at limit price, Time priority: Appended to FIFO queue at price level. IOC (Immediate-or-Cancel): Match what's available immediately, Cancel unfilled portion (don't add to book), Return partial fill + cancel ack. FOK (Fill-or-Kill): Check if entire quantity available before matching, If yes: Execute entire order, If no: Cancel entire order (no partial fills). Stop order: Monitor market: Check each trade or BBO update, Trigger condition: Stop price reached (sell stop: price ≤ stop, buy stop: price ≥ stop), Conversion: Becomes market order when triggered (re-enter matching engine). Concurrency handling: Single symbol, multiple orders: Single thread per symbol: Orders serialized (no concurrent modification), Queue per symbol: Orders wait in SPSC queue, No locks needed: Thread owns symbol's order book exclusively. Multiple symbols: Partition: Each symbol assigned to thread (hash-based or load-balanced), Independent: No cross-symbol locking, Scaling: Add threads as needed (horizontal scalability). Order modifications: Modify = Cancel + Replace: Remove original order from queue (lose time priority), Add new order at end of queue (new timestamp), Alternative: Price-improving modify keeps time priority (exchange-specific rule). Market data distribution: Pub/sub model: Publishers: Matching engine produces events, Subscribers: Market data consumers (clients, internal systems), Channels: Separate channels for Level 1, 2, 3 (clients choose granularity). Multicast for low latency: UDP multicast: Single packet reaches all subscribers (efficient), Sequenced: Messages have sequence numbers (gap detection), Retransmit: TCP retransmit channel for missed packets (reliability). WebSocket for retail: Lower priority: Not latency-critical, Throttled: Limit updates per second (e.g., 10 Hz vs 1000 Hz for multicast), Aggregated: Combine multiple updates (reduce bandwidth). Order book recovery: Persistent event log: Every action logged: Order submissions, matches, cancels, modifications, Sequence number: Each event numbered (detect gaps, replay order), Storage: Append-only log (fast writes, SSD or memory-mapped file). Recovery process: (1) Load last snapshot (order book state at point in time), (2) Replay events from snapshot to current (reconstruct book), (3) Verify: Match final state against checksum, (4) Resume: Start accepting new orders. Snapshots: Periodic: Every N seconds or M orders, Async: Background thread takes snapshot (doesn't block matching), Format: Serialized order book (all orders, all price levels). Self-trade prevention: Definition: Same participant buying and selling (shouldn't match own orders), Detection: Check order owner (client ID, account) before matching, Actions: (a) Cancel resting: Remove own order from book, add incoming, (b) Cancel incoming: Reject new order, keep resting, (c) Cancel both: Remove both orders (most conservative). Implementation: Lookup: Each order tagged with client ID, Match check: if (incoming.client_id == resting.client_id) { prevent_match() }, Configuration: Per client (some want self-trade for legitimate reasons). Tick size constraints: Validation: Ensure price % tick_size == 0 (e.g., $150.01 valid, $150.015 invalid), Rejection: Orders with invalid prices rejected immediately, Rounding: Some systems round to nearest tick (dangerous, prefer reject). Priority inversion prevention: Avoid slow operations in matching thread: No IO: Don't write to disk or network in critical path (delegate to other threads), No locks: Don't wait for other threads, No allocations: Pre-allocate order objects (object pool pattern), No system calls: Stay in user space. Fast path optimization: Inlined functions: Critical matching logic inlined (no function call overhead), Branch prediction: Arrange code for common case (e.g., limit orders more common than market), CPU cache: Keep hot data structures cache-aligned and compact. Performance targets: Latency: Order ack: <100 microseconds (µs) from receipt to ack, Match latency: <50 µs (order to trade), Market data: <20 µs (trade to market data publish). Throughput: 100,000+ orders/sec per symbol, 1,000,000+ orders/sec system-wide (multi-symbol). Fair queuing: FIFO per client: Within same price, clients queued fairly, No starvation: Every client gets turn (round-robin if needed), Rate limiting: Per-client limits (prevent one client overwhelming system). Audit trail: Logging: Every order, every fill, every cancel (compliance, debugging), Timestamp: Microsecond precision (NTP-synchronized clocks), Immutable: Append-only (can't alter history), Indexed: Fast lookup by order ID, client, symbol, time range. Testing: Unit tests: Each order type, matching logic, edge cases (empty book, single order, etc.), Integration tests: Full workflow (submit → match → ack → market data), Performance tests: Measure latency and throughput under load, Chaos tests: Crash recovery, network failures, corrupt messages. Monitoring: Metrics: Order rate, match rate, latency percentiles (p50, p99, p99.9), Alerts: Latency spike, throughput drop, queue buildup, error rate, Dashboards: Real-time view of system health.",
    keyPoints: [
      'Architecture: Single thread per symbol (no locks, deterministic), SPSC queues for inter-thread communication, separate market data publisher thread, lock-free critical path',
      'Data structures: Price levels as std::map<Price, PriceLevel>, FIFO queues (std::deque) for time priority, O(1) order lookup (unordered_map), lock-free atomics for sync',
      'Order flow: IO thread receives → validate → enqueue → matching thread processes → generate fills → update book → ack client → publish market data (separate thread)',
      'Order types: Market (immediate, walk book), Limit (price-time priority), IOC (partial fill + cancel rest), FOK (all-or-nothing), Stop (trigger → market order)',
      'Recovery: Persistent event log (every action sequenced), periodic snapshots, replay from snapshot to current, verify state, self-trade prevention (check client ID before match)',
    ],
  },
  {
    id: 'mmf-q-2',
    question:
      'Build a market making system that: (1) Quotes bid and ask continuously (maintain two-sided market), (2) Adjusts quotes based on inventory (widen when long, tighten when short), (3) Manages adverse selection risk (toxic flow detection), (4) Targets specific spread capture and inventory limits, (5) Handles multiple symbols simultaneously, (6) Integrates with exchange via FIX protocol. Requirements: Sub-millisecond quote updates, inventory-aware pricing (Avellaneda-Stoikov or similar), cancel-replace efficiency (minimize time out of market), PnL tracking (realized and unrealized), position limits, kill switch (stop quoting on anomaly). How do you handle: quote synchronization (ensure bid < ask)? Simultaneous fills on both sides? Inventory risk (overnight positions, stop-outs)? Adverse selection (detect informed flow, widen spread)? Exchange latency (quotes stale before reaching exchange)?',
    sampleAnswer:
      "Market making system design: Core strategy: Objective: Earn bid-ask spread by providing liquidity, Constraints: Inventory limits (max long/short position), Risk limits (VaR, position concentration), Regulatory: Must quote minimum size and maximum spread (on some exchanges). Quote generation: Base quotes: Mid = (best_bid + best_ask) / 2 (current market mid), Bid = Mid - spread/2, Ask = Mid + spread/2, Spread: Function of volatility, inventory, order book state. Inventory adjustment (Avellaneda-Stoikov): Reservation price: r = Mid - γ × inventory (γ = risk aversion parameter), Inventory > 0 (long): Lower reservation price (incentivize selling), Inventory < 0 (short): Raise reservation price (incentivize buying), Quotes: Bid = r - spread/2, Ask = r + spread/2, Effect: When long, bid lower (less aggressive buying) and ask lower (more aggressive selling). Spread widening: Volatility: Higher vol → wider spread (more risk), Spread = base_spread + α × realized_volatility, Order flow toxicity: Detect informed traders (VPIN, order imbalance), If toxic flow detected: Widen spread by 2-5× (protect against adverse selection), Inventory extremes: Near limits → widen aggressively (urgent to reduce position). Implementation: Quote update logic: def generate_quotes(mid: float, inventory: int, vol: float, toxicity: float) -> tuple[float, float]: base_spread = 0.01 (1 cent minimum), vol_spread = vol * 0.5 (volatility component), toxicity_spread = toxicity * 0.05 (adverse selection protection), total_spread = base_spread + vol_spread + toxicity_spread, inventory_adjustment = -0.0001 * inventory (γ parameter), reservation_price = mid + inventory_adjustment, bid = reservation_price - total_spread / 2, ask = reservation_price + total_spread / 2, return round_to_tick(bid), round_to_tick(ask). Quote synchronization: Pre-check: Ensure bid < ask before sending (sanity check), Race condition: Bid and ask sent separately (could cross if market moves), Solution: Send both as single message (FIX multileg order, if supported), Or: Send ask first (safer: can't sell below buy price), then bid after confirmation, Cancel-replace: If market moves, cancel both quotes first, then send new quotes (avoid mid-market crossing). Simultaneous fills: Scenario: Bid and ask both filled (someone hit bid, someone lifted ask simultaneously), Result: Inventory unchanged (bought and sold same quantity), PnL: Captured spread minus fees, Risk: Rare but possible (especially in fast markets). Handling: Track pending orders: Know which quotes are live (not yet confirmed filled/cancelled), Fill notifications: Update inventory immediately upon fill, Recompute quotes: After each fill, recalculate quotes with new inventory. Inventory management: Position limits: Max position: ±1000 shares (per symbol), Soft limit: ±800 shares (start reducing, widen spread away from market), Hard limit: ±1000 shares (stop quoting side that would increase position), Example: Inventory = +850 (long), Action: Stop quoting bid (don't accumulate more), Quote ask aggressively (offload position), Widen ask less than normal (incentivize lifts). Unwinding positions: End-of-day: Target: Return to flat (inventory = 0) before close, Strategy: (1) Widen spread on accumulation side, (2) Narrow spread on offload side, (3) If near close, use market orders (accept worse price), Emergency: If position exceeds hard limit, Market order to reduce (take immediate loss if necessary). Overnight risk: Preferred: Flat overnight (avoid gap risk), Acceptable: Small position within limits, Gap risk: Stock opens significantly different from close (lose money on inventory), Mitigation: Reduce limits before close, hedge with futures/ETFs. Adverse selection detection: VPIN (Volume-Synchronized Probability of Informed Trading): Bucket trades by volume (not time), Classify as buy-initiated or sell-initiated, Calculate imbalance: VPIN = |buy_volume - sell_volume| / total_volume, Threshold: VPIN > 0.7 → toxic flow detected (widen spread or stop quoting). Order flow imbalance: Monitor: Recent trade flow (last 1-5 seconds), Imbalance: If 80%+ trades same direction, likely informed flow, Action: Widen spread on direction of imbalance (e.g., if buying pressure, widen ask more). Fill rate analysis: Normal market making: ~50% fill rate on each side (balanced), Adverse selection: Consistently filled on wrong side (buy then price drops, sell then price rises), Detection: If PnL per fill consistently negative → being adversely selected, Response: Widen spread, reduce quote size, or stop quoting temporarily. FIX protocol integration: Order submission: NewOrderSingle (35=D): Submit new quote (bid or ask), OrderCancelReplaceRequest (35=G): Modify existing quote (faster than cancel + new), OrderCancelRequest (35=F): Cancel quote. Messages: Outbound (to exchange): tag 35=D (new order), tags 11 (ClOrdID), 55 (symbol), 54 (side), 38 (quantity), 40 (order type), 44 (price). Inbound (from exchange): 35=8 (execution report), status: 0=New, 1=Partially filled, 2=Filled, 4=Cancelled, 8=Rejected. Session management: Heartbeat: 35=0 (every 30 seconds, keep connection alive), Logon: 35=A (authenticate), Logout: 35=5 (disconnect gracefully), Sequence numbers: Every message numbered (detect gaps, request retransmit). Exchange latency handling: RTT (round-trip time): Measure: Time from order sent to ack received, Typical: 500 µs - 5 ms (co-located), Higher: 10-50 ms (remote). Stale quotes: Problem: Quote sent at $100.00 / $100.05, by time it reaches exchange, market is $100.10 / $100.15, Risk: Get filled on stale quote (adverse selection), Mitigation: (1) Cancel-replace frequently (every 100-500 ms), (2) Tighten spread (reduce probability of fill on stale quote), (3) Co-locate (reduce latency). Order in flight: Pending: Orders sent but not yet acked (uncertain state), Risk: Send cancel but order already filled, Tracking: Maintain order state machine (Pending → Live → Filled/Cancelled), Don't double-send: If cancel pending, wait for ack before sending new order. Kill switch: Triggers: (1) PnL loss exceeds threshold (e.g., -$10,000 in 1 minute), (2) Position exceeds hard limit, (3) Fill rate anomaly (too many fills in short time), (4) Exchange connection issues (heartbeat missed), (5) Market data stale (no updates for X seconds). Actions: Cancel all orders immediately (35=F for all open orders), Stop sending new quotes, Flatten positions: Market orders to exit (if configured), Alert: Notify risk manager, log incident. Testing: Cancel all: FIX MassOrderCancelRequest (35=q), Failsafe: If no ack within 1 second, disconnect session (forces exchange to cancel all orders). Multi-symbol management: Independent: Each symbol has own strategy instance (inventory, quotes, state), Shared: Risk limits at portfolio level (total VaR, capital usage), Allocation: Distribute capital across symbols (more to liquid, less to illiquid), Prioritization: If capacity limited, focus on most profitable symbols. Correlation risk: Hedging: If long AAPL, short MSFT (both tech, correlated), Netting: Portfolio risk < sum of individual risks (diversification). PnL tracking: Realized PnL: Captured on completed round trips, Example: Buy 100 @ $100.00, Sell 100 @ $100.05 → Realized PnL = $5 (minus fees), Accumulation: Sum over all fills. Unrealized PnL: Current position marked to market, Example: Long 100 @ $100.00, Mark = $100.10 → Unrealized PnL = $10, Updates: Real-time as market moves. Fees: Exchange fees: Maker rebate (e.g., -$0.0020 per share, we get paid), Taker fee (e.g., +$0.0030 per share, we pay), Our PnL: Capture spread minus net fees, Target: Net positive after fees (spread > fee difference). Performance metrics: Sharpe ratio: Risk-adjusted return, Target: >2.0 (excellent), >1.0 (good), Max drawdown: Worst peak-to-trough decline, Target: <5% of capital, Fill ratio: Percentage of time quoted, Target: >90% (always providing liquidity), Adverse selection ratio: % of fills that are adverse, Target: <30% (most fills neutral or favorable). Monitoring: Real-time dashboard: Inventory (per symbol and aggregate), PnL (realized, unrealized, total), Quotes (current bid/ask, spread), Fill rates, Position limits. Alerts: Inventory near limits, PnL drawdown, Adverse selection spike, Exchange connectivity issues.",
    keyPoints: [
      'Quote generation: Avellaneda-Stoikov reservation price r = Mid - γ×inventory, quotes Bid = r - spread/2, Ask = r + spread/2, inventory adjustment (long → lower quotes, short → raise quotes)',
      'Spread: Base + volatility component + toxicity component, widen when VPIN > 0.7 (toxic flow), widen when near inventory limits, tighten when inventory neutral',
      'FIX protocol: NewOrderSingle (35=D), OrderCancelReplaceRequest (35=G), ExecutionReport (35=8), sequence numbers for ordering, cancel-replace every 100-500 ms (refresh quotes)',
      'Adverse selection: Detect via VPIN, order flow imbalance, fill rate analysis, widen spread or stop quoting when detected, co-locate to reduce stale quote risk',
      'Kill switch: Triggers on PnL loss, position limit breach, fill anomaly, cancel all orders (35=F), flatten positions, alert operators, disconnect if needed',
    ],
  },
  {
    id: 'mmf-q-3',
    question:
      "Design a smart order router (SOR) that: (1) Routes orders across multiple venues (NYSE, NASDAQ, BATS, IEX, dark pools), (2) Optimizes for best execution (price, speed, fill rate), (3) Implements Reg NMS compliance (order protection rule, no trade-throughs), (4) Handles routing strategies (sweep, ping, probabilistic), (5) Manages orders across venues (partial fills, cancels, modifications), (6) Provides TCA (transaction cost analysis) and execution reporting. Requirements: Sub-millisecond routing decisions, real-time market data from all venues, fair access (don't always favor one venue), anti-gaming (don't leak information), proper order types per venue (IOC for dark pools, limit for lit). How do you handle: venue latency differences (IEX has speed bump)? Locked markets (bid = ask)? Rebate optimization (maker-taker pricing)? Order protection rule (don't trade through better prices)? Routing to dark pools (information leakage risk)?",
    sampleAnswer:
      "Smart Order Router (SOR) design: Objectives: Best execution: Maximize fill rate, minimize slippage and fees, Reg NMS compliance: Order protection (no trade-through of protected quotes), Speed: Route within microseconds (don't delay order), Fairness: Don't systematically disadvantage any venue. Architecture: Components: Market data aggregator (consolidate NBBO from all venues), Routing engine (decision logic: where to send order), Venue connectors (FIX sessions to each exchange), Order manager (track orders across venues, handle fills/cancels), TCA engine (post-trade analysis: price improvement, effective spread). Data feeds: SIP (Securities Information Processor): Consolidated tape (all exchange quotes/trades), Latency: ~300-500 µs behind direct feeds (too slow for SOR), Direct feeds: Each exchange publishes own quotes (ITCH, PITCH, etc.), Latency: <100 µs (much faster), Required: Must use direct feeds for routing decisions. Venue universe: Lit exchanges: NYSE (price-time priority), NASDAQ (maker-taker rebates), BATS/CBOE (low fees, high rebates), IEX (speed bump: 350 µs delay), NYSE Arca, NYSE American. Dark pools: Broker pools: Goldman Sachs, Morgan Stanley, JP Morgan (midpoint matching), Exchange pools: NYSE Dark, NASDAQ Private, Independent: Liquidnet (institutional), IEX (partially dark). Order protection rule (Reg NMS): Rule 611: Cannot trade through protected quotes (better prices on other venues), Protected quote: Automated, immediately accessible, displayed quote on lit exchange, Example: NASDAQ bid $100.00, NYSE ask $100.05, Cannot: Buy on NYSE at $100.05 if can buy on NASDAQ at $100.00 (trade-through), Must: Route to NASDAQ first (or simultaneously). Compliance: Before routing: Check NBBO (National Best Bid and Offer), Route to best prices: Send orders to venues with best bid (for sells) or ask (for buys), If multiple venues at NBBO: Route proportionally or based on fill probability. Locked/crossed markets: Locked market: Bid = Ask (e.g., NASDAQ bid $100.00, NYSE ask $100.00), Crossed market: Bid > Ask (shouldn't happen, but does briefly), Cause: Latency (different venues, quotes update at different times), Handling: Wait: Brief (1-10 ms) for market to unlock, Sweep: Send IOC orders to both sides (capture arbitrage), Risk: Both fill (now long when wanted to sell, or vice versa). Routing strategies: 1. Sweep (aggressive): Goal: Execute entire order immediately, best available prices, Method: Send IOC orders to all venues simultaneously (at their ask for buy, bid for sell), Start: Best prices first (order protection), Continue: Walk through price levels until filled, Example: Buy 1000 shares, NASDAQ ask 500 @ $100.00, NYSE ask 300 @ $100.00, BATS ask 400 @ $100.01, Route: 500 to NASDAQ @ $100.00, 300 to NYSE @ $100.00, 200 to BATS @ $100.01, Result: Filled 1000 shares at VWAP = $100.002. 2. Ping (test liquidity): Goal: Test dark pools without leaking information, Method: Send small IOC orders to dark pools (e.g., 100 shares), If fill: Dark pool has liquidity, send larger order, If no fill: Try next dark pool, Advantage: Minimize information leakage (only reveal small size), Example: Want to buy 10,000 shares, Ping 100 shares to 5 dark pools, Dark pool A fills 100 → send 5,000 more, Dark pool B no fill → skip. 3. Probabilistic routing: Goal: Route based on historical fill rates, Method: Track fill probability per venue (P_fill[venue, time_of_day, order_size, etc.]), Route to venue with highest expected value: EV[venue] = P_fill[venue] × Price_improvement[venue] - Fees[venue], Example: IEX: 60% fill rate, 0.5 tick improvement, Dark pool: 30% fill rate, 1.0 tick improvement, Calculate: EV_IEX = 0.6 × 0.5 - 0 = 0.30, EV_dark = 0.3 × 1.0 - 0 = 0.30 (tie, use other factors). Venue-specific order types: Lit exchanges: Limit orders: Join book, may sit (provide liquidity, earn rebate), IOC orders: Take liquidity if available immediately (pay fee), Post-only: Only if can be maker (avoid taking, ensure rebate). Dark pools: Midpoint pegs: Price = (NBBO_bid + NBBO_ask) / 2, IOC: Must be IOC (no resting orders in dark pools, by definition), Size discovery: Some dark pools allow size improvement (fill more than displayed). IEX: Speed bump: 350 µs coil delay (intentional latency), Implication: Quotes may be stale by time order arrives, Strategy: Send limit orders (don't take stale quotes), Advantage: Less adverse selection (informed traders can't react to news faster). Latency handling: Measure RTT: Round-trip time to each venue (monitor continuously), Adjust routing: Faster venues get priority (all else equal), Staleness: Discard quotes older than threshold (e.g., 1 ms), Re-route: If venue slow to respond, cancel and route elsewhere. IEX speed bump: Effective delay: 350 µs each direction = 700 µs round-trip (vs <100 µs for others), Trade-off: Slower, but less adverse selection (better fill quality), Use case: Non-urgent orders, larger size (information leakage protection). Rebate optimization: Maker-taker pricing: Maker rebate: $0.0020 per share (credit for providing liquidity), Taker fee: $0.0030 per share (charge for taking liquidity), Net: Spread capture + rebate - fee. Venue economics: BATS: High rebate ($0.0032), Inverted: Taker rebate, maker fee (some symbols), NASDAQ: Standard maker-taker, IEX: No rebates (simplified pricing). Optimization: Post-only orders: Ensure maker rebate (don't cross spread), Venue selection: Route to high-rebate venues if price equal, Balance: Don't sacrifice price for rebate (e.g., $0.01 worse price >> $0.0020 rebate difference). Information leakage: Risk: Dark pool routing reveals intent (large buyer/seller), Detection: Other traders monitor dark pool fills, infer large order, Exploitation: Front-run remaining order (buy ahead, sell higher). Mitigation: Randomization: Don't always route to same dark pool (pattern unpredictable), Size variation: Vary order sizes (don't reveal total size), Time variation: Random delays between orders (don't show urgency), Limit attempts: Don't ping too many dark pools (each ping is information). Order management: Tracking: Maintain state for each child order (sent to each venue), Order ID mapping: Parent order ID → multiple child order IDs, State machine: Pending → Live → Partial fill → Filled / Cancelled. Partial fills: Scenario: Sent 1000 to NASDAQ, filled 600, Send: 400 remaining to next venue (NYSE), Aggregate: Track total filled across all venues. Cancels: User cancels parent order, Action: Send cancel to all venues with live child orders (35=F), Race condition: May fill before cancel arrives (handle gracefully, report actual fill). Modifications: Parent modify: User changes price or quantity, Child actions: Cancel all child orders, Re-route: Send new orders at new parameters. TCA (Transaction Cost Analysis): Arrival price benchmark: Price when order submitted (baseline), Effective price: VWAP of fills (volume-weighted average price), Slippage: Effective price - Arrival price (cost of execution), Components: Market impact (price moved due to our order), Timing cost (market moved while we waited), Spread cost (crossed bid-ask spread), Opportunity cost (unfilled portion if market moved). Reporting: Per order: Show fill details (venue, price, quantity, time, fees), Aggregate: Daily statistics (average slippage, fill rate, venue distribution), Compliance: Reg NMS report (any trade-throughs? protected quotes accessed?). Venue selection logic: def route_order(order, venues, nbbo): best_price = nbbo.ask if order.side == 'BUY' else nbbo.bid, protected_venues = [v for v in venues if v.quote_price == best_price and v.is_lit], if protected_venues: route_to = select_among_protected(protected_venues, order), (based on fill probability, fees, rebates), else: route_to = select_best_venue(venues, order), (consider dark pools, price improvement potential), send_child_order(route_to, order). Monitoring: Metrics: Fill rate (% of order quantity filled), Time to fill (latency from order to complete fill), Price improvement (filled better than NBBO), Venue usage (distribution across venues), Reg NMS violations (trade-throughs, should be 0). Alerts: Trade-through detected (compliance violation), Venue connectivity issue (unable to route), Fill rate drop (execution quality degraded), Latency spike (routing delayed). Testing: Simulation: Replay historical market data, test routing decisions, Compliance: Ensure no trade-throughs in test scenarios, Performance: Measure routing latency, fill rates, Stress: Handle locked markets, fast markets, venue outages.",
    keyPoints: [
      'Reg NMS compliance: Order protection rule (no trade-through), check NBBO before routing, send to best prices first, use direct feeds (SIP too slow), route to all venues at NBBO',
      'Routing strategies: Sweep (IOC to all venues, aggressive), Ping (test dark pools, minimize leakage), Probabilistic (route based on fill probability and expected value)',
      'Venue-specific: Lit exchanges use limit/IOC, dark pools use midpoint pegs + IOC only, IEX has 350 µs speed bump (less adverse selection, slower), handle latency differences',
      "Rebate optimization: Maker-taker pricing, post-only for rebates, venue selection considers fees/rebates, don't sacrifice price for rebate (price > rebate difference)",
      'Information leakage: Randomize dark pool routing, vary order sizes and timing, limit dark pool attempts, track partial fills across venues, cancel-all on parent cancel',
    ],
  },
];
