export const orderBookDynamicsQuiz = [
    {
        id: 'obd-q-1',
        question:
            'Design a real-time order book reconstruction system from NASDAQ ITCH feed that: (1) Processes 1M+ messages per second, (2) Maintains accurate order book state (all price levels, all orders), (3) Publishes Level 1, 2, and 3 snapshots at different frequencies (Level 1: every message, Level 2: 100ms, Level 3: on demand), (4) Handles message gaps and recovery, (5) Provides queue position lookup for any order ID, (6) Detects order book anomalies (crossed market, negative quantities, orphaned orders). Requirements: Lock-free data structures for hot path, zero-copy message parsing, memory-efficient order storage, low-latency snapshot generation, audit trail for all updates. How do you handle: message reordering (out-of-sequence)? Gap fills (missing sequence numbers)? Memory management (millions of orders)? Snapshot consistency (atomic view)? Performance monitoring (latency percentiles)?',
        sampleAnswer:
            'Order book reconstruction: Architecture: Pipeline stages: (1) Message ingestion (network receive, zero-copy), (2) Message parsing (binary decoding), (3) Sequence validation (gap detection), (4) Order book update (state mutation), (5) Snapshot generation (Level 1/2/3), (6) Publication (multicast/WebSocket). Threading: Single thread per symbol (avoid locks, deterministic ordering), Round-robin symbols across threads (load balance), Separate threads for: ingestion (network IO), publication (market data distribution), monitoring (metrics collection). Data structures: Order storage: Hash map: order_id → Order (O(1) lookup for cancels/modifies), Memory pool: Pre-allocated Order objects (avoid malloc in hot path), Intrusive linked list: Orders at same price (cache-friendly, no pointer indirection). Price levels: Tree map: price → PriceLevel (sorted, O(log n) insert/delete), Each PriceLevel: Total quantity (aggregate), Order count (number of orders), Head/tail pointers to order list (FIFO queue). Optimizations: Cache best bid/ask (avoid tree traversal every message), Pre-compute spread (update only when BBO changes), Lazy snapshot generation (only when requested, not every update). Message ingestion: Zero-copy parsing: Memory-map file or use recvmsg (avoid memcpy), Parse directly from network buffer (struct overlay), Validate: Check message type, sequence number, length. Sequence numbers: Every message has sequence number (monotonically increasing), Gap detection: if (msg.seq_num != expected_seq + 1) { gap_detected() }, Recovery: Request retransmit from exchange (via separate TCP channel), Buffer: Hold recent messages for fast local replay. Message processing: Add Order (type A): Parse: order_id, side, price, quantity, timestamp, Create Order object (from memory pool), Insert: orders[order_id] = order, Add to price level: price_levels[price].add_order(order), Update BBO: If new best bid/ask, cache update. Execute Order (type E): Lookup: order = orders[order_id], Reduce quantity: order.quantity -= executed_qty, Update price level: price_levels[order.price].reduce_quantity(executed_qty), Remove if fully filled: if (order.quantity == 0) { delete_order(order_id) }, Generate trade event: Publish separately (trade feed). Cancel Order (type X): Lookup order, reduce quantity (partial cancel) or remove (full cancel), Update price level aggregates. Delete Order (type D): Remove order entirely, clean up price level if empty. Replace Order (type U): Atomic delete + add (treat as two operations), Note: New order gets new timestamp (loses queue priority). Message reordering: Sequence tracking: Maintain expected_seq_num, detect out-of-order (msg.seq_num < expected), Buffer: Hold out-of-order messages in sequence-ordered queue (priority queue by seq_num), Replay: When gap filled, process buffered messages in order. Edge cases: Late message arrives after gap filled (discard duplicate), Out-of-order within TCP packet (parse all, then sort). Gap fills: Detection: expected = 1000, received = 1005 → gap [1001-1004], Request retransmit: Send gap fill request to exchange (TCP), Wait: Continue processing new messages (1005+), don\'t block, Buffer: Queue messages that depend on missing data, Replay: When gap filled, process 1001-1004, then continue. Timeout: If gap not filled within 1 second, alert (data loss), fallback to full snapshot request. Memory management: Object pools: Pre-allocate Order objects (e.g., 10M orders × 64 bytes = 640 MB), Free list: Track unused Order slots (stack of available indices), Reuse: When order deleted, return to free list (avoid malloc/free). Garbage collection: Periodic sweep: Remove stale orders (orphaned, not seen in hours), Compaction: Defragment memory (optional, can cause latency spike). Memory limits: Max orders: 10M cap (prevent unbounded growth), Eviction: LRU eviction if limit reached (unlikely in practice, orders get filled/cancelled). Level 1 snapshot: Best bid/ask: Cache in variables (updated on every BBO change), Publish: Every message update (if BBO changed), ~1M updates/sec, Format: bid_price, bid_size, ask_price, ask_size, mid_price, spread, timestamp, Latency: <1 µs (cache lookup only, no computation). Level 2 snapshot: Top N levels: Iterate top 20 bid and ask levels (from tree map), Frequency: 100 ms (10 Hz), sufficient for most use cases, Throttle: If no changes, don\'t publish (save bandwidth), Format: Array of (price, quantity, num_orders) for each side, Latency: <50 µs (tree traversal for 20 levels). Level 3 snapshot: All orders: Iterate all orders at each price level (millions of orders), Frequency: On demand (too large for regular publish, ~100 MB), Use case: Forensics, research, regulatory reporting, Format: Array of (order_id, price, quantity, timestamp, side), Latency: ~10 ms (millions of orders, serialize to JSON/binary). Snapshot consistency: Atomic view: Snapshot generation must see consistent state (no partial updates), Approach 1: Copy-on-write: Clone entire order book (expensive, ~1 GB), Approach 2: Read lock: Pause updates during snapshot (blocks trading, unacceptable), Approach 3: Sequence-based: Include sequence number in snapshot, reader validates consistency. Best approach: Sequence-tagged snapshots: Snapshot contains: data + sequence_number, Reader: Verify no updates between read_seq_start and read_seq_end, Retry: If updates occurred during read, re-read snapshot (rare, <1% of reads). Anomaly detection: Crossed market: bid > ask (shouldn\'t happen), Detection: After every BBO update, check bid ≤ ask, Alert: Log warning, market data consumers should handle gracefully, Cause: Network lag (different exchanges), bug in book, resolution pending. Negative quantities: price_level.quantity < 0 (bug in logic), Detection: Assert quantity ≥ 0 after every update, Recovery: Re-sync from snapshot (order book corrupted). Orphaned orders: Execute/cancel for order_id not in orders map, Cause: Missed add message (gap not filled), message reorder, Handling: Ignore (log warning), or request full snapshot. Performance monitoring: Latency tracking: Per-message: Timestamp in (network) → timestamp out (book updated), Histogram: p50, p95, p99, p99.9 latencies, Target: p99 < 100 µs, p99.9 < 500 µs, Alert: If p99 > 1 ms (degraded performance). Throughput: Messages per second: Current rate vs capacity (1M msg/s target), CPU usage: Per thread (should be <80% at peak), Memory: Resident set size (should be stable, no leaks). Queue depth: Inbound queue: Messages waiting to be processed (should be near 0), Backlog: If queue depth > 1000, system falling behind (drop messages or scale). Metrics collection: Separate thread: Don\'t block hot path, Sampling: Measure every 1000th message (reduce overhead), Aggregation: Per-second summary stats (mean, p95, p99, max). Testing: Unit tests: Each message type, edge cases (fully filled order, cancel non-existent order), Integration: Replay historical ITCH data (full day, ~100 GB), compare snapshot to reference. Stress test: Inject 2M msg/s (2× normal peak), measure latency degradation, Recovery test: Inject gaps, verify retransmit and replay logic, Memory test: Run for 24 hours, check for leaks (RSS should be stable). Deployment: Co-location: Server at exchange (minimize network latency, <100 µs), Hardware: High-frequency CPU (4+ GHz), large memory (128+ GB for multiple symbols), NIC: Kernel bypass (DPDK) for lowest latency, 10 Gbps or faster.',
        keyPoints: [
            'Architecture: Single thread per symbol (lock-free), memory pool for orders (pre-allocated), hash map for order lookup (O(1)), tree map for price levels (sorted)',
            'Sequence validation: Gap detection (seq_num != expected + 1), request retransmit, buffer out-of-order, replay when gap filled, timeout alert if not filled in 1s',
            'Snapshots: Level 1 (BBO) every update (<1 µs), Level 2 (depth) at 100ms (<50 µs), Level 3 (all orders) on demand (~10ms), sequence-tagged for consistency',
            'Anomaly detection: Crossed market (bid > ask), negative quantities (assert ≥ 0), orphaned orders (execute/cancel without add), log and alert on detection',
            'Performance: p99 latency < 100 µs, 1M+ msg/s throughput, monitor queue depth (near 0), memory stable (no leaks), co-locate at exchange (<100 µs network)',
        ],
    },
    {
        id: 'obd-q-2',
        question:
            'Build an order book imbalance-based trading strategy that: (1) Calculates imbalance from top 5 levels (bid volume - ask volume) / (bid + ask), (2) Generates signals (BUY if imbalance > +0.3, SELL if < -0.3), (3) Manages positions (max ±1000 shares, close at end of day), (4) Measures signal predictiveness (future price change correlation), (5) Optimizes imbalance window (1-level vs 5-level vs 10-level imbalance), (6) Handles signal latency (imbalance calculated at T, order submitted at T+100µs). Requirements: Real-time imbalance calculation, position sizing (scale by imbalance strength), stop-loss (exit if adverse move > 0.1%), PnL attribution, backtesting framework. How do you handle: False signals (mean reversion after imbalance)? Imbalance persistence (how long does signal last)? Market impact (your order affects imbalance)? Signal decay (older imbalance less predictive)? Transaction costs (spread, fees)?',
        sampleAnswer:
            'Imbalance trading strategy: Signal generation: Imbalance formula: I = (B - A) / (B + A), where B = sum of bid quantities (top N levels), A = sum of ask quantities, Range: [-1, +1], positive = bid pressure, negative = ask pressure. Depth selection: Test: 1-level (BBO only), 5-level, 10-level, 20-level, Finding: 5-level optimal (captures pressure without too much noise), Reason: Top 5 levels contain most actionable liquidity, deeper levels less predictive. Weighted imbalance: Standard: Equal weight to all levels, Weighted: Levels closer to mid get higher weight (more relevant), Formula: I_w = sum(w_i × q_i) / sum(w_i × q_i), where w_i = 1 / (1 + distance_from_mid). Implementation: def calculate_imbalance(book, depth=5): bid_qty = book.get_total_volume(\'bid\', depth), ask_qty = book.get_total_volume(\'ask\', depth), total = bid_qty + ask_qty, return (bid_qty - ask_qty) / total if total > 0 else 0. Signal thresholds: Entry long: imbalance > +0.3 (30% bid pressure), Entry short: imbalance < -0.3 (30% ask pressure), Neutral: -0.3 ≤ imbalance ≤ +0.3 (balanced), Optimization: Backtest different thresholds (0.2, 0.3, 0.4, 0.5), find best risk-adjusted return. Position management: Max position: ±1000 shares (risk limit), Scaling: Position size = sign(imbalance) × min(abs(imbalance) × 2000, 1000), Example: Imbalance +0.4 → position +800 shares (0.4 × 2000, capped at 1000), Imbalance +0.6 → position +1000 (capped), Imbalance -0.5 → position -1000 (short). Entry logic: if imbalance > 0.3 and position < max_long: buy_qty = min(target_position - current_position, 100 shares per order), send_limit_order(side=BUY, price=ask - tick, qty=buy_qty), (join ask, don\'t cross spread). Exit logic: Stop-loss: If adverse move > 0.1% from entry, exit immediately (market order), Time-based: Close all positions at 3:59 PM (avoid overnight risk), Signal reversal: If imbalance flips sign, close and reverse (e.g., +0.4 → -0.3). Signal predictiveness: Hypothesis: Imbalance at time T predicts price change from T to T+Δt, Measurement: Correlation(imbalance_T, price_change_T→T+Δt), Time windows: Δt = 100ms, 500ms, 1s, 5s, 10s, Finding: Strongest correlation at 500ms to 2s (short-term predictive), Decay: Correlation drops significantly after 5s (signal stale). Statistical significance: T-test: Is correlation significantly > 0? (p-value < 0.05), Sample size: Need 1000+ observations (full trading day), Result: p-value = 0.001 (highly significant, 99.9% confidence). Backtest: Historical data: Order book snapshots every 100ms (full depth), Replay: Calculate imbalance, generate signals, simulate orders, Metrics: Sharpe ratio, win rate, max drawdown, PnL per trade. False signals (mean reversion): Problem: Imbalance may be temporary (large order fills, then reverts), Detection: Measure imbalance persistence (does it stay high for >1 second?), Filter: Only trade if imbalance persists for 2 consecutive snapshots (200ms), Example: T=0: imbalance +0.4 (candidate signal), T=100ms: imbalance +0.3 (still high, confirm signal), T=200ms: Enter trade. Mean reversion: If imbalance > 0.5 (extreme), expect reversion (fade the signal), Extreme threshold: ±0.6 or higher (rare, likely anomaly). Imbalance persistence: Measurement: Autocorrelation of imbalance series, Result: Lag 1 (100ms): ρ = 0.6 (moderate persistence), Lag 5 (500ms): ρ = 0.3 (decaying), Lag 10 (1s): ρ = 0.1 (mostly random). Trading implication: Signal lifetime: ~500ms to 1s (act quickly), Holding period: Exit within 1-2 seconds if no follow-through, Re-evaluate: Update imbalance every 100ms, adjust position accordingly. Market impact: Your order: Adds to bid/ask, changes imbalance (feedback loop), Example: Imbalance +0.3 → buy 500 shares → adds to bid → imbalance now +0.25 (diluted), Mitigation: Limit order size (max 100 shares per order, accumulate over time), Use IOC orders (don\'t rest in book, reduce feedback), Measure: Post-trade imbalance (did your order move it significantly?). Self-fulfilling: If many traders use same imbalance signal, Collective buying → imbalance increases further → more buying (cascade), Risk: Strategy becomes crowded (lower returns), herding. Signal latency: Order book snapshot: Captured at time T, Processing: Imbalance calculated at T + 50µs, Order submission: Sent at T + 100µs (network latency), Exchange: Order arrives at T + 200µs (co-location), Risk: Order book changed during latency (stale signal). Latency impact: 100µs delay: Minimal (order book stable at microsecond scale in liquid stocks), 1ms delay: Moderate (some signal decay), 10ms delay: Significant (signal may have reversed), Target: Minimize latency (<500µs from snapshot to order arrival). Transaction costs: Spread cost: If cross spread, pay 1 tick ($0.01 for stocks >$1), Avoidance: Use limit orders at mid or join best bid/ask (don\'t cross), Maker rebates: Some exchanges pay $0.0020 per share for providing liquidity (post-only orders). Commission: $0.0010 per share (typical), Roundtrip: Buy + sell = $0.0020 per share, Breakeven: Need >0.0020/share price move to profit (e.g., 0.002% for $100 stock). Cost modeling: Net PnL: Gross PnL - spread costs - commissions - fees, Example trade: Buy 100 @ $100.00, sell 100 @ $100.05 (5 cent profit), Gross: $5.00, Spread: $1.00 (crossed spread twice), Commission: $0.20 ($0.001 × 100 × 2), Net: $3.80 (76% of gross). Optimization: Threshold tuning: Higher threshold (+0.4) → fewer trades, higher win rate, Lower threshold (+0.2) → more trades, lower win rate, Sharpe-optimal: Find threshold maximizing risk-adjusted return. Depth optimization: Test: 1-level, 3-level, 5-level, 10-level, 20-level imbalance, Result: 5-level best (captures pressure, not too noisy), Explanation: Top 5 levels = ~80% of total liquidity, deeper levels less informative. Hold time: Optimal: Exit within 1-2 seconds (signal decays), Longer holds: Mean reversion dominates (negative alpha), Shorter holds: Too fast (noise dominates signal). PnL attribution: Breakdown: Signal PnL: Profit from imbalance prediction, Transaction costs: Spread, commission, fees, Timing cost: Price moved while waiting to fill, Slippage: Worse fill than expected price. Per trade analysis: Expected: Signal predicts +$0.05 move (based on imbalance), Actual: Filled at +$0.04 (slippage), Costs: -$0.01 spread, -$0.002 commission, Net: +$0.028 per share. Aggregate: Daily PnL: Sum of all trades (should be positive), Win rate: % of trades profitable (target: >55%), Sharpe ratio: Daily PnL / std dev (target: >2.0 annualized). Backtesting framework: Data: Historical order book snapshots (100ms frequency, full depth), Simulation: Replay order book, calculate imbalance, generate signals, Execution: Assume fill at limit price (optimistic) or mid (realistic), Costs: Deduct spread, commission, fees, Metrics: Sharpe, max drawdown, win rate, PnL per trade. Validation: Out-of-sample: Train on 2022, test on 2023 (avoid overfitting), Walk-forward: Rolling window (optimize on 3 months, test on 1 month), Robustness: Test across stocks (large-cap, small-cap), days (high vol, low vol). Risk management: Position limits: Max ±1000 shares (prevent outsized loss), Stop-loss: Exit if -0.1% (10 bps) adverse move (tight risk control), Daily loss limit: Stop trading if -$500 (circuit breaker), Diversification: Trade multiple stocks (reduce single-stock risk). Monitoring: Real-time: Track imbalance, position, PnL, Alerts: Position limit, stop-loss hit, signal latency spike, Post-trade: Review attribution (why trade won/lost), PnL by hour, stock.',
        keyPoints: [
            'Imbalance: I = (bid_qty - ask_qty) / (bid + ask) from top 5 levels, thresholds +0.3 (buy) / -0.3 (sell), position size = imbalance × 2000 (capped at ±1000)',
            'Signal predictiveness: Correlation at 500ms-2s (strongest), decays after 5s, autocorrelation lag 1 = 0.6 (moderate persistence), filter for 2 consecutive snapshots (200ms)',
            'Market impact: Your order changes imbalance (feedback), limit order size (max 100 shares), use IOC (don\'t rest), measure post-trade imbalance (feedback detection)',
            'Transaction costs: Spread ($0.01), commission ($0.001/share), net PnL = gross - costs, use limit orders at mid (avoid crossing), maker rebates where available',
            'Backtesting: Historical snapshots (100ms), simulate fills at mid, deduct costs, optimize threshold (Sharpe-optimal), validate out-of-sample (train 2022, test 2023)',
        ],
    },
    {
        id: 'obd-q-3',
        question:
            'Design a queue position tracking system that: (1) Reconstructs Level 3 order book from exchange feed (all individual orders), (2) Tracks queue position for your orders (position in FIFO queue at price level), (3) Estimates fill probability based on queue position and historical data, (4) Provides queue-jump detection (your order moved back in queue, indicates order ahead cancelled), (5) Calculates expected fill time (based on trade rate at price level), (6) Optimizes order placement (which price level maximizes fill probability while minimizing adverse price). Requirements: Sub-millisecond queue position updates, handle cancel-replace (lose priority), detect hidden orders (iceberg orders), predict fill before it happens. How do you handle: Queue inference (exchange doesn\'t publish queue explicitly)? Time priority (orders at same price, same millisecond)? Pro-rata matching (CME futures, affects queue position)? Exchange outages (gap fills, recover queue state)? Fair queuing (some exchanges have complex priority rules)?',
        sampleAnswer:
            'Queue position tracking: Level 3 reconstruction: Data source: Exchange feed with individual order messages (NASDAQ ITCH, CME MDP), Messages: Add order (new order), Execute (fill), Cancel (remove), Replace (modify), Rebuild: Maintain hash map (order_id → Order), orders at each price level in FIFO queue. Queue structure: Per price level: Linked list of orders (insertion order = FIFO), Your order: Track position in list (number of orders ahead), Queue ahead: Sum quantities of all orders before yours, Queue behind: Sum quantities after yours (less relevant). Time priority: FIFO: Orders at same price sorted by timestamp, Nanosecond precision: Exchange timestamp (capture time), microsecond in practice, Same millisecond: Rare, but possible (exchange assigns sequence), Tie-breaking: Exchange sequence number (monotonic), then timestamp. Queue position calculation: Add order: Your order appended to end of queue at price level, Position: Count orders already at that price (you\'re last), Initial queue: If 5 orders ahead totaling 2000 shares, your position = 6, queue_ahead = 2000. Cancel ahead: Order ahead of you cancelled, your position improves: position -= 1, queue_ahead -= cancelled_qty, Update: Immediately upon cancel message. Execute ahead: Order ahead partially filled, queue_ahead -= executed_qty, position unchanged (you\'re still #6), but closer to front in volume terms. Implementation: class QueueTracker: def __init__(self): self.orders = {} (order_id → Order), self.price_levels = {} (price → LinkedList[Order]), def add_order(order_id, price, qty, timestamp): order = Order(order_id, price, qty, timestamp), self.orders[order_id] = order, self.price_levels[price].append(order), def get_position(order_id): order = self.orders[order_id], queue = self.price_levels[order.price], position = queue.index(order) + 1, (1-indexed), queue_ahead = sum(o.qty for o in queue[:position-1]), return (position, queue_ahead). Fill probability estimation: Historical data: For each price level, track: Order arrival rate (orders/second), Fill rate (shares filled/second), Time to fill distribution (histogram). Logistic regression: P(fill | queue_position, queue_ahead, spread, volatility), Features: queue_position (normalized), queue_ahead (volume ahead in shares), spread (wider = less likely to fill), volatility (higher = more trades, higher fill probability). Survival analysis: Kaplan-Meier: Estimate time-to-fill survival curve, Cox proportional hazards: Model fill probability over time, Hazard rate: λ(t | X) = λ0(t) × exp(β × X), where X = [queue_position, spread, ...]. Expected fill time: E[T] = queue_ahead / fill_rate, Example: Queue ahead = 1000 shares, Historical fill rate = 100 shares/second at this price, Expected fill time = 10 seconds, Confidence interval: Use historical std dev (±5 seconds, 95% CI). Queue-jump detection: Expected behavior: Your position improves only when orders ahead cancel/fill, Unexpected: Position worsens (jumped back), someone ahead of you was inserted, Causes: (1) Hidden order revealed (iceberg order, shows more quantity), (2) Exchange error (rare), (3) Missed message (gap in feed). Detection: Track position changes: if position increases (worse) without your action → queue jump, Alert: Log anomaly, may indicate hidden order or data issue, Recovery: Request Level 3 snapshot from exchange (verify actual queue). Hidden orders (icebergs): Problem: Order shows 100 shares, but has 1000 shares hidden (only 100 visible at a time), Impact: You think you\'re #5 in queue, but actually #10 (hidden orders ahead), Detection: After 100 shares filled, another 100 appears at same price (likely iceberg), Estimation: If order repeatedly "refreshes" at same price, assume iceberg (total quantity unknown). Handling: Conservative estimate: Assume 2-3× visible quantity is actual (hidden), Fill probability: Reduce estimate (iceberg orders take longer to fill, you\'re further back). Cancel-replace priority loss: Modify order: Price or quantity change requires cancel + re-add, Priority loss: New order goes to back of queue (loses time priority), Example: You\'re #3 in queue, modify price → now #15 (everyone else jumped ahead), Strategy: Avoid cancel-replace unless necessary (price move forces it). Alternatives: Partial cancel: Cancel portion, keep rest (maintains priority for remaining), New order: Submit additional order at new price (keep original), Price improving: Some exchanges preserve priority if modify improves price (better for market). Pro-rata matching (CME futures): Price-time: Standard (FIFO), used by most equity exchanges, Pro-rata: Fills distributed proportionally to order size, used by CME some products, Impact: Larger orders get more fills (not strictly FIFO). Queue position in pro-rata: Position less meaningful: Not #1, #2, #3, but "20% of pool", Your share: your_qty / total_qty_at_level, Expected fill: your_share × incoming_market_order_qty. Example: Price level $100: You: 500 shares, Total at level: 2000 shares (including yours), Your share: 500 / 2000 = 25%, Incoming market order: 400 shares to buy, Your fill: 25% × 400 = 100 shares, Others fill: Remaining 300 distributed proportionally. Hybrid models: FIFO + pro-rata: Some exchanges (e.g., CME) use hybrid, First: Top of book (best price) uses FIFO (first 100 shares), Then: Pro-rata for remaining (split among all), Complexity: Need to model both components. Exchange outages / gap fills: Gap detection: Sequence numbers miss (e.g., 1000, 1001, 1005 → gap [1002-1004]), Impact: Order book state unknown (missed adds/cancels), Queue position: Uncertain (can\'t trust without gap-fill). Recovery: Request retransmit: Exchange sends missed messages (via TCP), Replay: Process 1002-1004 in order, rebuild queue, Snapshot: If gap too large (>10 seconds), request full Level 3 snapshot (expensive, slow). Queue re-synchronization: After gap fill: Recalculate all queue positions (your orders may have moved), Verification: Compare to expected (detect anomalies), Alert: If position changed dramatically (jumped >10 positions), investigate. Fair queuing (complex priority): Some exchanges: Not simple FIFO, e.g., "hidden order priority" (hidden orders get priority over displayed), Example (Tokyo Stock Exchange): Market orders > limit orders at same price (priority), Pro-rata + time hybrid: Large orders get minimum fill, rest FIFO. Modeling: Exchange-specific: Need to understand each exchange\'s rules (read documentation), Simulation: Replay historical data, verify your model matches actual fills, Calibration: Adjust model parameters to fit observed behavior. Order placement optimization: Goal: Maximize fill probability while minimizing adverse price, Trade-off: Join best bid (high fill probability, but may overpay), Limit below best (lower fill probability, but better price if filled). Expected value: EV = P(fill) × (expected_profit) - (1 - P(fill)) × opportunity_cost, Optimization: Grid search over price levels (best bid, best bid - 1 tick, -2 ticks, ...), Choose: Price with highest EV. Queue position impact: Best bid: Your queue position likely far back (many orders already there), Best bid - 1 tick: Fewer orders, better position, higher fill probability (if price comes to you), Best bid + 1 tick (aggressor): Immediate fill, but cross spread (pay more). Strategy: If urgent: Best bid + 1 tick (aggressor, immediate), If patient: Best bid - 1 or -2 ticks (better price, wait for fill), Dynamic: Adjust as queue position changes (cancel-replace if queue too long). Historical analysis: Per price level: Track average time-to-fill, fill probability by queue position, Regression: P(fill | position, time_elapsed, market_conditions), Optimal placement: Price level with best fill probability / cost ratio. Monitoring: Real-time dashboard: Queue position for all your orders, Expected fill time (countdown), Fill probability (percentage), Queue ahead (volume), Alerts: Queue position worsened (queue jump), Expected fill time > threshold (re-evaluate price), Order filled (notification). Post-trade analysis: Actual fill time vs expected (model calibration), Queue position when filled (was estimate accurate?), Adverse selection: Filled quickly = price about to move against you?, Slow fill: Price moved away, didn\'t fill (opportunity cost).',
        keyPoints: [
            'Queue tracking: Level 3 reconstruction (all orders), linked list per price level (FIFO), position = count ahead + 1, queue_ahead = sum quantities, update on cancel/execute',
            'Fill probability: Historical fill rate (shares/second), logistic regression P(fill | position, spread, volatility), expected time = queue_ahead / fill_rate, survival analysis (Kaplan-Meier)',
            'Queue-jump: Position worsens without your action (someone jumped ahead), causes: iceberg (hidden order), exchange error, missed message, detect and alert, request snapshot to verify',
            'Pro-rata matching: Fills proportional to size (CME futures), your_share = your_qty / total_qty, expected fill = your_share × incoming_order, hybrid (FIFO + pro-rata) on some exchanges',
            'Optimization: Expected value = P(fill) × profit - (1-P(fill)) × opportunity_cost, trade-off (best bid = high P(fill) but far back, best-1 tick = better position), dynamic adjustment',
        ],
    },
];

