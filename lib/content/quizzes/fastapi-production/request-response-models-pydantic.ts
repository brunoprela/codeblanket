export const requestResponseModelsPydanticQuiz = [
  {
    id: 'fastapi-pydantic-q-1',
    question:
      'Design a comprehensive Pydantic model for an e-commerce order system. Include: (1) nested models for customer, shipping address, billing address, and line items, (2) validation rules for each field (email, phone, amounts, quantities), (3) custom validators for business rules (order total must match line items, shipping address required for physical products), (4) how to handle optional fields and defaults, (5) how to serialize this for API responses while excluding sensitive data. Provide complete code examples.',
    sampleAnswer:
      'E-commerce order Pydantic model design: (1) Nested models structure: class Address(BaseModel): street: str = Field(min_length=5); city: str; state: str = Field(regex="^[A-Z]{2}$"); zip_code: str = Field(regex=r"^\d{5}$"); country: str = "USA". class Customer(BaseModel): id: int; name: str = Field(min_length=2, max_length=100); email: EmailStr; phone: str = Field(regex=r"^\+?1?\d{10,14}$"). class LineItem(BaseModel): product_id: int = Field(gt=0); product_name: str; quantity: int = Field(gt=0, le=1000); unit_price: Decimal = Field(gt=0, decimal_places=2); is_physical: bool = True; @property def total(self) → Decimal: return self.quantity * self.unit_price. class Order(BaseModel): id: int; customer: Customer; line_items: List[LineItem] = Field(min_items=1); shipping_address: Optional[Address] = None; billing_address: Address; subtotal: Decimal; tax: Decimal = Field(ge=0); shipping_cost: Decimal = Field(ge=0); total: Decimal; payment_method: str; created_at: datetime = Field(default_factory=datetime.utcnow). (2) Validation rules: EmailStr validates email format, phone regex validates international format, Decimal with decimal_places=2 for money (avoids float precision issues), Field constraints: gt (greater than), le (less than or equal), min_items for lists, regex for state/zip. (3) Custom validators: @root_validator def validate_totals(cls, values): line_items = values.get("line_items", []); subtotal = sum(item.quantity * item.unit_price for item in line_items); if subtotal != values.get("subtotal"): raise ValueError(f"Subtotal mismatch: {subtotal} != {values.get(\'subtotal\')}"); expected_total = subtotal + values.get("tax", 0) + values.get("shipping_cost", 0); if abs(expected_total - values.get("total", 0)) > Decimal("0.01"): raise ValueError("Total calculation incorrect"); return values. @root_validator def validate_shipping_address(cls, values): line_items = values.get("line_items", []); has_physical = any(item.is_physical for item in line_items); if has_physical and not values.get("shipping_address"): raise ValueError("Shipping address required for physical products"); return values. (4) Optional fields & defaults: Use Optional[Type] = None for truly optional fields (shipping_address if digital products only), use Type = default_value for optional with default (country = "USA"), use Field(default_factory=func) for dynamic defaults (created_at = datetime.utcnow), None vs default: None means explicitly optional, default means "use this if not provided". (5) Serialization for API: Create separate response models: class OrderResponse(BaseModel): id: int; customer_name: str; customer_email: EmailStr; line_items: List[LineItemResponse]; shipping_address: Optional[Address]; total: Decimal; created_at: datetime; class Config: orm_mode = True. Excludes: customer ID (privacy), billing address (sensitive), payment method (PCI compliance), internal fields. Use response_model in endpoint: @app.post("/orders", response_model=OrderResponse) async def create_order(order: Order): saves to DB; return order → FastAPI filters to OrderResponse fields only. Alternative: response_model_exclude: @app.get("/orders/{id}", response_model=Order, response_model_exclude={"customer.id", "billing_address", "payment_method"}). Production considerations: Use Decimal for money (not float), validate business rules at model level, separate create/update/response models, use orm_mode for SQLAlchemy integration, test all validators thoroughly, document validation rules in Config.schema_extra for API docs.',
    keyPoints: [
      'Nested models: Address, Customer, LineItem with field constraints and regex validation',
      'Custom validators: @root_validator for business rules (totals, shipping requirements)',
      'Optional fields: Optional[Type] for nullable, Field(default=) for defaults, dynamic defaults with default_factory',
      'Serialization: Separate response models exclude sensitive data (payment_method, full billing)',
      'Production: Use Decimal for money, validate business rules, test validators, document in schema_extra',
    ],
  },
  {
    id: 'fastapi-pydantic-q-2',
    question:
      "Explain Pydantic validation performance and optimization strategies. Discuss: (1) Pydantic v2 architecture and why it's 5-17x faster, (2) performance implications of different field types (int vs EmailStr vs custom validators), (3) when to use custom validators vs built-in constraints, (4) how to profile and optimize validation in high-throughput APIs (100K+ req/min), (5) trade-offs between validation thoroughness and performance. Include benchmarks and optimization techniques.",
    sampleAnswer:
      'Pydantic performance deep dive: (1) Pydantic v2 architecture: Core rewrite in Rust (pydantic-core library), replaces pure Python validators. Rust benefits: compiled, no GIL, memory efficient, vectorized operations. Python layer remains for API, Rust handles hot path (validation, serialization). Benchmark: v1 validates 10K simple models in ~300ms, v2 in ~50ms (6x faster). Complex models: 5-17x improvement. Reason: Rust eliminates Python interpreter overhead, function call overhead, memory allocation overhead. (2) Field type performance: Simple types (fastest): int: ~50ns per field, str: ~100ns, bool: ~30ns, float: ~60ns. Built-in constraints (fast): Field(ge=0, le=100): adds ~50ns, regex="^[A-Z]+$": ~500ns (compiled once). Special types (slower): EmailStr: ~5μs (complex regex), HttpUrl: ~10μs (URL parsing), datetime parsing: ~2μs. Custom validators (variable): Simple check: ~200ns, Complex logic: 1-100μs. Nested models: Add cost per nesting level (~1μs per level). Example: Simple model (id: int, name: str, age: int) = ~300ns total, Complex model (email: EmailStr, url: HttpUrl, custom validators) = ~50μs total. 166x difference! (3) Custom validators vs built-in: Use built-in when possible: Field(ge=0) instead of @validator checking >= 0 (10x faster), regex instead of custom string parsing (5x faster), conint, confloat for numeric constraints. Use custom validators when: Business logic required (not just validation), Cross-field validation, External data validation (database lookup), Complex algorithms. Example optimization: Bad: @validator("age") def check_age(cls, v): if v < 0 or v > 120: raise ValueError("Invalid age"); return v (200ns overhead). Good: age: int = Field(ge=0, le=120) (50ns overhead, 4x faster). (4) Optimizing high-throughput APIs: Profile first: from time import perf_counter; start = perf_counter(); model = MyModel(**data); print(f"Validation: {(perf_counter() - start) * 1000:.3f}ms"). Identify bottlenecks: Use FastAPI built-in performance middleware, profile with py-spy or austin, check slow validators. Optimization techniques: (a) Simplify field types: email: str instead of email: EmailStr if you trust source or validate elsewhere, (b) Batch validation: validate list of items, not individual items in loop, (c) Model reuse: create model class once, reuse for all requests (FastAPI does this automatically), (d) Skip validation for internal calls: use .construct() to bypass validation for trusted data: user = User.construct(**trusted_data) # No validation, (e) Use model_validator for expensive operations: @model_validator(mode="after") def validate_expensive(self): if self.needs_expensive_check: # Only run when needed, (f) Cache compiled validators: Pydantic does this, but ensure models aren\'t recreated per request, (g) Parallel validation: For bulk operations, use ProcessPoolExecutor for CPU-bound validation. Benchmark results (100K req/min): Simple model (3 fields, basic types): ~0.05ms per request = 20K req/s per core → 5 cores = 100K req/s, Complex model (10 fields, EmailStr, custom validators): ~0.5ms per request = 2K req/s per core → 50 cores needed!, Optimized complex model (simplified types, built-in validators): ~0.1ms = 10K req/s per core → 10 cores = 100K req/s. 5x improvement through optimization. (5) Validation thoroughness vs performance: Trade-offs: Strict validation: EmailStr, phone regex, custom business rules → Slower but prevents bad data, Lenient validation: Basic types, minimal checks → Faster but may allow bad data. Production strategy: Validate at entry points: External APIs (public endpoints) → Strict validation, Internal services (trusted) → Lenient validation, Use two-stage validation: Basic validation (fast, always) → Type checks, required fields, Advanced validation (slow, conditional) → Business rules, external lookups. Example: class UserCreate(BaseModel): email: str # Fast, basic check; @validator("email") def simple_email_check(cls, v): if "@" not in v: raise ValueError("Invalid email"); return v. # Skip EmailStr (5μs) for simple check (200ns), 25x faster. Then in business logic: Async validate email uniqueness (database), Send verification email (confirms validity). This moves expensive validation out of request path. Real-world impact: Optimized Pydantic validation: 0.1-1ms per request (negligible), Unoptimized: 10-50ms per request (significant at scale). At 100K req/min: 1ms validation = 100K * 1ms = 100s CPU time per minute = 2 cores, 10ms validation = 1000s CPU time per minute = 17 cores!, Optimization can reduce infrastructure cost by 10x.',
    keyPoints: [
      'Pydantic v2: Rust-based core, 5-17x faster, eliminates Python interpreter overhead',
      'Field performance: int/str (50-100ns) << EmailStr (5μs) << custom validators (1-100μs)',
      'Optimize: Use built-in constraints (10x faster), skip validation for trusted data, batch processing',
      'High-throughput: Profile first, simplify types, 0.1-1ms validation target for 100K req/min',
      'Trade-offs: Strict validation at entry (public APIs), lenient internally, two-stage validation',
    ],
  },
  {
    id: 'fastapi-pydantic-q-3',
    question:
      'Design a Pydantic model strategy for versioned APIs with backward compatibility. Address: (1) how to handle API v1, v2, v3 with different field requirements, (2) deprecating fields without breaking clients, (3) adding new required fields while supporting old clients, (4) using Union types for flexibility, (5) testing compatibility across versions. Include migration strategies and real-world examples.',
    sampleAnswer:
      'Versioned API Pydantic strategy: (1) Handling multiple API versions: Approach A: Separate models per version: app/schemas/v1/user.py: class UserV1(BaseModel): id: int; name: str; email: str. app/schemas/v2/user.py: class UserV2(BaseModel): id: int; first_name: str; last_name: str; email: EmailStr; phone: Optional[str]. app/schemas/v3/user.py: class UserV3(BaseModel): id: int; first_name: str; last_name: str; email: EmailStr; phone: str; country_code: str. Pros: Clear separation, independent evolution, no mixing logic. Cons: Code duplication, harder to share logic. Approach B: Shared base with extensions: class UserBase(BaseModel): id: int; email: str. class UserV1(UserBase): name: str. class UserV2(UserBase): first_name: str; last_name: str; phone: Optional[str]. class UserV3(UserV2): phone: str # Required in v3; country_code: str. Pros: DRY, shared validation. Cons: Inheritance complexity. Approach C (recommended): Base + version-specific fields: class UserBase(BaseModel): id: int; email: EmailStr. class UserCreateV1(UserBase): name: str. class UserCreateV2(UserBase): first_name: str; last_name: str; phone: Optional[str] = None. class UserCreateV3(UserBase): first_name: str; last_name: str; phone: str; country_code: str = "+1". Route versioning: @app.post("/v1/users", response_model=UserResponseV1) async def create_user_v1(user: UserCreateV1); @app.post("/v2/users", response_model=UserResponseV2) async def create_user_v2(user: UserCreateV2); @app.post("/v3/users", response_model=UserResponseV3) async def create_user_v3(user: UserCreateV3). (2) Deprecating fields without breaking: Mark as deprecated in docs but keep functional: class UserV2(BaseModel): first_name: str; last_name: str; name: Optional[str] = Field(None, deprecated=True, description="Deprecated: use first_name/last_name"); @validator("name", always=True) def migrate_name(cls, v, values): # If old clients send "name", split to first_name/last_name; if v and not values.get("first_name"): parts = v.split(); values["first_name"] = parts[0]; values["last_name"] = " ".join(parts[1:]) if len(parts) > 1 else ""; return None # Don\'t store deprecated field; return v. OpenAPI shows "deprecated: true" in docs. Alternatively: Accept both, log warnings for deprecated usage: @validator("name") def warn_deprecated(cls, v): if v: logger.warning("Field \'name\' is deprecated, use first_name/last_name"); return v. (3) Adding required fields with backward compat: Option 1: Make new field optional with default: class UserV3(BaseModel): # ... existing fields; country_code: str = "+1" # Required in v3, but has default; # Old clients can omit, new clients must provide explicitly. Option 2: Different endpoints for different versions: v2 endpoint accepts old schema (no country_code), v3 endpoint requires country_code. Option 3: Runtime defaults based on version header: @app.post("/users") async def create_user(user: Union[UserV2, UserV3], version: str = Header("v3")): if version == "v2": if not user.country_code: user.country_code = "+1" # Default for v2 clients; # Process user. (4) Union types for flexibility: Accept multiple versions in single endpoint: @app.post("/users") async def create_user(user: Union[UserCreateV1, UserCreateV2, UserCreateV3]): if isinstance(user, UserCreateV1): # Handle v1 format (name → first_name/last_name); elif isinstance(user, UserCreateV2): # Handle v2 format; elif isinstance(user, UserCreateV3): # Handle v3 format; # Save to database with normalized format. Pros: Single endpoint, flexible. Cons: Complex logic, harder to deprecate old versions. Discriminated unions for clarity: class UserCreateV1(BaseModel): version: Literal["v1"] = "v1"; name: str. class UserCreateV2(BaseModel): version: Literal["v2"] = "v2"; first_name: str; last_name: str. UserCreate = Union[UserCreateV1, UserCreateV2]; @app.post("/users") async def create_user(user: UserCreate): match user.version: case "v1": # Handle v1; case "v2": # Handle v2. Pydantic automatically selects correct model based on "version" field (discriminator). (5) Testing compatibility: Compatibility test suite: def test_v1_client_creates_user(): client = TestClient(app); response = client.post("/v1/users", json={"name": "Alice Johnson", "email": "alice@example.com"}); assert response.status_code == 200; assert "first_name" in response.json() # Check v1 → v2 migration. def test_v2_client_with_v3_endpoint(): # Ensure v2 clients can still use v3 endpoint with defaults; client = TestClient(app); response = client.post("/v3/users", json={"first_name": "Bob", "last_name": "Smith", "email": "bob@example.com"}); # Omit phone and country_code; assert response.status_code == 200 # Should work with defaults. def test_deprecated_field_warning(caplog): # Ensure deprecated fields log warnings; user = UserV2(name="Charlie", email="charlie@example.com"); assert "deprecated" in caplog.text.lower(). Migration strategy: Phase 1: Add v2 endpoint alongside v1, v1 remains fully functional, announce v1 deprecation with sunset date (6-12 months). Phase 2: Log v1 usage, monitor adoption, send notifications to clients still using v1. Phase 3: v1 returns 410 Gone with message: "API v1 is deprecated. Please upgrade to v2. Docs: https://...", provide grace period (3-6 months). Phase 4: Remove v1 code after sunset date + grace period. Real-world example (Stripe): Stripe API versions: 2019-12-03, 2020-08-27, 2022-11-15, each version is a "snapshot" of API at that date, versions supported for 1 year after deprecation notice, clients specify version in header: Stripe-Version: 2022-11-15. Pydantic implementation: request_version = request.headers.get("api-version", "v3"); if request_version == "v1": user_model = UserCreateV1; elif request_version == "v2": user_model = UserCreateV2; else: user_model = UserCreateV3; user = user_model(**request.json()).',
    keyPoints: [
      'Versioning strategies: Separate models per version, shared base, route-based (/v1/users, /v2/users)',
      'Deprecation: Keep deprecated fields functional, migrate with @validator, log warnings, OpenAPI deprecated flag',
      'Adding required fields: Make optional with defaults, separate endpoints, runtime defaults by version header',
      'Union types: Accept multiple versions, discriminated unions with Literal["v1"|"v2"|"v3"]',
      'Testing: Compatibility tests across versions, migration testing, deprecation warnings, phased sunset (announce → log → 410 Gone → remove)',
    ],
  },
];
