export const fastapiArchitecturePhilosophyQuiz = [
  {
    id: 'fastapi-arch-q-1',
    question:
      'Compare and contrast FastAPI with Flask and Django REST Framework. For each framework, discuss: (1) architectural philosophy, (2) performance characteristics, (3) developer experience, (4) specific use cases where each excels, (5) production considerations. A startup is building a new mobile app backend that needs real-time features, automatic API documentation, and will handle high traffic. Which framework would you recommend and why?',
    sampleAnswer:
      'Framework comparison and recommendation: (1) FastAPI architecture: Built on ASGI (async), type-driven development with Pydantic, dependency injection system, standards-based (OpenAPI). Philosophy: Performance + developer experience without compromise. (2) Flask architecture: WSGI (sync), minimal core, extension-based, flexible routing. Philosophy: Microframework, unopinionated, developer controls everything. (3) Django REST Framework architecture: Full-stack framework, batteries-included, MTV pattern, ORM-centric, built-in admin. Philosophy: "Don\'t repeat yourself," convention over configuration. Performance: FastAPI ~37,000 req/s (async I/O, Starlette/Uvicorn), Flask ~3,000 req/s (sync, blocking), Django ~1,500 req/s (heavyweight ORM, sync). FastAPI 10-25x faster for I/O-bound operations. Developer experience: FastAPI - Automatic validation, type safety, auto-generated OpenAPI docs, IDE autocomplete, fewer bugs. Flask - Flexible but manual validation, no auto-docs, simpler learning curve. Django - Full ecosystem (admin, auth, ORM), heavy learning curve, more boilerplate. Use cases: FastAPI excels at: High-performance APIs, microservices, real-time (WebSockets), ML model serving, async architecture. Flask excels at: Simple REST APIs, legacy systems, gradual migration, specific extensions needed. Django excels at: Full web apps (HTML + API), admin panel needed, monolithic architecture, rapid prototyping with batteries-included. Production considerations: FastAPI - Excellent performance, automatic docs critical for teams, type safety reduces bugs, async requires understanding. Flask - Mature ecosystem, lots of extensions, need to build validation/docs manually. Django - Proven at scale, admin panel valuable, heavier resource footprint. Recommendation for startup mobile backend: FastAPI because: (1) Real-time features: Native async/WebSocket support crucial. Flask/Django limited. (2) High traffic: 10x+ better performance matters at scale. (3) Automatic documentation: OpenAPI critical for mobile team integration, saves weeks of work. (4) Modern Python: Type hints catch errors early, better IDE support, easier onboarding. (5) Microservices-ready: Lightweight, scales horizontally easily. (6) Developer velocity: Less code, fewer bugs, faster iteration. Trade-offs: Newer ecosystem (fewer extensions), team needs async knowledge, less "batteries-included" than Django. But for mobile backend with performance/real-time needs, FastAPI is optimal choice. Alternative: If team has zero async experience and needs admin panel, start with Django + DRF, migrate performance-critical endpoints to FastAPI later.',
    keyPoints: [
      'FastAPI: ASGI async, 10-25x faster, type-driven, automatic OpenAPI docs',
      'Flask: WSGI sync, flexible, manual validation, mature ecosystem',
      'Django/DRF: Full-stack, batteries-included, admin panel, heavyweight',
      'For mobile backend with real-time: FastAPI ideal (async, performance, auto-docs)',
      'Production: FastAPI for APIs/microservices, Django for full apps, Flask for simple/legacy',
    ],
  },
  {
    id: 'fastapi-arch-q-2',
    question:
      'Explain how FastAPI leverages Python type hints for validation, documentation, and developer experience. Discuss: (1) how Pydantic models work under the hood, (2) the relationship between type hints and OpenAPI schema generation, (3) validation performance implications, (4) trade-offs between type safety and flexibility, (5) how dependency injection enhances this system. Provide code examples showing complex validation scenarios.',
    sampleAnswer:
      'Type hints in FastAPI ecosystem: (1) Pydantic under the hood: Uses Python type annotations to define data schemas. At runtime, Pydantic creates validators from annotations. Process: Type hints → Pydantic schema → Rust-based validation (pydantic-core in v2). Example: class User(BaseModel): email: EmailStr; age: int = Field (ge=0, le=120). Pydantic generates validator that checks email format, age range. Validation is 5-17x faster than marshmallow (pure Python validators). Uses Rust for core validation logic. (2) Type hints to OpenAPI: FastAPI introspects function signatures. For endpoint: @app.post("/users", response_model=UserResponse) async def create (user: UserCreate) → FastAPI extracts: Path: /users, Method: POST, Request body: UserCreate schema, Response: UserResponse schema. Generates JSON Schema for each model, compiles to OpenAPI 3.0 spec. Automatic: parameter descriptions, validation rules, examples, response codes. (3) Validation performance: Pydantic v2 (Rust-based): 5-17x faster than v1, comparable to hand-written validators. Runs at request parsing time, before handler execution. Cost: ~0.1-1ms per request (negligible vs I/O). Benefit: Catch invalid data before expensive operations (DB queries). Example: Invalid email rejected in 0.1ms vs 100ms database transaction wasted. (4) Type safety vs flexibility: Type safety benefits: IDE autocomplete, mypy static checking, runtime validation, self-documenting code. Trade-off: Less "duck typing," more upfront schema definition. Flexibility maintained: Use Union types, Optional, custom validators, Config options, arbitrary JSON with dict[str, Any]. Example complex validation: class Address(BaseModel): street: str; city: str; country: str = Field(..., regex="^[A-Z]{2}$"). class User(BaseModel): name: str = Field (min_length=1, max_length=100); email: EmailStr; age: int = Field (ge=18, description="Must be 18+"); addresses: List[Address] = []; tags: Optional[List[str]] = None; metadata: dict[str, Any] = {}; @validator("name") def name_no_numbers (cls, v): if any (c.isdigit() for c in v): raise ValueError("Name cannot contain numbers"); return v. This provides: string length validation, email format, age constraints, nested object validation, list validation, custom validators, arbitrary data (metadata). (5) Dependency injection enhances types: Dependencies are typed, enabling: Automatic resolution, type checking, testing (mock dependencies), reusability. Example: async def get_current_user (token: str = Depends (oauth2)) → User: validates token, returns User object. async def get_admin (user: User = Depends (get_current_user)) → User: depends on get_current_user, checks admin role. Endpoint: @app.delete("/users/{id}") async def delete (user_id: int, admin: User = Depends (get_admin), db: Session = Depends (get_db)). Dependencies resolved automatically, type-checked, testable by injecting mocks. Production impact: Type-driven approach reduces bugs by 40% (Microsoft study on TypeScript, similar benefits), saves documentation time (OpenAPI auto-generated), improves onboarding (types are documentation), enables tooling (mypy, IDE autocomplete), validates at API boundary (fail fast).',
    keyPoints: [
      'Pydantic: Type hints → Rust-based validation (5-17x faster), ~0.1-1ms overhead',
      'Type hints → OpenAPI: FastAPI introspects signatures, generates docs automatically',
      'Complex validation: Field constraints, nested objects, custom validators, Union types',
      'Dependency injection: Typed dependencies, automatic resolution, testable with mocks',
      'Production: 40% fewer bugs, self-documenting, fail fast at API boundary',
    ],
  },
  {
    id: 'fastapi-arch-q-3',
    question:
      'Design a production-ready FastAPI application architecture for a high-traffic e-commerce platform. Address: (1) application structure and organization (routers, services, repositories), (2) async vs sync endpoint decisions, (3) database connection management with dependency injection, (4) error handling strategy, (5) middleware for logging, CORS, authentication, (6) deployment configuration. How would you handle 100,000+ requests per minute? Include code structure examples.',
    sampleAnswer:
      'E-commerce FastAPI architecture for scale: (1) Application structure: app/ ├── main.py (app entry, lifespan, middleware) ├── api/ │   ├── v1/ (versioned APIs) │   │   ├── endpoints/ │   │   │   ├── auth.py (login, logout, refresh) │   │   │   ├── products.py (product routes) │   │   │   ├── orders.py (order routes) │   │   │   └── users.py (user routes) │   │   └── router.py (combine routers) │   └── deps.py (shared dependencies) ├── core/ │   ├── config.py (settings, env vars) │   ├── security.py (JWT, password hashing) │   └── logging.py (structured logging) ├── db/ │   ├── base.py (Base, engine, session) │   └── repositories/ (data access layer) │       ├── product_repo.py │       ├── order_repo.py │       └── user_repo.py ├── models/ (SQLAlchemy ORM models) │   ├── user.py │   ├── product.py │   └── order.py ├── schemas/ (Pydantic models) │   ├── user.py │   ├── product.py │   └── order.py └── services/ (business logic) ├── product_service.py ├── order_service.py └── user_service.py. Layers: Endpoint → Service → Repository → Database. (2) Async vs sync decisions: Use async for: I/O-bound: database queries (async SQLAlchemy), HTTP requests (httpx), file operations (aiofiles), Redis/cache (aioredis), external APIs. Example: @app.get("/products") async def list_products (repo: ProductRepo = Depends()): products = await repo.list_all(); return products. Use sync for: CPU-bound: password hashing (bcrypt), image processing (Pillow), data encryption. Example: @app.post("/users") def create_user (user: UserCreate): hashed = hash_password (user.password); # CPU-bound, blocks; return create (user). Run sync in thread pool: from fastapi import BackgroundTasks; result = await run_in_threadpool (cpu_bound_task, data). (3) Database connection management: # db/base.py: from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession; engine = create_async_engine(DATABASE_URL, pool_size=20, max_overflow=40, pool_pre_ping=True); async_session = sessionmaker (engine, class_=AsyncSession, expire_on_commit=False). # api/deps.py: async def get_db() → AsyncSession: async with async_session() as session: async with session.begin(): yield session; # Auto-commit/rollback. # Repository pattern: class ProductRepo: def __init__(self, db: AsyncSession): self.db = db; async def get (self, id: int): return await self.db.get(Product, id); async def list_all (self): result = await self.db.execute (select(Product)); return result.scalars().all(). # Endpoint: @app.get("/products/{id}") async def get_product (id: int, db: AsyncSession = Depends (get_db)): repo = ProductRepo (db); product = await repo.get (id); if not product: raise HTTPException(404); return product. (4) Error handling: # Global exception handlers: @app.exception_handler(HTTPException) async def http_exception_handler (request, exc): return JSONResponse({"error": exc.detail, "code": exc.status_code}, status_code=exc.status_code); @app.exception_handler(Exception) async def global_exception_handler (request, exc): logger.error (f"Unhandled: {exc}", exc_info=True); return JSONResponse({"error": "Internal server error"}, status_code=500). # Custom exceptions: class ProductNotFound(Exception): pass. @app.exception_handler(ProductNotFound) async def product_not_found_handler (request, exc): return JSONResponse({"error": "Product not found"}, status_code=404). (5) Middleware: # Logging: @app.middleware("http") async def log_requests (request: Request, call_next): start = time.time(); response = await call_next (request); duration = time.time() - start; logger.info (f"{request.method} {request.url.path} {response.status_code} {duration:.3f}s"); return response. # CORS: app.add_middleware(CORSMiddleware, allow_origins=["https://example.com"], allow_credentials=True, allow_methods=["*"]). # Authentication: @app.middleware("http") async def auth_middleware (request, call_next): if request.url.path.startswith("/api/v1"): token = request.headers.get("Authorization"); if not token: return JSONResponse({"error": "Unauthorized"}, 401); # Validate token; response = await call_next (request); return response. (6) Handling 100K+ req/min: Deploy strategy: 10 Uvicorn workers (1 per CPU core), gunicorn as process manager: gunicorn main:app --workers 10 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000. Load balancer (NGINX/ALB) → Multiple app instances (K8s pods). Database: Connection pooling (pool_size=20, max_overflow=40), read replicas for queries, pgbouncer for connection pooling. Caching: Redis for frequently accessed data (products, user sessions), cache products for 5min (100K reads → 10K DB queries). Async everything: Async DB queries, async HTTP clients, async Redis. Horizontal scaling: Stateless app instances, scale pods based on CPU/memory, auto-scaling (HPA in Kubernetes). Monitoring: Prometheus metrics (request rate, latency, error rate), distributed tracing (OpenTelemetry), structured logging (JSON logs). Performance: Each Uvicorn worker handles ~5-10K req/s (I/O-bound, async), 10 workers = 50-100K req/s per machine. Scale horizontally with load balancer + multiple machines/pods. Cache hit rate 90% reduces DB load 10x.',
    keyPoints: [
      'Structure: Layered (endpoint → service → repository → DB), versioned APIs, DI',
      'Async for I/O (DB, HTTP, cache), sync for CPU-bound (hashing), threadpool for blocking',
      'DB: Async SQLAlchemy, connection pooling, repository pattern, dependency injection',
      'Error handling: Global handlers, custom exceptions, structured logging',
      'Scale: 10 workers/machine, async I/O, Redis caching 90%, horizontal scaling, 50-100K req/s',
    ],
  },
];
