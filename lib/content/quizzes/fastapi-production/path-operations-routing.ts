export const pathOperationsRoutingQuiz = [
  {
    id: 'fastapi-routing-q-1',
    question:
      'Design a comprehensive routing architecture for a SaaS e-commerce platform with API versioning, multi-tenancy, and admin separation. Address: (1) URL structure for v1, v2, v3 APIs with different capabilities, (2) tenant isolation in routing (subdomain vs path vs header), (3) admin API separation and security, (4) organizing 50+ endpoints across users, products, orders, payments, analytics modules, (5) implementing graceful deprecation for v1 endpoints. Provide complete router structure with code examples.',
    sampleAnswer:
      'SaaS e-commerce routing architecture: (1) API versioning structure: URL-based versioning for clarity. app/ ├── api/ │   ├── v1/ (deprecated, sunset in 6 months) │   │   ├── router.py │   │   └── endpoints/ (users, products, orders basic CRUD) │   ├── v2/ (current stable) │   │   ├── router.py │   │   └── endpoints/ (adds pagination, filtering) │   ├── v3/ (latest, adds GraphQL-like features) │   │   ├── router.py │   │   └── endpoints/ (adds include/exclude fields, batch ops) │   └── deps.py (shared dependencies) V1 endpoints: GET /api/v1/products (simple list). V2 endpoints: GET /api/v2/products?page=1&page_size=20&sort=price (paginated). V3 endpoints: GET /api/v3/products?fields=id,name,price&expand=category (field selection). Each version has separate Pydantic models: v1: ProductV1(id, name, price), v2: ProductV2(id, name, price, category_id, created_at), v3: ProductV3 with optional field selection. (2) Multi-tenancy routing: Best approach: Subdomain (cleanest): api.tenant1.example.com, api.tenant2.example.com. Extract tenant from subdomain: async def get_tenant(request: Request) → Tenant: subdomain = request.url.hostname.split(".")[0]; tenant = await fetch_tenant(subdomain); if not tenant: raise HTTPException(403, "Invalid tenant"); return tenant. Apply to all routers: tenancy_router = APIRouter(dependencies=[Depends(get_tenant)]). Alternative: Path-based (less clean but simpler): /api/{tenant_id}/v2/products. Alternative: Header-based: X-Tenant-ID header. Recommendation: Subdomain for production (professional), path for development. (3) Admin API separation: Separate sub-application for isolation: admin_app = FastAPI(title="Admin API", docs_url="/admin/docs"); @admin_app.get("/users") async def admin_list_users(admin: Admin = Depends(get_current_admin)). Mount at /admin: app.mount("/admin", admin_app). Security: Separate authentication (admin JWT different from user JWT), IP whitelist for admin endpoints, rate limiting stricter for admin, audit logging for all admin actions. Structure: admin/ ├── users.py (manage all users) ├── products.py (bulk operations) ├── orders.py (refunds, cancellations) ├── analytics.py (platform metrics) └── settings.py (platform configuration). Admin dependencies: async def require_admin(current_user: User = Depends(get_current_user)): if not current_user.is_admin: raise HTTPException(403, "Admin required"); return current_user. (4) Organizing 50+ endpoints: Modular structure by domain: api/v2/ ├── users/ │   ├── router.py │   ├── auth.py (login, logout, register) │   ├── profile.py (get, update profile) │   └── preferences.py (settings) ├── products/ │   ├── router.py │   ├── crud.py (CRUD operations) │   ├── search.py (search, filter) │   └── reviews.py (product reviews) ├── orders/ │   ├── router.py │   ├── cart.py (shopping cart) │   ├── checkout.py (create order) │   ├── management.py (list, get, cancel) │   └── fulfillment.py (shipping, tracking) ├── payments/ │   ├── router.py │   ├── methods.py (add, remove payment methods) │   └── transactions.py (payment processing) └── analytics/ ├── router.py ├── sales.py (sales metrics) └── customers.py (customer insights). Combine routers: from api.v2.users.router import router as users_router; from api.v2.products.router import router as products_router; v2_router = APIRouter(prefix="/api/v2"); v2_router.include_router(users_router, prefix="/users", tags=["users"]); v2_router.include_router(products_router, prefix="/products", tags=["products"]). This creates clear OpenAPI documentation with tags. (5) Graceful v1 deprecation: Phase 1 (Month 0): Announce deprecation. Add deprecation header: @v1_router.get("/products") async def list_products_v1(response: Response): response.headers["X-API-Deprecated"] = "true"; response.headers["X-API-Sunset"] = "2024-06-01"; response.headers["X-API-Migration-Guide"] = "https://docs.example.com/migrate-v2"; return products. Add deprecated flag to OpenAPI docs: v1_router = APIRouter(prefix="/api/v1", tags=["v1 (Deprecated)"], deprecated=True). Phase 2 (Month 1-3): Log v1 usage. Identify active v1 clients: @app.middleware("http") async def log_v1_usage(request: Request, call_next): if request.url.path.startswith("/api/v1"): logger.warning(f"V1 API used: {request.client.host} {request.url.path}"); # Track client (IP, API key) for outreach; response = await call_next(request); return response. Send notifications to v1 clients with migration guide. Phase 3 (Month 4-5): Return warnings. @v1_router.get("/products") async def list_products_v1(): return {"warning": "API v1 will be removed on 2024-06-01. Please migrate to v2.", "data": products}. Phase 4 (Month 6): Return 410 Gone. @v1_router.get("/products") async def list_products_v1(): raise HTTPException(410, detail="API v1 is deprecated. Migrate to v2: https://docs.example.com/migrate"). Phase 5 (Month 7): Remove v1 code. Complete removal after grace period. Monitoring: Track v1 usage decline (100% → 10% → 1% → 0%), automated alerts when v1 usage spikes, dashboard showing clients still on v1. Testing strategy: Maintain v1 tests during deprecation, integration tests for v1 → v2 migration, contract tests to ensure v2 backward compatibility where possible.',
    keyPoints: [
      'Versioning: URL-based (/api/v1, v2, v3), separate routers & models per version',
      'Multi-tenancy: Subdomain extraction (api.tenant.com), tenant dependency injection',
      'Admin separation: Separate FastAPI sub-app, mount at /admin, stricter auth & audit logging',
      'Organization: Domain-based modules (users, products, orders), combine with include_router, use tags for docs',
      'Deprecation: 6-month phased sunset (announce → log → warn → 410 Gone → remove), migration guide, client tracking',
    ],
  },
  {
    id: 'fastapi-routing-q-2',
    question:
      'Compare URL-based vs header-based API versioning for a public API used by thousands of clients. Discuss: (1) implementation complexity, (2) client integration effort, (3) caching implications (CDN, browser cache), (4) documentation and discoverability, (5) migration path for clients, (6) which approach major companies use (Stripe, GitHub, AWS) and why. Provide recommendation with trade-offs.',
    sampleAnswer:
      'URL-based vs Header-based API versioning comparison: (1) Implementation complexity: URL-based (simpler): Separate routers per version, clear code organization, easy routing: @app.include_router(v1_router, prefix="/api/v1"); @app.include_router(v2_router, prefix="/api/v2"). Cons: URL duplication, can\'t share routes easily. Header-based (complex): Single set of routes, version logic in handlers or dependencies: async def get_api_version(api_version: str = Header("v2")): return api_version. @app.get("/users") async def list_users(version: str = Depends(get_api_version)): if version == "v1": return old_format(); elif version == "v2": return new_format(). Cons: More complex routing logic, conditional code in handlers, harder to deprecate specific versions. Verdict: URL-based simpler for implementation and maintenance. (2) Client integration: URL-based (easier): Clients just change URL: https://api.example.com/v1/users → https://api.example.com/v2/users. No header management, works with curl, browser, any HTTP client. Header-based (harder): Clients must set header: curl -H "API-Version: 2023-11-01" https://api.example.com/users. Requires header management in every request, some tools (Postman, browsers) need configuration, easier to forget or misconfigure. Verdict: URL-based easier for clients (no header juggling). (3) Caching implications: URL-based (cache-friendly): Different URLs = different cache keys, CDN can cache v1 and v2 separately: /api/v1/products (cached for 1 hour), /api/v2/products (cached for 5 minutes different TTL). No cache collisions. Header-based (cache-problematic): Same URL, different header = needs Vary: API-Version header, CDN must support Vary header (not all do), cache efficiency lower (same URL, multiple cached versions), browser cache doesn\'t respect Vary reliably. Must configure CDN: Cache-Control: max-age=300, Vary: API-Version. CloudFront, Fastly support Vary but with complexity. Verdict: URL-based much better for caching. (4) Documentation & discoverability: URL-based (clear): OpenAPI docs naturally separate: /docs shows all versions or /v1/docs, /v2/docs separate, versioning obvious in docs, easy to explore different versions. FastAPI generates clean docs with version separation. Header-based (complex): Single OpenAPI spec or need separate specs per version, harder to show "this endpoint has 3 versions", clients must know to set header (not obvious), documentation must explain header versioning (extra cognitive load). Verdict: URL-based more discoverable and self-documenting. (5) Migration path: URL-based: Clients migrate at their own pace, can test v2 while still using v1 in production, gradual endpoint-by-endpoint migration possible, sunset schedule per version (v1 sunset 2024-06-01). Clear deprecation: 301 redirects v1 → v2 possible, 410 Gone when removed. Header-based: Clients change header value (small change), can use header to A/B test versions, harder to deprecate (can\'t redirect headers), must coordinate full migration (can\'t mix v1/v2 easily). Verdict: URL-based easier migration, header-based smaller code change. (6) Industry practices: Stripe (header-based): API-Version: 2023-11-01 header, versioning by date (not v1/v2/v3), each version is "snapshot" of API on that date, maintains 12+ versions simultaneously (backward compatibility critical for payments). Why: Prevents breaking changes for existing integrations, allows fine-grained version control (date-based), single URL simplifies integration initially. Trade-off: Complex internal versioning logic, clients must manage headers. GitHub (URL-based mixed): REST API: URL versioning (api.github.com/v3, deprecated, api.github.com/repos default), GraphQL: Single endpoint, schema versioning, moving to URL-less versioning for consistency. Why: REST API simplicity (URL versioning), GraphQL doesn\'t need URL versioning (schema-based). AWS (URL-based): Most services use URL versioning: ec2.amazonaws.com/2016-11-15, s3.amazonaws.com/v2, CloudFormation API version in URL. Why: Clear service boundaries, easy to deprecate old versions, CDN caching efficiency. Trade-off: Longer URLs. Twilio (URL-based): /2010-04-01/, /v2 (year-based and major version), mix of date and version numbering. Twitter (URL-based): /1.1/, /2/ (major versions). Why: Simplicity, discoverability, REST conventions. Recommendation: Use URL-based versioning for: Public APIs (ease of integration), APIs with caching (CDN, browser), REST APIs (convention), APIs with multiple clients (mobile, web, partners), clear deprecation path. Use header-based versioning for: Internal APIs (control over clients), APIs requiring backward compatibility for years (payments), date-based snapshots (Stripe model), GraphQL APIs (single endpoint). Best practice: Choose URL-based unless specific need for header-based (like Stripe). If using headers, provide default version for no-header requests. Trade-offs summary: URL-based: Simpler, cache-friendly, discoverable, easier migration. Cons: URL duplication, more routes. Header-based: Single URL, fine-grained control, harder to cache, complex for clients. Cons: caching issues, less discoverable.',
    keyPoints: [
      'URL-based: Simpler implementation, cache-friendly (CDN/browser), discoverable in docs, easier client migration',
      'Header-based: Single URL, fine-grained control, complex caching (Vary header), harder for clients',
      'Caching: URL-based works with all CDNs, header-based needs Vary support and reduces cache efficiency',
      'Industry: Stripe (header, date-based, backward compat), GitHub/AWS/Twitter (URL, simplicity), choose based on needs',
      'Recommendation: URL-based for public/REST APIs, header-based only if need Stripe-like backward compatibility',
    ],
  },
  {
    id: 'fastapi-routing-q-3',
    question:
      'Design query parameter validation strategy for a complex search/filtering API with 20+ filter parameters, pagination, sorting, and field selection. Address: (1) handling optional filters cleanly without 20 function parameters, (2) validating filter combinations (e.g., date ranges, mutually exclusive filters), (3) default values and sensible limits, (4) performance implications of complex filtering, (5) generating clear error messages for invalid parameters. Include code examples and patterns.',
    sampleAnswer:
      'Complex query parameter strategy: (1) Handling many optional filters: Problem: @app.get("/products") async def search(param1=None, param2=None, ..., param20=None) → 20 parameters in function signature! Solution A: Pydantic model for filters: class ProductFilters(BaseModel): # Text search; search: Optional[str] = Field(None, min_length=2, max_length=100); # Category filters; category_ids: Optional[List[int]] = Field(None, max_items=10); brand_ids: Optional[List[int]] = Field(None, max_items=5); # Price range; min_price: Optional[Decimal] = Field(None, ge=0); max_price: Optional[Decimal] = Field(None, ge=0, le=1_000_000); # Numeric filters; min_rating: Optional[float] = Field(None, ge=0, le=5); stock_status: Optional[Literal["in_stock", "out_of_stock", "all"]] = "all"; # Date filters; created_after: Optional[date] = None; created_before: Optional[date] = None; # Boolean flags; is_featured: Optional[bool] = None; is_on_sale: Optional[bool] = None; # Pagination; page: int = Field(1, ge=1, le=10000); page_size: int = Field(20, ge=1, le=100); # Sorting; sort_by: str = Field("relevance", regex="^(price|rating|created_at|name|relevance)$"); sort_order: Literal["asc", "desc"] = "desc"; # Field selection; fields: Optional[List[str]] = Field(None, description="Fields to return"). Usage: @app.get("/products") async def search_products(filters: ProductFilters = Depends()): # Depends() parses query params into ProductFilters model; # All validation automatic!; return await query_products(filters). Benefits: Single parameter in handler, all validation in model, reusable across endpoints, easy to test. Solution B: Separate models for concerns: class PaginationParams(BaseModel): page: int = Field(1, ge=1); page_size: int = Field(20, ge=1, le=100). class SortParams(BaseModel): sort_by: str; sort_order: Literal["asc", "desc"] = "desc". class ProductFilters(BaseModel): search: Optional[str] = None; # ...other filters. @app.get("/products") async def search(filters: ProductFilters = Depends(), pagination: PaginationParams = Depends(), sorting: SortParams = Depends()): pass. (2) Validating filter combinations: Use @root_validator for cross-field validation: class ProductFilters(BaseModel): min_price: Optional[Decimal] = None; max_price: Optional[Decimal] = None; created_after: Optional[date] = None; created_before: Optional[date] = None; search: Optional[str] = None; category_ids: Optional[List[int]] = None; @root_validator def validate_price_range(cls, values): min_price = values.get("min_price"); max_price = values.get("max_price"); if min_price and max_price and min_price > max_price: raise ValueError("min_price must be less than max_price"); return values; @root_validator def validate_date_range(cls, values): after = values.get("created_after"); before = values.get("created_before"); if after and before and after > before: raise ValueError("created_after must be before created_before"); # Enforce max 1 year range; if after and before and (before - after).days > 365: raise ValueError("Date range cannot exceed 1 year"); return values; @root_validator def require_filter(cls, values): # At least one filter required; has_filter = any([values.get("search"), values.get("category_ids"), values.get("min_price"), values.get("max_price")]); if not has_filter: raise ValueError("At least one filter required (search, category, price range)"); return values. Mutually exclusive filters: class AnalyticsFilters(BaseModel): user_id: Optional[int] = None; team_id: Optional[int] = None; @root_validator def mutually_exclusive(cls, values): if values.get("user_id") and values.get("team_id"): raise ValueError("Cannot filter by both user_id and team_id"); return values. (3) Default values & limits: Sensible defaults: Pagination: page=1, page_size=20 (not 100—too expensive), max page_size=100 (prevent abuse), max page=10000 (prevent deep pagination—use cursor instead). Date ranges: Default to last 30 days if no dates provided: created_after: date = Field(default_factory=lambda: date.today() - timedelta(days=30)); created_before: date = Field(default_factory=date.today). Sorting: Default to relevance or created_at desc. Lists: max_items=10 for filter lists (prevents huge IN queries). Rate limiting: Max 100 requests/minute per API key. Example with limits: class ProductFilters(BaseModel): category_ids: List[int] = Field(default=[], max_items=10, description="Max 10 categories"); page_size: int = Field(20, ge=1, le=100, description="Max 100 items per page"); search: Optional[str] = Field(None, min_length=2, max_length=100, description="2-100 chars"); created_after: date = Field(default_factory=lambda: date.today() - timedelta(days=90)); created_before: date = Field(default_factory=date.today). (4) Performance implications: Problem: Complex filters can generate expensive database queries. Solutions: Index strategy: CREATE INDEX idx_products_category ON products(category_id); CREATE INDEX idx_products_price ON products(price); CREATE INDEX idx_products_created ON products(created_at); CREATE INDEX idx_products_search ON products USING gin(to_tsvector(\'english\', name || \' \' || description)). Composite indexes for common filter combinations: CREATE INDEX idx_products_cat_price ON products(category_id, price); CREATE INDEX idx_products_cat_created ON products(category_id, created_at DESC). Query optimization: Limit early: SELECT * FROM products WHERE category_id = 1 ORDER BY created_at DESC LIMIT 20 → Fast. Avoid: SELECT * FROM products WHERE expensive_calculation() ORDER BY created_at → Slow. Use EXPLAIN ANALYZE to profile. Caching: Cache common filter combinations (category pages), Redis cache key from filter hash: cache_key = f"products:{hash(filters)}"; if cached := redis.get(cache_key): return cached. TTL: 5 minutes for dynamic, 1 hour for stable filters. Pagination optimization: Cursor-based for large datasets: last_id: Optional[int] = None; SELECT * FROM products WHERE id > last_id ORDER BY id LIMIT 20. Offset-based for small datasets: SELECT * FROM products OFFSET 20 LIMIT 20. Prevent deep pagination: max page=1000 (offset=20000 too slow). Database query building: Use SQLAlchemy query builder: query = select(Product); if filters.search: query = query.where(Product.name.ilike(f"%{filters.search}%")); if filters.category_ids: query = query.where(Product.category_id.in_(filters.category_ids)); if filters.min_price: query = query.where(Product.price >= filters.min_price); query = query.order_by(getattr(Product, filters.sort_by).desc() if filters.sort_order == "desc" else asc()). (5) Clear error messages: Pydantic provides detailed validation errors, customize for user-friendliness: @app.exception_handler(RequestValidationError) async def validation_exception_handler(request, exc): errors = []; for error in exc.errors(): field = " → ".join(str(x) for x in error["loc"][1:]); # Skip "query"; msg = error["msg"]; type_ = error["type"]; # Custom messages; if type_ == "value_error.number.not_ge": errors.append(f"{field}: must be at least {error[\'ctx\'][\'limit_value\']}"); elif type_ == "value_error.number.not_le": errors.append(f"{field}: must be at most {error[\'ctx\'][\'limit_value\']}"); elif "date_range" in msg: errors.append(f"Date range: {msg}"); else: errors.append(f"{field}: {msg}"); return JSONResponse(status_code=422, content={"detail": "Invalid filters", "errors": errors}). Example error response: {"detail": "Invalid filters", "errors": ["min_price: must be at least 0", "page_size: must be at most 100", "created_after: must be before created_before"]}. Testing: def test_price_range_validation(): response = client.get("/products?min_price=100&max_price=50"); assert response.status_code == 422; assert "min_price must be less than max_price" in response.json()["errors"]. Production monitoring: Log common validation errors to identify UX issues, track filter usage to optimize indexes, alert on high error rates (>5%).',
    keyPoints: [
      'Many filters: Use Pydantic model with Depends(), single parameter in handler, all validation in model',
      'Combination validation: @root_validator for cross-field logic (date ranges, mutually exclusive, required filters)',
      'Defaults & limits: page_size=20 max 100, max_items=10 for lists, default date ranges, prevent abuse',
      'Performance: Index common filters, cache filter combinations, cursor pagination, prevent deep pagination, use EXPLAIN ANALYZE',
      'Error messages: Customize RequestValidationError handler, user-friendly messages, log for UX improvements',
    ],
  },
];
