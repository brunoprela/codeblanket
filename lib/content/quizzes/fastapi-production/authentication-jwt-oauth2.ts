export const authenticationJwtOauth2Quiz = [
  {
    id: 'fastapi-auth-q-1',
    question:
      'Design a complete authentication system for a mobile app using JWT access tokens and refresh tokens. Address: (1) token generation with appropriate claims and expiration times, (2) secure token storage recommendations for mobile, (3) refresh token rotation strategy, (4) handling token revocation/logout, (5) implementing "remember me" functionality. Include security considerations and complete code.',
    sampleAnswer:
      'Mobile app JWT authentication system: (1) Token generation with claims: Access token (short-lived): expire = datetime.utcnow() + timedelta (minutes=15); payload = {"sub": str (user.id), "username": user.username, "email": user.email, "roles": user.roles, "exp": expire, "iat": datetime.utcnow(), "type": "access", "jti": str (uuid.uuid4())}; access_token = jwt.encode (payload, SECRET_KEY, algorithm="HS256"). Refresh token (long-lived): expire = datetime.utcnow() + timedelta (days=7); payload = {"sub": str (user.id), "exp": expire, "iat": datetime.utcnow(), "type": "refresh", "jti": str (uuid.uuid4()), "device_id": device_id}; refresh_token = jwt.encode (payload, SECRET_KEY). Key claims: sub (user ID), exp (expiration), iat (issued at), jti (JWT ID for revocation), type (access/refresh), device_id (track devices). Why 15min access + 7day refresh: Access token short → minimizes damage if stolen, refresh token long → good UX (no frequent re-login), compromise: stolen refresh more dangerous but rare. (2) Mobile token storage: iOS - Keychain: import Security; // Store in keychain; let query = [kSecClass: kSecClassGenericPassword, kSecAttrAccount: "access_token", kSecValueData: token.data (using: .utf8)!]; SecItemAdd (query as CFDictionary, nil). Secure, encrypted by OS, survives app reinstall. Android - EncryptedSharedPreferences: val masterKey = MasterKey.Builder (context).setKeyScheme(SCHEME).build(); val prefs = EncryptedSharedPreferences.create (context, "auth_prefs", masterKey, AES256_SIV, AES256_GCM); prefs.edit().putString("access_token", token).apply(). Encrypted at rest, tied to app. NEVER: Plain SharedPreferences (unencrypted), local database without encryption, JavaScript AsyncStorage (if using React Native - use SecureStore). (3) Refresh token rotation: On token refresh, issue NEW refresh token, invalidate old refresh token. Implementation: refresh_tokens table: CREATE TABLE refresh_tokens (id, user_id, token_hash, device_id, created_at, expires_at, revoked BOOLEAN); On login: token_hash = hash (refresh_token); db.add(RefreshToken (user_id=user.id, token_hash=token_hash, device_id=device_id, expires_at=expire)); db.commit(). On refresh: @app.post("/token/refresh"); async def refresh (refresh_token: str, db: Session = Depends (get_db)): payload = decode_token (refresh_token); user_id = payload["sub"]; jti = payload["jti"]; # Verify token exists and not revoked; token_record = db.query(RefreshToken).filter_by (user_id=user_id, token_hash=hash (jti), revoked=False).first(); if not token_record: raise HTTPException(401, "Invalid refresh token"); # Create new tokens; new_access = create_access_token({"sub": user_id}); new_refresh = create_refresh_token (user_id, device_id); # Revoke old token; token_record.revoked = True; # Store new token; db.add(RefreshToken (user_id=user_id, token_hash=hash (new_refresh), device_id=device_id)); db.commit(); return {"access_token": new_access, "refresh_token": new_refresh}. Benefits: Stolen refresh token usable only once, automatic revocation on use, audit trail of all token issuance. (4) Token revocation/logout: Store token blacklist in Redis (fast): redis_client = Redis(); On logout: ttl = token_payload["exp"] - time.time(); redis_client.setex (f"blacklist:access:{jti}", int (ttl), "1"); redis_client.setex (f"blacklist:refresh:{jti}", int (ttl), "1"). Check on validation: def verify_token (token): payload = decode_token (token); jti = payload["jti"]; if redis_client.exists (f"blacklist:access:{jti}"): raise HTTPException(401, "Token revoked"); return payload. For refresh tokens, also mark in database: db.query(RefreshToken).filter_by (token_hash=hash (jti)).update({"revoked": True}). Logout all devices: @app.post("/logout-all"); async def logout_all (user: User = Depends (get_current_user), db: Session = Depends (get_db)): db.query(RefreshToken).filter_by (user_id=user.id, revoked=False).update({"revoked": True}); # Blacklist all active refresh tokens; db.commit(); return {"detail": "Logged out from all devices"}. (5) "Remember me" functionality: Approach A - Longer refresh token: Remember me checked: expire = timedelta (days=30), Not checked: expire = timedelta (days=7). @app.post("/login"); async def login (credentials: LoginRequest, remember_me: bool = False): refresh_expiry = timedelta (days=30 if remember_me else 7); refresh_token = create_refresh_token (user.id, device_id, expiry=refresh_expiry). Approach B - Persistent token in database: Create persistent_tokens table, store encrypted token on device, validate on app launch, auto-login if valid. Security considerations: 1. HTTPS only (TLS 1.2+), 2. Token in Authorization header (not query params), 3. CORS properly configured, 4. Rate limit login/refresh endpoints, 5. Log all auth events (login, logout, refresh), 6. Alert on suspicious activity (many failed logins, refreshes from new locations), 7. Token rotation prevents replay attacks, 8. Device binding prevents token theft cross-device. Mobile-specific: Handle token refresh transparently (interceptor), retry failed requests after refresh, queue requests during refresh, logout on 401 after refresh attempt.',
    keyPoints: [
      'Tokens: Access 15min (sub, roles, jti, type), refresh 7 days (sub, jti, device_id), HS256 signing',
      'Mobile storage: iOS Keychain (encrypted), Android EncryptedSharedPreferences, never plain storage',
      'Rotation: Issue new refresh on use, revoke old, store hash in DB, prevents replay attacks',
      'Revocation: Redis blacklist for access tokens (by jti), DB revoked flag for refresh, logout all devices support',
      'Remember me: 30-day refresh vs 7-day, or persistent token, security: HTTPS, rate limiting, audit logging',
    ],
  },
  {
    id: 'fastapi-auth-q-2',
    question:
      'Compare JWT vs session-based authentication for a high-traffic API (100K+ concurrent users). Discuss: (1) scalability (horizontal scaling, state management), (2) performance (overhead, database hits), (3) security (token theft, XSS, CSRF), (4) user experience (logout, token refresh), (5) infrastructure requirements (Redis, DB). Provide decision framework with benchmarks.',
    sampleAnswer:
      'JWT vs Session authentication analysis: (1) Scalability: JWT (stateless): No server-side storage required, any server can validate token (just verify signature), perfect for horizontal scaling (load balancer → any server), no session synchronization between servers, can scale to millions of users easily. Session (stateful): Requires session storage (database, Redis), all servers need access to shared session store, sticky sessions or distributed cache needed, harder to scale (session store becomes bottleneck). Benchmark: 100K concurrent users with JWT: No session storage, ~0.1ms token validation (decode + verify signature), memory: ~1KB per request (token parsing). 100K concurrent users with sessions: Need 100K sessions in Redis (~100MB if 1KB each), ~1ms session lookup in Redis (network + deserialization), Redis becomes single point of failure (need replication). Verdict: JWT scales horizontally much easier. (2) Performance: JWT overhead: Token size: 200-500 bytes (carried in every request), validation: ~0.1ms (decode + verify signature with HS256), no database hit for authentication, but: larger request size (HTTP overhead), need to decode/verify on every request. Session overhead: Session ID: ~20 bytes (small cookie), validation: ~1ms (Redis lookup), requires database/Redis hit on every request, but: smaller request size, faster validation if cached. Benchmark (10K req/s): JWT: 10K × 0.1ms = 1 second CPU time, no database load, total: 1 CPU core. Sessions: 10K × 1ms = 10 seconds, 10K Redis queries/sec, total: 1 CPU core + Redis load. At scale (100K req/s): JWT: 10 CPU cores, no database. Sessions: 10 CPU cores + 100K Redis ops/sec (need powerful Redis cluster). Verdict: JWT more performant at high scale (no database bottleneck). (3) Security: Token theft - JWT: If stolen, valid until expiration (15-30min), mitigation: short expiration + refresh tokens, token blacklist for logout, HTTPS mandatory (prevent theft). Session: If session ID stolen, valid until session expires, mitigation: regenerate session ID on login, IP binding, user-agent check, server-side revocation easy. Verdict: Sessions slightly more secure (instant revocation). XSS attacks: JWT: If stored in localStorage, vulnerable to XSS (JavaScript can read), mitigation: store in httpOnly cookie (not accessible to JS), or memory only (lost on refresh). Session: Stored in httpOnly cookie (safe from XSS), session ID not readable by JavaScript. Verdict: Sessions better (httpOnly default). CSRF attacks: JWT (localStorage): Not vulnerable to CSRF (not sent automatically), but vulnerable to XSS. JWT (cookie): Vulnerable to CSRF (sent automatically), mitigation: CSRF token, SameSite cookie attribute. Session (cookie): Vulnerable to CSRF, mitigation: CSRF token, SameSite=Strict. Verdict: Tie (both need CSRF protection if using cookies). Token size: JWT contains user data (claims) → larger attack surface if leaked, Session ID is random → no info leakage. Recommendation: JWT with httpOnly cookie + SameSite + CSRF token = best security. (4) User experience: Logout - JWT: Complex (need blacklist), or just delete client-side (but token still valid server-side until expiration), "logout all devices" requires blacklist. Session: Easy (delete session server-side), instant logout, easy "logout all sessions". Verdict: Sessions better for logout UX. Token refresh - JWT: Refresh token flow (exchange refresh for new access), transparent to user (background refresh), but complex implementation. Session: Extend session expiration on activity, simpler (just update TTL). Verdict: Sessions simpler. Remember me - JWT: Longer refresh token expiration (30 days). Session: Persistent session with longer TTL. Verdict: Tie (both support easily). Cross-device: JWT: Same refresh token works on multiple devices (if not device-bound), logout one doesn\'t affect others (unless logout all). Session: Each device has own session, logout one device doesn\'t affect others. Verdict: Tie (both support multi-device). (5) Infrastructure: JWT requirements: Just application servers (stateless), optional: Redis for token blacklist (logout), secret key management (environment variables). No single point of failure, simple deployment. Session requirements: Redis/Memcached for session store (required), high availability: Redis cluster or Redis Sentinel, persistence: AOF or RDB for session recovery, session store is critical (if down, all users logged out). More complex infrastructure, single point of failure (Redis). Cost: JWT: Lower (no session store), just CPU for validation. Sessions: Higher (need Redis cluster), Redis hosting cost (~$100-500/month for 100K users). Decision framework: Use JWT when: Microservices (stateless is critical), horizontal scaling important (many servers), high traffic (100K+ concurrent), cross-service authentication (API gateway), cost-sensitive (no Redis). Use sessions when: Monolithic app (single server or few servers), need instant logout (security critical), lower traffic (<10K concurrent), simpler infrastructure preference, existing session infrastructure. Hybrid approach (best of both): Use JWT for authentication (stateless), store minimal state in Redis (blacklist only), short JWT expiration (5-15min), refresh token in database (not Redis). Benefits: scalable like JWT, revocable like sessions. Example: Uber uses JWT (microservices, scale), GitHub uses sessions (security, instant revocation), Stripe uses API keys (no expiration, revocable). Real-world: Most new APIs use JWT (microservices trend), but add blacklist for security. Best practice: Start with JWT, add session store only if needed for features (instant logout, complex user state).',
    keyPoints: [
      'Scalability: JWT stateless (any server, easy horizontal scaling), sessions stateful (need Redis, harder to scale)',
      'Performance: JWT ~0.1ms validation no DB, sessions ~1ms Redis lookup, at 100K req/s JWT better (no DB bottleneck)',
      'Security: Sessions easier revocation, both need httpOnly+SameSite+CSRF, JWT larger attack surface but acceptable',
      'UX: Sessions easier logout (server-side delete), JWT complex (blacklist), both support remember me/multi-device',
      'Infrastructure: JWT cheaper (no Redis required), sessions need Redis cluster ($100-500/month), hybrid approach best (JWT + minimal Redis)',
    ],
  },
  {
    id: 'fastapi-auth-q-3',
    question:
      'Design password reset flow with security best practices. Address: (1) generating secure reset tokens, (2) token storage and expiration, (3) preventing timing attacks and user enumeration, (4) rate limiting reset requests, (5) notifying users of password changes. Include complete implementation with security analysis.',
    sampleAnswer:
      'Secure password reset flow: (1) Generate secure reset tokens: Use cryptographically secure random: import secrets; reset_token = secrets.token_urlsafe(32). 32 bytes = 256 bits entropy, URL-safe base64 encoded, result: 43 characters. Store hash (not plain token): import hashlib; token_hash = hashlib.sha256(reset_token.encode()).hexdigest(). Why hash: If database breached, attacker can\'t use tokens. Alternative: UUID4 (acceptable but slightly less secure): import uuid; reset_token = str (uuid.uuid4()). Implementation: @app.post("/password/reset-request"); async def request_reset (email: EmailStr, background_tasks: BackgroundTasks, db: Session = Depends (get_db)): # Find user (don\'t reveal if exists!); user = db.query(User).filter(User.email == email).first(); # Always respond same (prevent user enumeration); response = {"detail": "If email exists, reset link sent"}; if not user: # Fake delay (timing attack prevention); await asyncio.sleep (random.uniform(0.1, 0.3)); return response; # Generate token; reset_token = secrets.token_urlsafe(32); token_hash = hashlib.sha256(reset_token.encode()).hexdigest(); expires = datetime.utcnow() + timedelta (hours=1); # Store in database; reset_record = PasswordResetToken (user_id=user.id, token_hash=token_hash, expires_at=expires, used=False); db.add (reset_record); db.commit(); # Send email (background task); background_tasks.add_task (send_reset_email, user.email, reset_token); return response. (2) Token storage and expiration: Database schema: CREATE TABLE password_reset_tokens (id SERIAL PRIMARY KEY, user_id INTEGER REFERENCES users (id), token_hash VARCHAR(64) NOT NULL, created_at TIMESTAMP DEFAULT NOW(), expires_at TIMESTAMP NOT NULL, used BOOLEAN DEFAULT FALSE, used_at TIMESTAMP); Expiration: Short-lived (1 hour), one-time use (mark used=True after use), automatic cleanup (delete expired tokens daily). Cleanup job: async def cleanup_expired_tokens(): while True: db.query(PasswordResetToken).filter(PasswordResetToken.expires_at < datetime.utcnow()).delete(); db.commit(); await asyncio.sleep(86400) # Daily. Validation: def validate_reset_token (token: str, db: Session): token_hash = hashlib.sha256(token.encode()).hexdigest(); record = db.query(PasswordResetToken).filter(PasswordResetToken.token_hash == token_hash, PasswordResetToken.expires_at > datetime.utcnow(), PasswordResetToken.used == False).first(); if not record: raise HTTPException(400, "Invalid or expired token"); return record. (3) Prevent timing attacks and user enumeration: Timing attack: Attacker measures response time. Valid email: 100ms (DB query + email send), invalid email: 10ms (no DB query) → attacker learns email exists! Prevention: Always same response time: if not user: await asyncio.sleep (random.uniform(0.1, 0.3)) # Fake processing. Always same message: "If email exists, reset link sent" (never say "email not found"). User enumeration: Attacker tries many emails to find valid accounts. Prevention: Rate limiting (see below), CAPTCHA after 3 attempts, monitor for enumeration patterns (many failed resets from same IP). Response: Always 200 OK (never 404), same message for success/failure, same response time (±50ms). (4) Rate limiting: Per IP: Max 5 reset requests per hour per IP. from collections import defaultdict; from time import time; reset_attempts_ip = defaultdict (list). def check_reset_rate_limit_ip (ip: str): now = time(); attempts = reset_attempts_ip[ip]; attempts = [t for t in attempts if now - t < 3600]; if len (attempts) >= 5: raise HTTPException(429, "Too many reset requests. Try again in 1 hour."); attempts.append (now); reset_attempts_ip[ip] = attempts. Per email: Max 3 reset requests per day per email. reset_attempts_email = defaultdict (list). def check_reset_rate_limit_email (email: str): now = time(); attempts = reset_attempts_email[email]; attempts = [t for t in attempts if now - t < 86400]; if len (attempts) >= 3: # Don\'t reveal this to user (security); logger.warning (f"Rate limit exceeded for email: {email}"); return; attempts.append (now); reset_attempts_email[email] = attempts. CAPTCHA: After 3 failed attempts from IP, require CAPTCHA: if len (reset_attempts_ip[ip]) >= 3: # Return CAPTCHA challenge; return {"requires_captcha": True, "captcha_site_key": CAPTCHA_KEY}. (5) Notify users of password changes: When password reset completed: @app.post("/password/reset"); async def reset_password (token: str, new_password: str, background_tasks: BackgroundTasks, db: Session = Depends (get_db)): # Validate token; record = validate_reset_token (token, db); user = db.query(User).filter(User.id == record.user_id).first(); # Update password; user.hashed_password = hash_password (new_password); record.used = True; record.used_at = datetime.utcnow(); # Invalidate all sessions/tokens (security!); db.query(RefreshToken).filter(RefreshToken.user_id == user.id).update({"revoked": True}); db.commit(); # Send notification email; background_tasks.add_task (send_password_changed_email, user.email); return {"detail": "Password reset successful"}. Notification email content: Subject: "Password Changed"; Body: "Your password was changed on [date] at [time]. If you didn\'t make this change, click here to secure your account immediately."; Include: timestamp, IP address, device/browser info, link to secure account (if not user\'s action). Alert on suspicious activity: Multiple resets in short time, reset from new location/device, reset + login from different IPs. Security analysis: Token security: 256-bit entropy (unguessable), hashed in database (safe if DB breached), one-time use (replay attack prevention), short expiration (1 hour window), URL-safe (no encoding issues). Attack vectors covered: Brute force: Prevented by 256-bit entropy (2^256 attempts needed), Timing attack: Constant response time, User enumeration: Same message for all cases, Rate limiting: 5/hour per IP + 3/day per email, Replay attack: One-time use tokens, Session hijacking: Invalidate all sessions on password change. Additional security: Email verification before account creation (prevent fake accounts), Two-factor authentication option (even stronger), Security questions (additional verification), Audit log (track all reset requests). Production monitoring: Alert on: >10 reset requests from single IP in 1 hour, >100 reset requests total in 1 hour (potential attack), successful resets followed by immediate deletion (compromised accounts). Compliance: GDPR: Email notification is user notification, HIPAA: Audit trail of all password changes, PCI DSS: Strong password policy + password history.',
    keyPoints: [
      'Token generation: secrets.token_urlsafe(32) for 256-bit entropy, store SHA256 hash not plaintext, 1-hour expiration',
      'Prevention: Constant response time (await sleep for invalid), always same message, never reveal email exists/not',
      'Rate limiting: 5/hour per IP, 3/day per email, CAPTCHA after 3 attempts, monitor enumeration patterns',
      'Token validation: One-time use (mark used), check expiration, hash comparison, invalidate all sessions on reset',
      'Notifications: Email on password change (timestamp, IP, device), alert on suspicious activity, audit logging',
    ],
  },
];
