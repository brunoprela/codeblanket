/**
 * Quiz questions for SQL vs NoSQL section
 */

export const sqlvsnosqlQuiz = [
  {
    id: 'q1',
    question:
      'You are designing a social media platform. Which database would you use for: (a) User accounts and authentication, (b) User posts and timeline feeds, (c) Real-time messaging? Justify each choice.',
    sampleAnswer:
      'Social media database choices: (a) USER ACCOUNTS & AUTHENTICATION - Use SQL (PostgreSQL). Reasoning: User accounts are critical data requiring strong consistency and ACID transactions. Cannot have duplicate emails, must maintain referential integrity. Authentication must be accurate (can\'t have user logged in with wrong credentials). Complex queries needed: "Find mutual friends", "Find users by email/username". Data model: Relational (users, friendships, permissions). Schema: Relatively stable (user accounts don\'t change structure often). Scale: Millions to hundreds of millions of users (SQL can handle with read replicas). Trade-off: Harder to scale writes, but user registration is infrequent compared to reads. Implementation: PostgreSQL primary (writes) + 5-10 read replicas (read scaling). (b) USER POSTS & TIMELINE FEEDS - Use NoSQL (Cassandra). Reasoning: Massive scale (billions of posts, 10s of billions of timeline entries). Write-heavy (millions of posts per day). Denormalized for performance (embed author info in posts to avoid JOINs). Timeline is user-specific (partition by user_id for horizontal scaling). Eventual consistency acceptable (if post appears in feed 100ms late, users don\'t notice). Schema: Flexible (posts may have text, images, videos, polls - varying fields). Data model: Denormalized. Timeline table: { user_id, post_id, author_name, author_avatar, content, timestamp }. No JOINs needed. Access pattern: "Get latest 50 posts for user X" (simple, fast). Trade-off: Data duplication (author name duplicated in millions of posts), eventual consistency (post count might be briefly inaccurate). Implementation: Cassandra cluster with 100+ nodes, partitioned by user_id. Scale: Add nodes linearly (3 nodes → 30 nodes → 300 nodes). (c) REAL-TIME MESSAGING - Use NoSQL (Redis + Cassandra). Reasoning: Redis for online/active messages (low latency <1ms): Store online users (SET), Store unread message count (COUNTER), Store typing indicators (EXPIRE after 5s). Cassandra for message history (durable storage): Store all messages (billions of messages). Query: "Get last 100 messages for conversation X". Partition by conversation_id. Why not SQL: Message volume too high for SQL (billions of messages). Need horizontal scaling. Queries are simple (no complex JOINs needed). Trade-off: Two-database complexity (Redis for real-time, Cassandra for history). Eventual consistency (message might appear on sender\'s device before recipient, but acceptable). Result: SQL for critical user data (ACID), Cassandra for scale (posts, messages), Redis for real-time (online status).',
    keyPoints: [
      'User accounts: SQL (ACID, data integrity, complex queries)',
      'Posts/feeds: Cassandra (massive scale, denormalized, horizontal scaling)',
      'Real-time messaging: Redis (low latency) + Cassandra (message history)',
      'Polyglot persistence: Use multiple databases for different needs',
      'SQL for consistency, NoSQL for scale and flexibility',
    ],
  },
  {
    id: 'q2',
    question:
      'Compare the challenges and approaches for scaling a SQL database (PostgreSQL) vs a NoSQL database (Cassandra) from 1,000 to 10 million users.',
    sampleAnswer:
      'Scaling SQL vs NoSQL from 1K to 10M users: POSTGRESQL (SQL) SCALING CHALLENGES: Stage 1 (1K-100K users): Single server with 16GB RAM, 8 cores. Vertical scaling: Upgrade to 64GB RAM, 32 cores ($500/month). Read replicas: Add 3-5 read replicas for read scaling. Query optimization: Add indexes, optimize slow queries. Result: Handles 100K users comfortably. Stage 2 (100K-1M users): Vertical scaling limits: Primary at 128GB RAM, 64 cores ($5,000/month). Read replicas: 10-20 replicas for read scaling. Caching: Add Redis for frequent queries. Connection pooling: PgBouncer to manage connections. Write scaling challenge: Single primary is bottleneck. All writes go to one server. Approaching limits (10,000 writes/sec maximum). Stage 3 (1M-10M users): SHARDING REQUIRED (complex!): Partition data by user_id ranges: Shard 1: users 1-1M, Shard 2: users 1M-2M, etc. Each shard: Primary + read replicas. Application logic: Route queries to correct shard. Challenges: Cross-shard queries: "Top 10 users globally" requires querying all shards + merge. Rebalancing: Adding shards requires migrating data. Transactions: Cross-shard transactions complex (distributed transactions). Complexity: High. Requires custom sharding logic or tools (Citus, Vitess). Cost: 10 shards × $500/month (primary) = $5,000/month + replicas. CASSANDRA (NoSQL) SCALING: Stage 1 (1K-100K users): Cassandra cluster: 3 nodes (minimum), 16GB RAM each. Replication factor: 3 (data replicated to 3 nodes). Result: Handles 100K users easily. Cost: 3 nodes × $120/month = $360/month. Stage 2 (100K-1M users): Add nodes: 3 nodes → 10 nodes (automatic rebalancing). Linear scaling: 10x nodes = 10x capacity. No code changes: Cassandra handles distribution automatically. Cost: 10 nodes × $120/month = $1,200/month. Stage 3 (1M-10M users): Add more nodes: 10 nodes → 50 nodes. Automatic rebalancing: Data redistributed across nodes. No sharding logic: Cassandra handles partitioning by partition key. Queries remain simple: "Get posts by user_id" works same on 3 nodes or 50 nodes. Cost: 50 nodes × $120/month = $6,000/month. COMPARISON: PostgreSQL: $5,000/month (10 shards) + high complexity (sharding logic). Cassandra: $6,000/month (50 nodes) + low complexity (built-in sharding). OPERATIONAL COMPLEXITY: PostgreSQL: Manual sharding: Write and maintain sharding logic. Cross-shard queries: Complex aggregations. Rebalancing: Manual data migration when adding shards. Expertise required: Database sharding expertise rare and expensive. Cassandra: Add nodes: Simple (cassandra-stress, nodetool). Rebalancing: Automatic (Cassandra handles). Queries: Same query works regardless of node count. Trade-off: Must design for Cassandra\'s limitations (no JOINs, eventual consistency). WINNER: For 10M users: Cassandra easier to scale horizontally. SQL requires complex sharding for write scaling. Cassandra built for horizontal scaling from day 1. Recommendation: Start with SQL for simplicity (< 1M users). Migrate to NoSQL when hitting scaling limits (> 1M users and growing fast).',
    keyPoints: [
      'SQL: Vertical scaling + read replicas work until ~1M users',
      'SQL: Requires complex manual sharding for write scaling beyond 1M users',
      'NoSQL (Cassandra): Built-in horizontal scaling, add nodes linearly',
      'NoSQL: Lower operational complexity at scale (automatic sharding)',
      'Trade-off: SQL gives ACID and complex queries, NoSQL gives easier scaling',
    ],
  },
  {
    id: 'q3',
    question:
      'You have an e-commerce system currently using MongoDB for everything (products, orders, payments). You are experiencing data consistency issues with payments. How would you refactor the architecture?',
    sampleAnswer:
      'Refactoring MongoDB-only e-commerce for data consistency: CURRENT PROBLEM: MongoDB for everything: Products, orders, payments all in MongoDB. Payment consistency issues: Double-charging (payment processed twice). Lost payments (payment succeeded but order not created). Inventory overselling (two users buy last item). Root cause: MongoDB lacks multi-document ACID transactions (until v4.0, and even then limited). Eventual consistency causes race conditions. REFACTORED ARCHITECTURE (Polyglot Persistence): POSTGRESQL FOR CRITICAL TRANSACTIONAL DATA: (1) Payments table: Track all payment attempts, statuses, and outcomes. ACID transactions ensure exactly-once payment processing. (2) Orders table: Order creation and payment processing in single transaction: BEGIN TRANSACTION, CREATE order, PROCESS payment, UPDATE inventory, COMMIT (all succeed or all rollback). (3) Inventory table: Strong consistency prevents overselling. Row-level locking during checkout. (4) Users table: User accounts, authentication, balances. Implementation: PostgreSQL primary (writes) + read replicas (reads). ACID transactions for: Order creation + payment, Inventory reservation, Refunds. MONGODB FOR NON-CRITICAL FLEXIBLE DATA: (1) Products catalog: Product details (varying attributes by category). Product descriptions, images, specifications. Flexible schema (electronics have different fields than clothing). Read-heavy (millions of product views, few updates). (2) Product reviews: User-generated content. Flexible structure (text, images, videos). Eventual consistency acceptable (review appears in 1-2 seconds). (3) User browsing history: Flexible schema, non-critical data. (4) Search index: Denormalized product data for search. Eventual consistency fine (search results slightly stale acceptable). REDIS FOR CACHING & SESSIONS: (1) Shopping cart: Temporary data (cart items before checkout). Fast access (<1ms). (2) Session storage: User sessions. (3) Product cache: Cache hot products (top 1000 products). MIGRATION PLAN: Phase 1: Set up PostgreSQL cluster. Phase 2: Migrate payments & orders to PostgreSQL (critical first). Deploy code changes: Orders use PostgreSQL transactions. Test extensively: Simulate concurrent orders, payment failures. Phase 3: Migrate inventory to PostgreSQL (prevent overselling). Phase 4: Keep products in MongoDB (working well, no changes needed). RESULT: Payments & orders: Strong consistency (ACID), no double-charging. Inventory: Strong consistency, no overselling. Products & reviews: Flexible schema, good performance. TRADE-OFFS: Complexity: Two databases to manage (PostgreSQL + MongoDB). But: Correct tool for each job. More operational complexity but better reliability. ALTERNATIVE (if MongoDB v4.2+): Use MongoDB multi-document transactions for payments. Still not as robust as PostgreSQL for financial data. Not recommended for critical financial transactions.',
    keyPoints: [
      'Move critical transactional data (payments, orders, inventory) to PostgreSQL',
      'Keep flexible, non-critical data (products, reviews) in MongoDB',
      'Use ACID transactions for payment processing (prevent double-charging)',
      'Polyglot persistence: Right database for each use case',
      "Trade complexity for correctness (can't afford payment errors)",
    ],
  },
];
