/**
 * Quiz questions for Monolith vs Microservices section
 */

export const monolithvsmicroservicesQuiz = [
  {
    id: 'q1',
    question:
      'Your startup has 10 developers and is building an e-commerce platform. Should you use a monolithic or microservices architecture? Justify your decision and explain when you might reconsider.',
    sampleAnswer:
      'Startup architecture decision (10 developers, e-commerce): RECOMMENDATION: Start with MONOLITH. REASONING: Team Size: 10 developers is too small for microservices. Microservices overhead: Each service needs API, deployment pipeline, monitoring, logging. With 10 services, spend more time on infrastructure than features. Monolith overhead: Simple deployment, one codebase, easy to navigate. Requirements Uncertainty: Early stage, requirements will change frequently. Monolith easier to refactor (no API contracts between services). Example: Decide to merge "cart" and "checkout" → Simple in monolith, painful in microservices. Development Speed: Need to move fast, validate product-market fit. Monolith: Add feature in one codebase, deploy immediately. Microservices: Create new service, deploy, integrate → Slower. Operational Simplicity: Small team, can\'t afford dedicated DevOps. Monolith: Deploy one app to Heroku/AWS. Microservices: Need Kubernetes, service mesh, distributed tracing → Too complex. IMPLEMENTATION: Single codebase (Ruby on Rails, Django, Node.js + Express). Organized by modules: app/users/, app/products/, app/orders/. Prepare for future: Design with bounded contexts in mind (separate user logic from product logic). Single database (PostgreSQL). Horizontal scaling: Run multiple instances behind load balancer. WHEN TO RECONSIDER (Migrate to Microservices): (1) Team grows beyond 50 developers: Multiple teams stepping on each other in monolith codebase. Deployment coordination becomes bottleneck. Time to extract services for team autonomy. (2) Scaling challenges: One component (e.g., product search) needs 10x more resources than others. Can\'t scale entire monolith economically. Extract search into separate service. (3) Technology needs: Need to use specialized technology (e.g., Elasticsearch for search, ML in Python for recommendations). Can\'t integrate into monolith easily. Extract as separate services. (4) High availability requirements: Payment processing needs 99.99% uptime. Isolate in separate service so other components can be deployed without affecting payments. MIGRATION STRATEGY (when time comes): Use Strangler Fig pattern: Year 1-2: Monolith works great. Year 2-3: Team 50+, extract first service (e.g., Payment). Year 3-4: Extract more services as needed (Search, Recommendations). Result: Hybrid architecture (core monolith + strategic microservices). COST COMPARISON: Monolith: 1 deployment, 1 monitoring system, simple. Cost: $500/month infrastructure + low ops overhead. Microservices (premature): 10 services, Kubernetes, monitoring, tracing. Cost: $5,000/month infrastructure + high ops overhead. 10x more expensive with no benefit at 10 devs!',
    keyPoints: [
      'Start with monolith for small team (< 20 devs), faster development',
      'Microservices premature at 10 devs: High complexity, low benefit',
      'Migrate to microservices when team grows (50+ devs) or scaling needs arise',
      'Use Strangler Fig pattern for incremental migration (not big bang rewrite)',
      'Hybrid approach: Core monolith + strategic microservices',
    ],
  },
  {
    id: 'q2',
    question:
      'Explain the trade-offs between monolithic and microservices architectures for data consistency. How would you handle an order placement that requires updating inventory, processing payment, and creating an order record?',
    sampleAnswer:
      'Data consistency: Monolith vs Microservices for order placement. SCENARIO: User places order → Must: (1) Create order record, (2) Process payment, (3) Reduce inventory. All must succeed or all must fail (atomicity). MONOLITHIC APPROACH: Single database, ACID transactions. Implementation: BEGIN TRANSACTION; INSERT INTO orders (user_id, total) VALUES (101, 299.99); UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 501; INSERT INTO payments (order_id, amount, status) VALUES (123, 299.99, "success"); COMMIT; Advantages: ✅ Atomicity: All succeed or all rollback (strong consistency). ✅ Simple: One transaction, familiar SQL. ✅ Immediate consistency: No eventual consistency issues. ✅ Easy rollback: Database handles everything. Disadvantages: ❌ Tight coupling: All data in one database. ❌ Scalability limits: Single database bottleneck. ❌ Can\'t scale components independently. MICROSERVICES APPROACH: Order Service, Payment Service, Inventory Service (separate databases). Problem: No distributed transactions! Can\'t do: BEGIN TRANSACTION; Call Payment Service; Call Inventory Service; COMMIT; -- Doesn\'t work across services. SOLUTION 1: SAGA PATTERN (Orchestration). Saga Orchestrator: 1. Call Order Service → Create order (status: pending). 2. Call Payment Service → Process payment. 3. If payment succeeds → Call Inventory Service → Reduce inventory. 4. If all succeed → Update order (status: confirmed). If any step fails → Execute compensating transactions: If payment fails: Cancel order (DELETE order). If inventory fails: Refund payment (call Payment Service refund API). Cancel order. Implementation: class OrderSaga { async placeOrder(userId, productId, amount) { const order = await orderService.create({userId, productId, amount, status: "pending"}); try { const payment = await paymentService.charge({orderId: order.id, amount}); await inventoryService.reduceStock({productId, quantity: 1}); await orderService.updateStatus(order.id, "confirmed"); return {success: true, orderId: order.id}; } catch (error) { // Compensating transactions if (payment && payment.success) { await paymentService.refund(payment.id); } await orderService.cancel(order.id); return {success: false, error: error.message}; } } }. Advantages: ✅ Independent services: Each service has own database, scales independently. ✅ Fault isolation: Payment service down doesn\'t crash inventory service. ✅ Flexibility: Services can use different databases (Payment: PostgreSQL, Inventory: MongoDB). Disadvantages: ❌ Eventual consistency: Brief window where order exists but payment pending. ❌ Compensating transactions: Must implement refund/cancel logic manually. ❌ Complexity: More code, more failure modes. ❌ Partial failures: Order created but payment fails → Must handle. SOLUTION 2: SAGA PATTERN (Choreography with Events). Event-driven approach (using Kafka): 1. Order Service publishes "order.created" event. 2. Payment Service consumes event → Processes payment → Publishes "payment.success" or "payment.failed". 3. Inventory Service consumes "payment.success" → Reduces stock → Publishes "inventory.updated". 4. Order Service consumes events → Updates order status. Compensation: If Payment Service publishes "payment.failed", Order Service cancels order. If Inventory Service publishes "inventory.insufficient", Payment Service refunds. Advantages: ✅ Loose coupling: Services don\'t call each other directly. ✅ Scalability: Event-driven, async processing. Disadvantages: ❌ Hard to trace: Event flow across services complex. ❌ Eventual consistency: Order might show "pending" for seconds. COMPARISON: Monolith: Immediate consistency (ACID), simple, but limited scalability. Microservices: Eventual consistency (Saga), complex, but scales and isolates failures. RECOMMENDATION: For critical transactions (order placement): Microservices worth complexity at scale (1000+ orders/sec, 50+ devs). For small scale (< 100 orders/sec, < 20 devs): Monolith simpler. HYBRID APPROACH: Keep order placement in monolith (ACID transactions). Extract non-critical services (recommendations, reviews) as microservices.',
    keyPoints: [
      'Monolith: ACID transactions ensure atomicity (all succeed or fail)',
      'Microservices: No distributed transactions, use Saga pattern',
      'Saga pattern: Orchestration (coordinator) or Choreography (events)',
      'Compensating transactions: Manually undo failed steps (refund payment)',
      'Trade-off: Monolith simpler (strong consistency) vs Microservices scalable (eventual consistency)',
    ],
  },
  {
    id: 'q3',
    question:
      'Your company has a monolithic application with 100 developers, and deployments take 2 hours with frequent failures. How would you migrate to microservices? What services would you extract first and why?',
    sampleAnswer:
      "Monolith to Microservices migration strategy (100 devs, 2-hour deploy): CURRENT PROBLEMS: 100 developers in single codebase: Merge conflicts, coordination overhead, slow development. 2-hour deployments: Deploy entire app for small change, high risk. Deployment failures: One bug crashes entire app. MIGRATION STRATEGY: Use STRANGLER FIG PATTERN (incremental, not rewrite). PHASE 1: IDENTIFY SERVICE BOUNDARIES (Bounded Contexts). Analyze monolith modules: Users, Products, Orders, Payments, Inventory, Recommendations, Search. Identify dependencies: Which modules depend on which? Find leaf dependencies (modules with no dependents) → Extract first. PHASE 2: PRIORITIZE SERVICES TO EXTRACT (Order matters!). Criteria: (1) High change frequency (lots of deploys), (2) Different scaling needs, (3) Team ownership clear, (4) Leaf dependencies (few dependencies). FIRST SERVICE: PAYMENT (High value, clear boundary). Why Payment first: High availability requirement: Payment must be 99.99% uptime. Isolate from other deploys. Compliance: PCI-DSS compliance easier with separate service. Clear boundary: Input (order, amount), Output (payment status). Small team ownership: 5-person team owns payments. Leaf dependency: Other services depend on it, but it depends on external API (Stripe) only. Migration steps: Week 1-2: Create Payment Service (duplicate payment logic from monolith). Week 3-4: Dual write (write to both monolith and new service). Week 5-6: Verify consistency, switch reads to new service. Week 7-8: Remove payment code from monolith. Result: Payments isolated, can deploy independently. Payment team deploys 10x/day without affecting others. SECOND SERVICE: SEARCH (Different tech stack). Why Search second: Different technology: Need Elasticsearch (can't integrate into monolith easily). High traffic: Search is 50% of traffic, needs independent scaling. Clear interface: Input (query), Output (results). Leaf dependency: Other services call search, search depends on product data (read-only). Migration: Create Search Service with Elasticsearch. Index product data from monolith (sync via events or periodic batch). Route search queries to new service. Scale search independently (10 instances vs 3 for monolith). THIRD SERVICE: RECOMMENDATIONS (ML, Python). Why Recommendations third: Different tech stack: ML in Python, monolith in Java. Resource intensive: ML training needs GPU, don't want in monolith. Clear boundary: Input (user_id), Output (recommended products). Can fail gracefully: If recommendations down, show popular products instead. FOURTH SERVICE: INVENTORY. Why Inventory fourth: High change frequency: Inventory updated frequently (order placed, restock). Different scaling: Inventory queries are frequent. Clear domain: Product quantities, warehouse management. SUBSEQUENT SERVICES: User Service, Order Service, Product Service (as needed). WHAT NOT TO EXTRACT: Core business logic that's stable and low- change: Keep in monolith.Tightly coupled modules: Keep together(extracting would require too many API calls).RESULT AFTER 12 MONTHS: Monolith: 50 % original size(Users, Orders, Products).Microservices: Payment, Search, Recommendations, Inventory(4 services).Benefits: Payment team deploys 20x / day(was 1x / week).Search scaled to 20 instances(was 3).Recommendations uses Python + ML(was impossible in Java monolith).Overall deployment frequency: 5x / week(was 1x / week).METRICS: Deployment time: 2 hours → 15 minutes(microservices deploy fast).Deployment success rate: 70 % → 95 % (smaller changes, less risk).Developer productivity: 100 devs in monolith(conflicts) → Teams own services(autonomy).Cost: Infrastructure: $10K / month(monolith) → $15K / month(monolith + 4 services).Ops overhead: Need Kubernetes, monitoring, tracing(worth it at 100 devs).",
    keyPoints: [
      'Use Strangler Fig pattern: Incremental extraction (not rewrite)',
      'Extract services in order: Payment (high availability), Search (different tech), Recommendations (ML)',
      'Start with leaf dependencies: Services with few dependencies first',
      "Keep core business logic in monolith: Don't over-extract",
      'Result: Hybrid architecture, faster deployments, team autonomy',
    ],
  },
];
