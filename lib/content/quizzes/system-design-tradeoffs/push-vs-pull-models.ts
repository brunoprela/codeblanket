/**
 * Quiz questions for Push vs Pull Models section
 */

export const pushvspullmodelsQuiz = [
  {
    id: 'q1',
    question:
      "You are designing a notification system for a social media app. Should you use push or pull? What about for loading the user's timeline/feed?",
    sampleAnswer:
      'Social media notification and feed design: NOTIFICATIONS - Use PUSH. Reasoning: Real-time requirement: Users expect instant notifications (new comment, like, message). Low latency critical: <1 second from event to notification. User experience: Push notifications wake app even when closed. Battery efficiency: Single persistent connection for all notifications (FCM/APNS). Implementation: Server → Firebase Cloud Messaging (FCM) / Apple Push Notification Service (APNS) → Mobile device. When user likes post: Backend publishes event, Notification service sends push to post author, Mobile OS delivers notification (even if app closed). Advantages: Instant delivery (<1 second latency). Works when app closed. Battery efficient (OS manages connection). Disadvantages: Requires persistent infrastructure (FCM/APNS). Cannot guarantee delivery (users can disable). Cost: FCM free, APNS free. Server infrastructure: $100/month (notification service). TIMELINE/FEED - Use PULL (with optional push for new content indicator). Reasoning: Bulk content: Timeline contains 50+ posts with images/videos (large payload). On-demand: User opens app when they want (not time-critical like notifications). Offline capability: Can cache and show stale feed (acceptable UX). Scalability: Pull scales better (stateless HTTP requests). Implementation: User opens app → GET /feed → Server fetches latest 50 posts → Return JSON. User scrolls → GET /feed?offset=50 → Next 50 posts (pagination). User pull-to-refresh → GET /feed → Latest posts. Advantages: Stateless (any server can handle request). Scales horizontally (load balancer distributes). Works offline (cached feed). Efficient for bulk data. Disadvantages: Not real-time (latency = time since last refresh). Must implement pull-to-refresh UX. OPTIMIZATION: Push indicator for new content: Server pushes lightweight notification "5 new posts available" → Client shows blue dot/badge. User pulls to refresh → Fetches new posts. Benefit: Combines push (real-time awareness) + pull (efficient bulk fetch). COMPARISON: Facebook approach: Notifications: Push (instant). Feed: Pull (on app open) + push indicator ("New posts available"). Result: Real-time for critical updates, efficient for bulk content.',
    keyPoints: [
      'Notifications: Push (real-time, <1s latency, wakes app)',
      'Timeline/feed: Pull (bulk content, stateless, scales better)',
      'Hybrid optimization: Push indicator for new content ("5 new posts")',
      'Push via FCM/APNS (battery efficient, OS-managed)',
      'Pull via standard HTTP (scalable, works offline with cache)',
    ],
  },
  {
    id: 'q2',
    question:
      "Compare push and pull approaches for Twitter\'s feed generation at scale (300M users, 500M tweets/day). How would you handle users with millions of followers?",
    sampleAnswer:
      "Twitter feed generation at scale - Push vs Pull: SCALE: 300M users, 500M tweets/day, some users have 100M+ followers. PUSH APPROACH (Fan-out on Write): When user tweets: Write tweet to database. For each follower: INSERT INTO timeline (follower_id, tweet_id, author_name, content, timestamp). Example: Regular user (1,000 followers) tweets → 1,000 timeline writes. Celebrity (100M followers) tweets → 100M timeline writes (!). When user opens timeline: SELECT * FROM timeline WHERE follower_id = user_id ORDER BY timestamp DESC LIMIT 50. Fast read (single query, pre-computed). Advantages: ✅ Fast reads (<10ms, just SELECT from pre-computed timeline). ✅ Timeline always ready (no computation on read). ✅ Good for users with few followers. Disadvantages: ❌ Expensive writes for celebrities: Taylor Swift (200M followers) tweets → 200M writes. At 500M tweets/day, if 1% from celebrities = 5M celebrity tweets. 5M × 100M average = 500 BILLION writes/day. Impossible! ❌ Wasted work: Inactive users get timeline updates they never read. PULL APPROACH (Fan-out on Read): When user tweets: Write tweet to database (single INSERT). When user opens timeline: SELECT * FROM tweets WHERE author_id IN (SELECT following_id FROM follows WHERE follower_id = user_id) ORDER BY timestamp DESC LIMIT 50. Compute timeline on demand (join tweets from all followed users). Advantages: ✅ Efficient writes (1 write per tweet regardless of followers). ✅ No wasted work (only compute for active users). ✅ Always up-to-date (no stale pre-computed timelines). Disadvantages: ❌ Slow reads: User follows 1,000 people → Query 1,000 users' tweets. Complex aggregation, sorting, ranking. ❌ High read load: 300M users opening feed → 300M complex queries. ❌ Timeline computation expensive (10-100ms+ per feed load). TWITTER'S HYBRID SOLUTION: Segment users by follower count: REGULAR USERS (<10,000 followers): Use PUSH (fan-out on write). User tweets → Write to all followers' timelines. Followers see tweet instantly. Cost: Manageable (most users have <1,000 followers). CELEBRITIES (>10,000 followers): Use PULL (fan-out on read). User tweets → Write tweet only (no fan-out). When follower opens feed: Fetch celebrity tweets on demand. Merge with pre-computed regular timeline. TIMELINE GENERATION (Hybrid): SELECT * FROM timeline WHERE user_id = X LIMIT 50 (pre-computed from regular users). UNION. SELECT * FROM tweets WHERE author_id IN (celebrity_ids_followed_by_X) LIMIT 10 (pulled on demand). ORDER BY timestamp LIMIT 50. Result: Fast for most content (pre-computed), acceptable for celebrity content (pulled). IMPLEMENTATION DETAILS: Write path: If author followers < 10,000: Fan-out (async workers write to timelines). If author followers >= 10,000: No fan-out (just write tweet). Read path: Fetch pre-computed timeline (fast). If user follows celebrities: Pull celebrity tweets (additional query). Merge, rank, return. PERFORMANCE: Writes: Regular user tweet: 1,000 writes (fan-out). Celebrity tweet: 1 write (no fan-out). Reads: Timeline load: 10-50ms (mostly pre-computed, some pulled). SCALE NUMBERS: Regular tweets (99%): 495M/day, avg 1,000 followers = 495B writes (manageable with async workers). Celebrity tweets (1%): 5M/day, no fan-out = 5M writes. Total writes: 495B writes (spread over 24 hours = 5.7M writes/sec, distributed across clusters). Reads: 300M users, 10 timeline loads/day = 3B reads/day = 35K reads/sec (easily handled). RESULT: Hybrid approach scales Twitter to billions of writes and reads per day.",
    keyPoints: [
      'Push (fan-out on write): Fast reads but expensive writes for celebrities',
      'Pull (fan-out on read): Efficient writes but slow/expensive reads',
      'Hybrid: Push for regular users (<10K followers), pull for celebrities',
      'Merge pre-computed timelines with on-demand celebrity tweets',
      'Scales to 500M tweets/day and 300M users',
    ],
  },
  {
    id: 'q3',
    question:
      'Design a CDN caching strategy using origin pull vs origin push. When would you use each approach?',
    sampleAnswer:
      "CDN caching: Origin Pull vs Origin Push strategies. ORIGIN PULL (Default, More Common): How it works: User requests file from CDN edge server (e.g., cdn.example.com/logo.png). Edge server checks local cache: If HIT → Return file immediately (fast, <10ms). If MISS → Pull from origin server → Cache locally → Return file (slower, 100-500ms). Future requests: Served from cache (fast). Cache expiration: TTL (Time To Live) determines how long file cached (e.g., 1 day). ADVANTAGES: ✅ Automatic caching: Only cache what's actually requested (no wasted storage). ✅ Simple setup: Point CDN to origin, configure TTL. ✅ Efficient: Unpopular files not cached (save edge server storage). ✅ Always up- to - date: Cache expires based on TTL.DISADVANTAGES: ❌ First request slow: Cache miss means pulling from origin(100 - 500ms). ❌ Origin load: Origin must serve cache misses. ❌ Unpredictable: First user after cache expiry gets slow response.USE CASES FOR ORIGIN PULL: Website assets: Images, CSS, JavaScript for normal websites.Long - tail content: Millions of images, most rarely accessed.User - generated content: Photos, videos uploaded by users (don't know what will be popular). API responses: Cacheable API responses (with appropriate Cache-Control headers). EXAMPLE: Image hosting site (like Imgur): 10M images, each accessed 0-1000x. Use origin pull: Only cache images that are actually requested. Popular images: Cached on all edges (fast). Unpopular images: Only on origin or few edges (save storage). ORIGIN PUSH (Pre-Warming): How it works: Developer uploads file to CDN. CDN pushes file to ALL edge servers worldwide. File immediately available on all edges (no cache miss). No connection to origin server after push. ADVANTAGES: ✅ No cache misses: File available everywhere immediately. ✅ Predictable performance: Always fast (no slow first request). ✅ Reduced origin load: Origin doesn't serve requests (CDN only). ✅ Control: Explicitly control what's cached and where. DISADVANTAGES: ❌ Manual deployment: Must upload files explicitly (not automatic). ❌ Wasted storage: All files on all edges (even if unused). ❌ Stale content risk: Must manually invalidate/update files. ❌ Cost: More storage used (all files on all edges). USE CASES FOR ORIGIN PUSH: Product launches: New iPhone announced → Push product images to all edges (ensure availability). Critical assets: Logo, homepage CSS/JS that ALL users need (pre-warm). Software downloads: New app version → Push to all edges (handle download spike). Live events: Super Bowl ads → Pre-push videos before game (avoid cache misses). EXAMPLE: Apple product launch: iPhone announcement → Push all product images, videos to CDN edges. Millions of users access simultaneously → All served from cache (no origin load). HYBRID STRATEGY: Use BOTH: ORIGIN PULL (Default): All website assets (images, CSS, JS). Automatic caching, simple to manage. ORIGIN PUSH (Strategic): Homepage hero image → Push before product launch. Critical JavaScript bundle → Push on deploy. Product launch assets → Push 1 hour before announcement. CACHE INVALIDATION: Origin Pull: Set short TTL (e.g., 5 minutes) for frequently changing content. Purge cache via CDN API when content updated. Origin Push: Manually upload new version with new filename (cache busting). Use versioned URLs: logo-v2.png instead of logo.png. REAL-WORLD EXAMPLE (E-commerce site): ORIGIN PULL: Product images (millions of products). User-uploaded reviews photos. Category thumbnails. CDN automatically caches popular products (long tail not cached). ORIGIN PUSH: Homepage hero banner (everyone sees this). Site logo, main CSS/JS bundle. Flash sale banners (push at sale start time). Black Friday landing page (push 1 hour before sale). RESULT: 99% of content: Origin pull (automatic, efficient). 1% of content: Origin push (critical, pre-warmed). Best of both worlds: Automatic caching + guaranteed availability for critical assets.",
    keyPoints: [
      "Origin pull: Automatic caching, only cache what's requested (default for most content)",
      'Origin push: Pre-warm cache, no cache misses (for critical assets, launches)',
      'Pull advantages: Simple, efficient storage, long-tail friendly',
      'Push advantages: Predictable performance, no cache misses',
      'Hybrid: Pull for most content, push for critical/launch assets',
    ],
  },
];
