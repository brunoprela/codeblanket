/**
 * Quiz questions for Systematic Problem-Solving Framework section
 */

export const systematicframeworkQuiz = [
  {
    id: 'q1',
    question:
      'Walk through the complete 4-step framework for designing Instagram, spending appropriate time on each step and showing what you would cover.',
    sampleAnswer:
      'DESIGNING INSTAGRAM - 4-STEP FRAMEWORK (45-60 min total): STEP 1: REQUIREMENTS & SCOPE (5-10 min): Functional Requirements: "Should we focus on: Photo upload/sharing (core), Stories (24hr expiration), Reels (short videos), Direct messaging, Likes/comments?" Assume: Core photo sharing + likes + comments + follow. Non-Functional Requirements: Scale: "How many DAU?" Assume 500M DAU. Upload rate: "Photos per user per day?" Assume 0.5 photos/day = 250M uploads/day. View rate: "Photos viewed per user?" Assume 100 views/day = 50B views/day. Storage: Average photo 2MB. Performance: Upload <3sec, view <200ms. Availability: 99.9% (social media, not critical). Consistency: Eventual (like counts can be delayed). Assumptions stated: 500M DAU, 250M photos/day, 50B views/day, 2MB avg photo, eventual consistency OK. Out of scope: Recommendations, ads, stories, video. (Time: 8 min) STEP 2: HIGH-LEVEL DESIGN (10-15 min): Back-of-envelope: Storage: 250M × 2MB = 500 TB/day = 180 PB/year. Traffic: Upload QPS: 250M/86K = 3K writes/sec. View QPS: 50B/86K = 580K reads/sec (200:1 ratio, read-heavy). Bandwidth: 580K × 2MB = 1.2 TB/sec = 9.6 Tbps (need CDN!). Core Components: (1) Clients (mobile/web), (2) Load Balancer, (3) API Servers, (4) Object Storage (S3), (5) Metadata DB (Cassandra - high writes), (6) Cache (Redis - hot photos), (7) CDN (CloudFront - photo delivery), (8) Message Queue (Kafka - async processing). Key APIs: POST /photos {user_id, image_data} → {photo_id, cdn_url}, GET /feed/:user_id → {photos:[]}, POST /like {user_id, photo_id}, GET /photo/:id → redirect to CDN. Database Schema: Users: user_id, username, ... Photos: photo_id, user_id, cdn_url, created_at. Likes: user_id, photo_id, created_at. Follows: follower_id, followee_id. Data Flow: Upload: Client → API → Compress → Upload to S3 → Store metadata in Cassandra → Return CDN URL. View: Client → CDN (cache hit) → Done. If miss, fetch from S3. Diagram drawn on whiteboard showing components and connections. (Time: 20 min total) STEP 3: DEEP DIVE (20-25 min): Interviewer asks: "How do you generate the user feed?" FEED GENERATION DEEP DIVE: Option 1 - Pull (Fanout on Read): When user requests feed: Query all photos from users they follow (last 7 days), Sort by timestamp, Return top 50. Pros: Simple writes (just store photo). Cons: Slow reads (query 1000 users if following 1000 people), Expensive for users who follow many. Option 2 - Push (Fanout on Write): When user posts photo: Write photo_id to all followers\' pre-computed feeds (Redis list per user). Feed request: Just read from Redis list (pre-sorted). Pros: Fast reads (O(1) lookup). Cons: Slow writes (if user has 10M followers, write to 10M feeds), Storage expensive (pre-compute all feeds). HYBRID APPROACH (chosen): Regular users (<10K followers): Push model. Celebrities (>10K followers): Pull model. Feed generation: Fetch pre-computed feed (push), Fetch photos from celebrities (pull), Merge, sort, cache for 5 min. Handles: 99% users with push (fast reads), 1% celebrities with pull (manageable writes). Interviewer: "How do you handle storage at this scale?" STORAGE DEEP DIVE: 180 PB/year → Can\'t fit on single system. Solution: Distributed object storage (S3 or similar). Optimization: Multiple storage tiers: Hot (recent, SSD, CDN edge): Last 30 days, Warm (HDD, S3 Standard): 30 days - 1 year, Cold (Glacier): >1 year. Compression: Serve multiple resolutions (thumbnail, medium, full), Generate on upload, Store all versions. Deduplication: Hash each photo (MD5), If duplicate, reference existing (save storage). (Time: 45 min total) STEP 4: WRAP UP (5 min): Failure scenarios: CDN down → Serve from S3 directly (slower), S3 region down → Multi-region replication, API server down → Load balancer routes to healthy servers. Monitoring: Upload success rate, View latency (p99), CDN hit rate, Storage costs. Bottlenecks: Write QPS approaching Cassandra limits → Shard by user_id, CDN bandwidth during viral posts → Auto-scale edge servers. Trade-offs made: Eventual consistency → Better availability, Hybrid feed → Balance read/write performance, Multi-tier storage → Cost optimization. (Time: 50 min total) ✅ FRAMEWORK DEMONSTRATED: Requirements clarified, High-level architecture designed, Deep dove into 2 critical components (feed, storage), Discussed failures, monitoring, trade-offs. (Time: 50 minutes, within 45-60 min window)',
    keyPoints: [
      'Step 1 (5-10 min): Clarify functional/non-functional requirements, state assumptions',
      'Step 2 (10-15 min): Calculate scale, design high-level architecture, define APIs/schema',
      'Step 3 (20-25 min): Deep dive into 2-3 critical components with trade-offs',
      'Step 4 (5 min): Discuss failures, monitoring, bottlenecks, optimizations',
      'Total time: 45-60 min, proportional allocation is key',
    ],
  },
  {
    id: 'q2',
    question:
      "You're 30 minutes into a design interview and realize you've spent too much time on requirements and high-level design. You haven't done any deep dive yet. How do you recover?",
    sampleAnswer:
      'TIME MANAGEMENT RECOVERY STRATEGY: ACKNOWLEDGE THE SITUATION (1 min): "I realize I\'ve spent more time than planned on the high-level design. Let me quickly transition to deep diving into the most critical components. We have about 25-30 minutes left - I\'d like to focus on [X and Y]. Does that sound good?" Why this works: (1) Shows self-awareness (you track time), (2) Explicitly transitions (clear signal), (3) Gets interviewer buy-in (collaborative). PRIORITIZE RUTHLESSLY (immediate): Identify 1-2 MOST CRITICAL components to deep dive. Ask interviewer: "Would you like me to focus on the database sharding strategy or the caching layer? Or both briefly?" Let them guide what they care about most. ACCELERATE THE DEEP DIVE (20-25 min): Focus on: (1) The problem: "At 500K writes/sec, single DB can\'t handle it.", (2) Options: "We have 3 options: sharding, replication, or NoSQL.", (3) Trade-offs: Quick comparison of pros/cons. (4) Decision: "I recommend sharding by user_id because...", (5) Implementation: Specific details. SKIP: Long background explanations, Overexplaining obvious things, Repeating what you already covered. THINK OUT LOUD (entire time): "Let me quickly walk through database sharding... [explain]... Now let me address caching... [explain]..." Keeps energy up, shows you\'re driving forward. WRAP UP EFFICIENTLY (3-5 min): "To wrap up quickly: Key trade-offs: [X vs Y], Bottlenecks: [Z], Monitoring: [metrics], If I had more time, I\'d discuss [A, B]." WHAT NOT TO DO: ❌ Panic or apologize excessively ("I\'m so sorry, I wasted time..."), ❌ Rush through everything superficially (better to go deep on 1 thing), ❌ Ignore the time issue and continue slowly, ❌ Blame the interviewer ("You didn\'t tell me to move on"). PREVENTION (for next time): Set mental checkpoints: "At 10 min, should be done with requirements.", "At 25 min, should be starting deep dive." Actively track time: Glance at clock/watch periodically. Ask for guidance: "I\'ve covered requirements and high-level design. Should I dive deeper into [X]?" REAL EXAMPLE: "I notice we\'re 30 minutes in and I haven\'t deep dived yet. Let me transition now to the database architecture, which I think is the most critical component. We\'ll need sharding to handle 500K writes/sec. Let me walk through the sharding strategy by user_id, how we handle queries across shards, and how we manage hot spots from celebrity users. Then I\'ll briefly touch on caching. Does this prioritization make sense?" Interviewer: "Yes, focus on sharding." [Proceed with focused deep dive] KEY LESSON: Time management is a skill interviewers evaluate. Recovering gracefully shows: (1) Self-awareness, (2) Prioritization ability, (3) Adaptability, (4) Communication. Better to deep dive on 1-2 components well than superficially cover 5 components.',
    keyPoints: [
      "Acknowledge situation explicitly, don't ignore it",
      'Ask interviewer to prioritize: "What should I focus on?"',
      'Deep dive on 1-2 critical components, skip non-essential details',
      'Think out loud, keep energy high, drive forward',
      'Prevention: Set mental checkpoints, track time proactively',
    ],
  },
  {
    id: 'q3',
    question:
      "When doing back-of-envelope calculations in Step 2, you realize the numbers don't justify the distributed system architecture you were planning. How should you handle this?",
    sampleAnswer:
      'HANDLING SCALE MISMATCH - SHOW ADAPTABILITY: SITUATION: You calculated: 10K DAU, 100 tweets/day, 1M tweets/day total = 12 writes/sec, 1.2K reads/sec (100:1 ratio). You were about to propose: Microservices, Kubernetes, Cassandra cluster, Kafka, Redis cluster, Multi-region deployment. Problem: This is MASSIVE over-engineering for 12 writes/sec! THE RIGHT RESPONSE (show intellectual honesty): "Wait, let me reconsider. Looking at my calculations: 12 writes/sec and 1.2K reads/sec. A single PostgreSQL instance can handle 1K writes/sec and 10K reads/sec comfortably. Let me redesign for this actual scale..." Why this is GOOD: (1) Shows you use numbers to inform decisions (not just buzzwords), (2) Demonstrates adaptability (not rigidly attached to preconceived solution), (3) Proves you understand complexity should match requirements, (4) Interviewer sees you reason from first principles. REVISED DESIGN (right-sized): Simple architecture for 10K DAU: (1) Load balancer (2 instances for redundancy), (2) API servers (3-5 instances, horizontally scaled), (3) PostgreSQL (single primary + 2 read replicas), (4) Redis cache (single instance, later cluster), (5) S3 for media storage, (6) CloudFront CDN. Monolith application (not microservices): Simpler, Faster development, Easier debugging, Sufficient for this scale. NO Kubernetes yet: Just Docker + simple orchestration, Saves operational complexity. EXPLAIN MIGRATION PATH: "This architecture works for 10K-1M users. When we hit 1M+ users and 50K+ writes/sec, we\'d migrate to: (1) Shard PostgreSQL (or move to Cassandra), (2) Break into microservices (user service, tweet service, feed service), (3) Add Kafka for event streaming, (4) Deploy Kubernetes for orchestration, (5) Multi-region for global scale. But we don\'t need that complexity today." CONTRAST WITH WRONG RESPONSE: ❌ BAD: Ignore the numbers: "Even though it\'s only 12 writes/sec, we should use Cassandra for future-proofing." Why bad: Over-engineering, ignoring your own calculations. ❌ BAD: Defensively justify: "Well, Cassandra is still better because..." Why bad: Doubling down on wrong decision. ❌ BAD: Quietly continue with distributed system without addressing mismatch. Why bad: Interviewer notices, questions your judgment. THE PRINCIPLE: "I use back-of-envelope calculations to validate my architecture decisions. If the numbers don\'t justify complexity, I simplify. Simple solutions are often better than complex ones." WHAT IMPRESSES INTERVIEWERS: (1) Adapting based on data, (2) Understanding when NOT to use fancy tech, (3) Knowing simple ≠ bad, (4) Planning migration path (shows foresight). REAL SCENARIO: Me: "Wait, at 12 writes/sec, we don\'t need Cassandra. PostgreSQL handles this easily. Let me revise to a simpler architecture..." Interviewer: "Great! I wanted to see if you\'d catch that. Many candidates over-engineer. Walk me through your simplified design." [Proceed with right-sized architecture] OUTCOME: Showed engineering judgment, passed interview. KEY TAKEAWAY: Best engineers: Start simple, scale when needed, Use numbers to justify decisions, Not attached to "cool tech" for its own sake. Interview red flag: Proposing Cassandra + Kafka + Kubernetes for 10K users. Interview green flag: "Actually, a simple monolith with PostgreSQL is perfect for this scale."',
    keyPoints: [
      'Use calculations to validate architecture decisions',
      "If numbers don't justify complexity, simplify the design",
      'Explain when you would scale up (migration path)',
      'Shows engineering judgment: simple when appropriate, complex when needed',
      'Interviewers value knowing when NOT to use distributed systems',
    ],
  },
];
