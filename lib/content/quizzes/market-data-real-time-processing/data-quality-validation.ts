export const dataQualityValidationQuiz = [
  {
    id: 'data-quality-validation-q-1',
    question:
      'Design a real-time data quality validation system that processes 100K ticks/second and detects: (1) Crossed markets, (2) Price spikes (> 5% move), (3) Stale data (> 10s old), (4) Duplicate ticks. Requirements: < 10μs validation latency per tick, zero false positives on legitimate volatility, automatic alerting. Provide architecture and Python implementation.',
    sampleAnswer:
      'Real-time validation system:\n\n**Architecture**: Multi-stage validation pipeline: (1) Fast path (< 5μs): Basic checks (crossed market, negatives, nulls), (2) Statistical path (< 5μs): Price spike detection using rolling window, (3) Async path: Duplicate detection via bloom filter. Total < 10μs for 99% of ticks.\n\n**Implementation**:\n```python\nfrom collections import deque\nimport numpy as np\n\nclass FastValidator:\n    def __init__(self):\n        self.price_windows = {}  # symbol -> deque of last 100 prices\n        self.last_ticks = {}  # symbol -> last tick (for duplicate detection)\n        self.alerts = []\n    \n    def validate(self, tick):\n        # Stage 1: Fast checks (< 2μs)\n        if tick[\"bid\"] > tick[\"ask\"]:\n            return {\"valid\": False, \"error\": \"crossed_market\"}\n        if tick[\"bid\"] <= 0 or tick[\"ask\"] <= 0:\n            return {\"valid\": False, \"error\": \"negative_price\"}\n        \n        # Stage 2: Price spike (< 3μs)\n        symbol = tick[\"symbol\"]\n        if symbol in self.price_windows:\n            window = self.price_windows[symbol]\n            mean = np.mean(window)\n            std = np.std(window)\n            z_score = abs((tick[\"bid\"] - mean) / std) if std > 0 else 0\n            \n            if z_score > 5:  # 5 sigma outlier\n                # Check if legitimate (e.g., earnings announcement)\n                return {\"valid\": True, \"warning\": \"price_spike\", \"z_score\": z_score}\n        \n        # Stage 3: Staleness (< 1μs)\n        age = (time.time() - tick[\"timestamp\"])\n        if age > 10:\n            return {\"valid\": False, \"error\": \"stale_data\"}\n        \n        # Stage 4: Duplicate (< 1μs)\n        if symbol in self.last_ticks and self.last_ticks[symbol] == tick:\n            return {\"valid\": False, \"error\": \"duplicate\"}\n        \n        # Update state\n        if symbol not in self.price_windows:\n            self.price_windows[symbol] = deque(maxlen=100)\n        self.price_windows[symbol].append(tick[\"bid\"])\n        self.last_ticks[symbol] = tick\n        \n        return {\"valid\": True}\n```\n\n**Zero False Positives**: Use z-score threshold of 5 sigma (not 3) for spikes. At 5σ, legitimate volatility (even flash crashes) won\'t trigger. For actual errors, cross-reference with multiple vendors - if all 3 vendors show spike, it\'s real.\n\n**Alerting**: Critical errors (crossed market) → PagerDuty immediately. Warnings (spikes) → Slack channel. Aggregate: If error rate > 1%, alert ops team.',
    keyPoints: [
      'Multi-stage pipeline: Fast checks (2μs) + statistical (3μs) + staleness (1μs) + duplicates (1μs) = 7μs total',
      'Crossed market: Simple comparison bid > ask, instant rejection (0 false positives)',
      'Price spikes: Z-score with 5σ threshold (not 3σ) eliminates false positives on legitimate volatility',
      'Stale detection: Compare timestamp to current time, reject if > 10s old',
      'Performance: 7μs average < 10μs target, 100K ticks/sec = 700ms CPU/sec = 70% single core',
    ],
  },
  {
    id: 'data-quality-validation-q-2',
    question:
      'You receive conflicting quotes from two vendors: IEX shows AAPL bid=$150.24, Polygon shows bid=$150.18 (6¢ difference). How to: (1) Detect conflicts automatically, (2) Determine which vendor is correct, (3) Handle in production without halting trading, (4) Prevent cascading to strategies?',
    sampleAnswer:
      'Vendor conflict resolution:\n\n**Detection**: Compare quotes from all vendors when received. If price difference > 5 bps (basis points), flag as conflict. For AAPL at $150: 5 bps = $0.075. 6¢ difference = 40 bps → conflict detected.\n\n**Determining Correctness**:\n1. **Majority voting**: If 3 vendors available, use majority (2 say $150.24, 1 says $150.18 → $150.24 wins)\n2. **Exchange primary**: Check which is closer to primary exchange (NASDAQ for AAPL). IEX is direct NASDAQ feed, Polygon aggregates multiple exchanges → trust IEX for AAPL\n3. **Volume weighted**: Weight by reported volume at each price. If 5000 shares at $150.24 vs 500 at $150.18 → $150.24 more reliable\n4. **Historical reliability**: Track vendor accuracy over time. If Polygon has 0.1% error rate vs IEX 0.01% → trust IEX\n\n**Production Handling**:\n```python\nclass ConflictResolver:\n    def resolve(self, quotes):\n        if len(quotes) < 2:\n            return quotes[0]  # Single vendor, no conflict possible\n        \n        # Calculate price variance\n        prices = [q[\"bid\"] for q in quotes]\n        std = np.std(prices)\n        mean = np.mean(prices)\n        cv = std / mean  # Coefficient of variation\n        \n        if cv > 0.0005:  # > 5 bps variance\n            # Conflict detected - use primary vendor\n            primary = self.get_primary_vendor(quotes[0][\"symbol\"])\n            for q in quotes:\n                if q[\"vendor\"] == primary:\n                    # Log conflict but use primary\n                    self.log_conflict(quotes)\n                    return q\n        \n        # No conflict - use first vendor\n        return quotes[0]\n```\n\n**Preventing Cascade**: Don\'t forward conflicting quotes to strategies. Buffer quotes for 50ms, wait for confirmation from multiple vendors, then forward consensus. Strategies see only validated, conflict-free data. Cost: 50ms additional latency. Benefit: No erroneous signals.\n\n**Alternative**: Forward all vendor quotes to strategies, let strategy decide (advanced). Most strategies can\'t handle conflicts → prefer centralized resolution.',
    keyPoints: [
      'Detection: Compare all vendor prices, flag if difference > 5 bps (0.05% of price)',
      'Resolution: (1) Majority voting, (2) Trust primary exchange feed, (3) Volume-weighted, (4) Historical reliability',
      'IEX vs Polygon for AAPL: IEX = direct NASDAQ feed (primary), Polygon = aggregator → trust IEX',
      'Production: Buffer 50ms for vendor confirmation, forward only consensus to strategies (prevents cascade)',
      'Cost-benefit: +50ms latency but eliminates erroneous signals from conflicting data',
    ],
  },
  {
    id: 'data-quality-validation-q-3',
    question:
      'Calculate data quality score (0-100) for a symbol based on: accuracy (% valid ticks), completeness (gaps per hour), timeliness (average latency). AAPL today: 1M ticks, 50 errors (crossed markets), 3 gaps (> 10s), average latency 45ms. What is the quality score and should trading continue?',
    sampleAnswer:
      'Data quality score calculation:\n\n**Component Scores**:\n\n1. **Accuracy**: (Valid ticks / Total ticks) × 100\n   = ((1,000,000 - 50) / 1,000,000) × 100\n   = 99.995% ✓\n   \n2. **Completeness**: 100 - (gaps / expected_updates_per_hour) × 100\n   For liquid stock like AAPL: expect continuous updates (1 per second minimum)\n   Gaps allowed: 3 per hour / 3600 seconds = 0.08% downtime\n   = 100 - 0.08 = 99.92% ✓\n   \n3. **Timeliness**: Based on latency thresholds\n   < 50ms = 100 points\n   50-100ms = 90 points\n   100-500ms = 70 points\n   > 500ms = 0 points\n   \n   45ms latency = 100 points ✓\n\n**Overall Score** (weighted average):\n- Accuracy: 40% weight (most important)\n- Completeness: 30% weight\n- Timeliness: 30% weight\n\nScore = (99.995 × 0.4) + (99.92 × 0.3) + (100 × 0.3)\n      = 39.998 + 29.976 + 30\n      = 99.97/100 ✓\n\n**Decision Logic**:\n```python\nclass TradingDecision:\n    def should_trade(self, quality_score):\n        if quality_score >= 99:\n            return {\"trade\": True, \"status\": \"excellent\"}\n        elif quality_score >= 95:\n            return {\"trade\": True, \"status\": \"good\", \"warning\": \"monitor_closely\"}\n        elif quality_score >= 90:\n            return {\"trade\": True, \"status\": \"acceptable\", \"reduce_size\": 0.5}\n        elif quality_score >= 85:\n            return {\"trade\": False, \"status\": \"degraded\", \"action\": \"pause_new_orders\"}\n        else:\n            return {\"trade\": False, \"status\": \"critical\", \"action\": \"halt_all_trading\"}\n```\n\n**AAPL Decision**: Score 99.97 → **Continue trading at full size**. Quality is excellent. 50 errors out of 1M ticks (0.005% error rate) is well within acceptable range. 3 gaps per hour is minimal. 45ms latency is good.\n\n**Alerts**: No immediate action needed. If score drops below 99, investigate. If below 95, reduce position sizes. If below 90, halt new trades.',
    keyPoints: [
      'Accuracy: 99.995% (50 errors / 1M ticks), excellent quality',
      'Completeness: 99.92% (3 gaps / hour = 0.08% downtime), minimal impact',
      'Timeliness: 100 points (45ms < 50ms threshold), low latency',
      'Overall score: 99.97/100 (weighted: 40% accuracy + 30% completeness + 30% timeliness)',
      'Decision: Continue trading at full size (score > 99), no alerts needed, monitor for degradation',
    ],
  },
];
