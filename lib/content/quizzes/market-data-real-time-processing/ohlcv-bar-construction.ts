export const ohlcvBarConstructionQuiz = [
  {
    id: 'ohlcv-bar-construction-q-1',
    question:
      'Design a bar construction system that builds multiple timeframes simultaneously (1min, 5min, 15min, 1hour) from the same tick stream. The system must: (1) Share tick processing across all timeframes, (2) Ensure bar alignment (5min bars start at 0,5,10... minutes), (3) Handle market close with partial bars, (4) Support late ticks updating multiple bars, (5) Achieve < 1ms latency per tick. Provide architecture, algorithm, and Python implementation.',
    sampleAnswer:
      "Multi-timeframe bar construction system:\n\n**Architecture**: Single tick processor feeds multiple bar builders, each configured for different timeframes. Use hierarchical construction: 1min bars → aggregate into 5min → aggregate into 15min → aggregate into 1hour.\n\n**Algorithm**: (1) Process tick once, (2) Route to 1min builder, (3) When 1min completes, feed to 5min builder, (4) When 5min completes (every 5 bars), feed to 15min builder, (5) When 15min completes, feed to 1hour builder. This cascading approach ensures consistency and efficiency.\n\n**Implementation**:\n```python\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List\n\nclass MultiTimeframeBarBuilder:\n    def __init__(self):\n        # Bar builders for each timeframe\n        self.builders = {\n            '1min': TimeBarBuilder(60),\n            '5min': TimeBarBuilder(300),\n            '15min': TimeBarBuilder(900),\n            '1hour': TimeBarBuilder(3600)\n        }\n        \n        # Callbacks per timeframe\n        self.callbacks = {tf: [] for tf in self.builders.keys()}\n        \n        # Stats\n        self.ticks_processed = 0\n    \n    async def process_tick(self, tick):\n        \"\"\"Process tick through all timeframes\"\"\"\n        self.ticks_processed += 1\n        \n        # Process in all builders\n        completed_bars = {}\n        for timeframe, builder in self.builders.items():\n            bar = await builder.process_tick(tick)\n            if bar:\n                completed_bars[timeframe] = bar\n                # Execute callbacks\n                for callback in self.callbacks[timeframe]:\n                    await callback(bar)\n        \n        return completed_bars\n```\n\n**Bar Alignment**: Use floor division to align bars: `bar_start = (timestamp // interval) * interval`. Example: For 5min bars, timestamp 9:32:45 → (9*60+32) = 572 minutes, 572 // 5 = 114, 114 * 5 = 570 minutes = 9:30:00 ✓\n\n**Late Tick Handling**: Maintain completed bars for last 5 minutes per timeframe. When late tick arrives, identify which bars it belongs to (check all timeframes), update each affected bar.\n\n**Market Close**: Force-complete all partial bars: `for builder in builders.values(): builder.force_complete_all()`. Mark as partial with flag `partial=True`.\n\n**Performance**: Single tick processing = 10μs (parse + route). Per-builder update = 2μs. Total: 10 + (2 × 4 timeframes) = 18μs < 1ms ✓. At 10K ticks/sec: 180ms CPU/sec = 18% CPU usage.\n\n**Hierarchical Optimization**: Instead of processing all timeframes independently, build larger bars from smaller: When 5 consecutive 1min bars complete, aggregate into 1× 5min bar (OHLC: O=first.open, H=max(all.high), L=min(all.low), C=last.close, V=sum(all.volume)). This reduces redundant calculations.\n\n**Production Considerations**: Use Redis to share bars across services, persist bars to TimescaleDB every 1min, broadcast bar completions via WebSocket, monitor lag between bar close and completion time (target < 100ms).",
    keyPoints: [
      'Multi-timeframe: Single tick feeds all builders (1min, 5min, 15min, 1hour), share processing across timeframes',
      'Bar alignment: Use floor division (timestamp // interval) * interval to align bars to boundaries (9:32 → 9:30 for 5min)',
      'Hierarchical construction: Build larger bars from smaller (5× 1min bars → 1× 5min bar) for efficiency',
      'Late tick handling: Maintain 5min buffer of completed bars, update all affected timeframes when late tick arrives',
      'Performance: 18μs per tick (10μs parse + 2μs × 4 builders) handles 10K ticks/sec at 18% CPU',
    ],
  },
  {
    id: 'ohlcv-bar-construction-q-2',
    question:
      'Compare time-based bars vs volume-based bars vs dollar-based bars for a trading strategy. For each type: (1) Calculate number of bars per day, (2) Describe information content differences, (3) Identify optimal use cases, (4) Analyze advantages/disadvantages. Provide example: AAPL with 50K ticks/day, avg volume 500 shares/tick, avg price $150. Recommend which bar type to use for momentum vs mean-reversion strategies.',
    sampleAnswer:
      'Bar type comparison for AAPL (50K ticks/day, 500 shares/tick, $150 price):\n\n**Time-Based Bars (1-minute)**:\n\nBars per day: 390 minutes (6.5 hours) = 390 bars/day\nTicks per bar: 50K / 390 ≈ 128 ticks/bar (variable)\n\nInformation content: Fixed time interval, variable activity. Pros: Standard, easy to interpret, consistent with market hours. Cons: Dead periods (low volume) still create bars, active periods compressed. Use cases: General technical analysis, standard indicators (RSI, MACD work on time bars).\n\n**Volume-Based Bars (10K shares)**:\n\nDaily volume: 50K ticks × 500 shares = 25M shares\nBars per day: 25M / 10K = 2,500 bars/day\nTicks per bar: 50K / 2,500 = 20 ticks/bar (consistent)\n\nInformation content: Fixed volume, variable time. Pros: Activity-based, more bars during high volume (market open/close), adapts to market regime. Cons: Irregular time intervals, harder to visualize. Use cases: Volume-based strategies, order flow analysis, detecting institutional activity.\n\n**Dollar-Based Bars ($1M threshold)**:\n\nDaily dollar volume: 25M shares × $150 = $3.75B\nBars per day: $3,750M / $1M = 3,750 bars/day\nTicks per bar: 50K / 3,750 ≈ 13 ticks/bar\n\nInformation content: Fixed dollar volume, accounts for price changes. Pros: Best for institutional analysis (tracks actual capital flow), adapts to volatility (more bars when volatile), price-normalized. Cons: Most complex, harder to compare across stocks. Use cases: Smart money tracking, institutional order detection, large-cap analysis.\n\n**Comparison Table**:\n\n| Bar Type | Bars/Day | Ticks/Bar | Pros | Cons |\n|----------|----------|-----------|------|------|\n| Time (1min) | 390 | 128 | Standard, simple | Dead periods |\n| Volume (10K) | 2,500 | 20 | Activity-based | Irregular timing |\n| Dollar ($1M) | 3,750 | 13 | Capital flow | Complex |\n\n**Strategy Recommendations**:\n\n*Momentum Strategy*: Use **volume-based bars (10K shares)** or **dollar bars ($1M)**. Reasoning: Momentum driven by volume surges. Volume bars create more bars during high activity (momentum events), fewer bars during consolidation. Example: Stock breaks out on high volume → volume bars capture this with multiple bars showing momentum, while time bars might show 1-2 large candles (missing microstructure).\n\n*Mean-Reversion Strategy*: Use **time-based bars (1min or 5min)**. Reasoning: Mean reversion depends on time-based cycles (opening range, lunch lull, close). Volume/dollar bars lose time structure. Example: Stock overshoots at open → mean revert by 10:30am. Time bars clearly show this pattern. Volume bars create irregular intervals that obscure time-based patterns.\n\n**Advanced Recommendation**: Use multiple bar types simultaneously. For momentum: Monitor dollar bars (fast signals) + 5min time bars (trend confirmation). For mean reversion: 1min time bars (entry/exit timing) + volume bars (confirm low volume during reversion).\n\n**Research Findings**: Studies show volume bars have lower autocorrelation (better for ML models) and dollar bars best match institutional order flow. Time bars best for human interpretation and standard indicators.',
    keyPoints: [
      'Time bars (1min): 390 bars/day, fixed intervals, best for standard technical analysis and mean reversion',
      'Volume bars (10K shares): 2,500 bars/day, activity-based, more bars during high volume, best for momentum strategies',
      'Dollar bars ($1M): 3,750 bars/day, tracks capital flow, price-normalized, best for institutional analysis',
      'Momentum strategy: Use volume/dollar bars (capture activity surges, adapt to market regime changes)',
      'Mean reversion: Use time bars (preserve time-based patterns like opening range, lunch lull, closing patterns)',
    ],
  },
  {
    id: 'ohlcv-bar-construction-q-3',
    question:
      "You are backtesting a strategy and notice discrepancies between your constructed bars and the vendor's bars (Bloomberg). For AAPL on 2024-01-15, 9:30-9:31 bar: Your bars show OHLC = (150.25, 150.35, 150.20, 150.30), Bloomberg shows (150.24, 150.36, 150.19, 150.31). Explain: (1) 5 potential causes of discrepancies, (2) How to debug and identify root cause, (3) Impact on backtesting, (4) Resolution approaches. Provide debugging methodology and code for bar comparison.",
    sampleAnswer:
      "Bar discrepancy analysis and debugging:\n\n**Potential Causes**:\n\n1. **Different Data Sources**: You use IEX, Bloomberg uses consolidated tape (all exchanges). Bloomberg may have ticks from NYSE/ARCA that you don't have. Impact: Missing extreme prices (high/low), different OHLC.\n\n2. **Pre-market/Post-market Inclusion**: Bloomberg may include pre-market ticks (4am-9:30am) in opening bar, while you start at 9:30:00 exactly. Impact: Different open price.\n\n3. **Timestamp Rounding**: You round timestamps to bar start (floor), Bloomberg may use different rounding (ceiling or mid-point). Impact: Ticks assigned to wrong bars.\n\n4. **Late Tick Handling**: Bloomberg may accept late ticks for 5 seconds after bar close, you may not. Impact: Updated OHLC in vendor data.\n\n5. **Corporate Actions**: Stock split or dividend adjustment applied differently. If AAPL split 4:1 yesterday, prices should be divided by 4. Impact: All prices off by factor.\n\n**Debugging Methodology**:\n\n```python\nfrom dataclasses import dataclass\nfrom decimal import Decimal\n\n@dataclass\nclass BarComparison:\n    timestamp: datetime\n    symbol: str\n    field: str\n    your_value: Decimal\n    vendor_value: Decimal\n    difference: Decimal\n    pct_diff: float\n\nclass BarDebugger:\n    def __init__(self, tolerance_pct: float = 0.01):\n        self.tolerance = tolerance_pct\n        self.discrepancies = []\n    \n    def compare_bars(self, your_bar: Bar, vendor_bar: Bar) -> List[BarComparison]:\n        \"\"\"Compare two bars and identify discrepancies\"\"\"\n        if your_bar.timestamp != vendor_bar.timestamp:\n            print(f\"ERROR: Timestamp mismatch: {your_bar.timestamp} vs {vendor_bar.timestamp}\")\n        \n        comparisons = []\n        \n        # Compare each field\n        for field in ['open', 'high', 'low', 'close']:\n            your_val = getattr(your_bar, field)\n            vendor_val = getattr(vendor_bar, field)\n            \n            diff = abs(your_val - vendor_val)\n            pct_diff = float(diff / vendor_val) if vendor_val > 0 else 0\n            \n            if pct_diff > self.tolerance:\n                comp = BarComparison(\n                    timestamp=your_bar.timestamp,\n                    symbol=your_bar.symbol,\n                    field=field,\n                    your_value=your_val,\n                    vendor_value=vendor_val,\n                    difference=diff,\n                    pct_diff=pct_diff\n                )\n                comparisons.append(comp)\n                self.discrepancies.append(comp)\n        \n        return comparisons\n    \n    def diagnose(self, comparisons: List[BarComparison]) -> str:\n        \"\"\"Diagnose likely cause of discrepancies\"\"\"\n        if not comparisons:\n            return \"Bars match within tolerance\"\n        \n        # Check if all fields off by same percentage (suggests price adjustment)\n        pct_diffs = [c.pct_diff for c in comparisons]\n        if max(pct_diffs) - min(pct_diffs) < 0.001:\n            avg_diff = sum(pct_diffs) / len(pct_diffs)\n            if abs(avg_diff - 0.25) < 0.01:\n                return \"Likely cause: 4:1 stock split not applied\"\n            elif abs(avg_diff - 0.50) < 0.01:\n                return \"Likely cause: 2:1 stock split not applied\"\n            else:\n                return f\"Likely cause: Systematic price adjustment ({avg_diff*100:.1f}%)\"\n        \n        # Check if only open differs (suggests pre-market inclusion)\n        if len([c for c in comparisons if c.field == 'open']) > 0 and \\n           len([c for c in comparisons if c.field != 'open']) == 0:\n            return \"Likely cause: Pre-market ticks included in vendor open\"\n        \n        # Check if high/low differ but open/close match (suggests missing ticks)\n        high_low_diff = len([c for c in comparisons if c.field in ['high', 'low']]) > 0\n        open_close_match = len([c for c in comparisons if c.field in ['open', 'close']]) == 0\n        if high_low_diff and open_close_match:\n            return \"Likely cause: Missing ticks from other exchanges (incomplete data)\"\n        \n        return \"Likely cause: Late tick processing or timestamp rounding differences\"\n    \n    def analyze_tick_coverage(self, your_ticks: List, vendor_bar: Bar) -> dict:\n        \"\"\"Check if your ticks can produce vendor bar\"\"\"\n        if not your_ticks:\n            return {'error': 'No ticks available'}\n        \n        # Find ticks in bar window\n        bar_start = vendor_bar.timestamp\n        bar_end = bar_start + timedelta(minutes=1)\n        bar_ticks = [t for t in your_ticks \n                     if bar_start <= t.timestamp < bar_end]\n        \n        if not bar_ticks:\n            return {'error': 'No ticks found in bar window', 'possible_cause': 'Data gap'}\n        \n        # Calculate what bar would be from your ticks\n        prices = [float(t.mid_price) for t in bar_ticks]\n        calculated_bar = {\n            'open': prices[0],\n            'high': max(prices),\n            'low': min(prices),\n            'close': prices[-1]\n        }\n        \n        # Compare to vendor\n        can_explain = {\n            'high': calculated_bar['high'] >= float(vendor_bar.high),\n            'low': calculated_bar['low'] <= float(vendor_bar.low)\n        }\n        \n        if not can_explain['high']:\n            return {\n                'error': f\"Vendor high ({vendor_bar.high}) > your max tick ({calculated_bar['high']})\",\n                'possible_cause': 'Missing ticks from other exchanges'\n            }\n        \n        if not can_explain['low']:\n            return {\n                'error': f\"Vendor low ({vendor_bar.low}) < your min tick ({calculated_bar['low']})\",\n                'possible_cause': 'Missing ticks from other exchanges'\n            }\n        \n        return {'status': 'OK', 'ticks_analyzed': len(bar_ticks)}\n\n# Usage\ndebugger = BarDebugger(tolerance_pct=0.01)\n\nyour_bar = Bar(\n    symbol=\"AAPL\",\n    timestamp=datetime(2024, 1, 15, 9, 30),\n    interval=\"1min\",\n    open=Decimal(\"150.25\"),\n    high=Decimal(\"150.35\"),\n    low=Decimal(\"150.20\"),\n    close=Decimal(\"150.30\"),\n    volume=10000\n)\n\nbloomberg_bar = Bar(\n    symbol=\"AAPL\",\n    timestamp=datetime(2024, 1, 15, 9, 30),\n    interval=\"1min\",\n    open=Decimal(\"150.24\"),\n    high=Decimal(\"150.36\"),\n    low=Decimal(\"150.19\"),\n    close=Decimal(\"150.31\"),\n    volume=10500\n)\n\ncomparisons = debugger.compare_bars(your_bar, bloomberg_bar)\nfor comp in comparisons:\n    print(f\"{comp.field}: {comp.your_value} vs {comp.vendor_value} ({comp.pct_diff*100:.2f}% diff)\")\n\ndiagnosis = debugger.diagnose(comparisons)\nprint(f\"Diagnosis: {diagnosis}\")\n\n# Check tick coverage\ntick_analysis = debugger.analyze_tick_coverage(your_ticks, bloomberg_bar)\nprint(f\"Tick analysis: {tick_analysis}\")\n```\n\n**Impact on Backtesting**:\n\n1. **Missing extremes** (high/low differ): Strategies relying on support/resistance levels will have different results. Stop losses may not trigger in backtest but would in live trading.\n\n2. **Open price difference**: Gap trading strategies affected. Morning breakout signals may differ.\n\n3. **Volume discrepancy**: Volume-based strategies (volume profile, VWAP) will have different calculations.\n\n4. **Systematic bias**: If your bars consistently underestimate volatility (narrower high-low range), risk models will be wrong.\n\n**Resolution Approaches**:\n\n1. **Use consolidated tape data**: Subscribe to all exchanges (expensive but accurate).\n\n2. **Adjust for known differences**: If Bloomberg includes pre-market, filter those ticks from your data for comparison.\n\n3. **Accept vendor bars as truth**: Use Bloomberg bars for backtesting if you can't match construction.\n\n4. **Document discrepancies**: Note that live trading will use your construction (may differ from backtest).\n\n5. **Test on both**: Run backtest with your bars AND vendor bars, compare results. If strategy performance similar (±5%), acceptable.\n\n**Best Practice**: For production trading, use same bar construction in backtest and live. Don't backtest on Bloomberg bars if live trading uses your constructed bars - this creates train/test mismatch.",
    keyPoints: [
      'Common causes: Different data sources (missing exchanges), pre-market inclusion, timestamp rounding, late ticks, corporate actions',
      'Debugging: Compare each field (OHLC), check percentage differences, analyze tick coverage, look for patterns (systematic vs random)',
      'Diagnosis: If all fields off by same % → price adjustment. If only open differs → pre-market. If high/low differ → missing ticks.',
      'Impact: Stop losses may not trigger (missing extremes), gap strategies affected (wrong open), volume-based calculations off',
      'Resolution: Use consolidated data, adjust for known differences, or use vendor bars for backtesting (match live construction)',
    ],
  },
];
