export const marketDataVendorsApisQuiz = [
  {
    id: 'market-data-vendors-apis-q-1',
    question:
      'Design a market data redundancy system using two vendors (IEX Cloud + Polygon.io) for a production trading system. Requirements: (1) Subscribe to 500 symbols from both vendors simultaneously, (2) Detect feed failures and automatically failover, (3) Handle discrepancies when both feeds are active, (4) Minimize latency and bandwidth costs, (5) Provide Python implementation with WebSocket connections. Explain failover logic, conflict resolution, and cost analysis.',
    sampleAnswer:
      'Multi-vendor redundancy architecture:\n\n**System Design**: Primary feed (IEX Cloud) + Secondary feed (Polygon.io) running in parallel. Use primary for trading decisions, secondary for validation and failover.\n\n```python\nimport asyncio\nfrom datetime import datetime, timedelta\nfrom decimal import Decimal\nfrom typing import Dict, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass Quote:\n    symbol: str\n    bid: Decimal\n    ask: Decimal\n    timestamp: datetime\n    source: str\n\nclass RedundantDataFeed:\n    """Redundant market data with automatic failover"""\n    \n    def __init__(self, symbols: list):\n        self.symbols = symbols\n        \n        # Feed connections\n        self.iex_feed = None  # Primary\n        self.polygon_feed = None  # Secondary\n        \n        # Latest quotes from each feed\n        self.iex_quotes: Dict[str, Quote] = {}\n        self.polygon_quotes: Dict[str, Quote] = {}\n        \n        # Combined quotes (output)\n        self.quotes: Dict[str, Quote] = {}\n        \n        # Health monitoring\n        self.iex_last_update: Dict[str, datetime] = {}\n        self.polygon_last_update: Dict[str, datetime] = {}\n        \n        # Failover state\n        self.primary_feed = "iex"  # or "polygon"\n        self.feed_down_threshold = 5.0  # seconds\n        \n        # Discrepancy tracking\n        self.discrepancies = []\n        self.discrepancy_threshold_bps = 10  # Alert if > 10 bps difference\n    \n    async def start(self):\n        """Start both feeds"""\n        await asyncio.gather(\n            self._run_iex_feed(),\n            self._run_polygon_feed(),\n            self._monitor_health(),\n            self._check_discrepancies()\n        )\n    \n    async def _run_iex_feed(self):\n        """Run IEX Cloud WebSocket feed"""\n        while True:\n            try:\n                # Connect to IEX (pseudo-code)\n                async with iex_websocket_connect() as ws:\n                    await ws.subscribe(self.symbols)\n                    \n                    async for message in ws:\n                        quote = self._parse_iex_quote(message)\n                        self.iex_quotes[quote.symbol] = quote\n                        self.iex_last_update[quote.symbol] = datetime.now()\n                        \n                        # If IEX is primary, update output\n                        if self.primary_feed == "iex":\n                            self.quotes[quote.symbol] = quote\n            \n            except Exception as e:\n                print(f"IEX feed error: {e}")\n                await asyncio.sleep(5)  # Reconnect delay\n    \n    async def _run_polygon_feed(self):\n        """Run Polygon.io WebSocket feed"""\n        while True:\n            try:\n                async with polygon_websocket_connect() as ws:\n                    await ws.subscribe(self.symbols)\n                    \n                    async for message in ws:\n                        quote = self._parse_polygon_quote(message)\n                        self.polygon_quotes[quote.symbol] = quote\n                        self.polygon_last_update[quote.symbol] = datetime.now()\n                        \n                        # If Polygon is primary, update output\n                        if self.primary_feed == "polygon":\n                            self.quotes[quote.symbol] = quote\n            \n            except Exception as e:\n                print(f"Polygon feed error: {e}")\n                await asyncio.sleep(5)\n    \n    async def _monitor_health(self):\n        """Monitor feed health and perform failover"""\n        while True:\n            await asyncio.sleep(1)  # Check every second\n            \n            now = datetime.now()\n            \n            # Check primary feed health\n            if self.primary_feed == "iex":\n                stale_symbols = [\n                    s for s in self.symbols\n                    if (now - self.iex_last_update.get(s, now)).total_seconds() \n                       > self.feed_down_threshold\n                ]\n                \n                if len(stale_symbols) > len(self.symbols) * 0.1:  # > 10% stale\n                    print(f"IEX feed unhealthy ({len(stale_symbols)} stale symbols)")\n                    print("FAILOVER: Switching to Polygon")\n                    self.primary_feed = "polygon"\n                    # Update all quotes from Polygon\n                    self.quotes = self.polygon_quotes.copy()\n            \n            else:  # primary is polygon\n                stale_symbols = [\n                    s for s in self.symbols\n                    if (now - self.polygon_last_update.get(s, now)).total_seconds()\n                       > self.feed_down_threshold\n                ]\n                \n                if len(stale_symbols) > len(self.symbols) * 0.1:\n                    print(f"Polygon feed unhealthy ({len(stale_symbols)} stale)")\n                    \n                    # Try to failback to IEX if healthy\n                    iex_stale = [\n                        s for s in self.symbols\n                        if (now - self.iex_last_update.get(s, now)).total_seconds()\n                           > self.feed_down_threshold\n                    ]\n                    \n                    if len(iex_stale) < len(self.symbols) * 0.1:\n                        print("FAILBACK: Switching to IEX")\n                        self.primary_feed = "iex"\n                        self.quotes = self.iex_quotes.copy()\n    \n    async def _check_discrepancies(self):\n        """Compare feeds and detect discrepancies"""\n        while True:\n            await asyncio.sleep(5)  # Check every 5 seconds\n            \n            for symbol in self.symbols:\n                iex_quote = self.iex_quotes.get(symbol)\n                polygon_quote = self.polygon_quotes.get(symbol)\n                \n                if not (iex_quote and polygon_quote):\n                    continue\n                \n                # Compare mid prices\n                iex_mid = (iex_quote.bid + iex_quote.ask) / 2\n                polygon_mid = (polygon_quote.bid + polygon_quote.ask) / 2\n                \n                diff = abs(iex_mid - polygon_mid)\n                diff_bps = float(diff / iex_mid) * 10000\n                \n                if diff_bps > self.discrepancy_threshold_bps:\n                    discrepancy = {\n                        \'symbol\': symbol,\n                        \'iex_mid\': iex_mid,\n                        \'polygon_mid\': polygon_mid,\n                        \'diff_bps\': diff_bps,\n                        \'timestamp\': datetime.now()\n                    }\n                    self.discrepancies.append(discrepancy)\n                    print(f"DISCREPANCY: {symbol} IEX ${iex_mid} vs Polygon ${polygon_mid} ({diff_bps:.1f} bps)")\n```\n\n**Conflict Resolution**:\n\n1. **Normal operation**: Use primary feed (IEX) for all decisions\n2. **Failover**: Switch to secondary (Polygon) if primary stale > 5s for > 10% of symbols\n3. **Failback**: Return to primary when it recovers\n4. **Discrepancy alerts**: Log when feeds differ > 10 bps\n5. **Data validation**: Reject quotes with crossed markets (bid > ask)\n\n**Cost Analysis**:\n\nIEX Cloud: $499/mo for real-time unlimited + WebSocket\nPolygon.io: $399/mo for stocks real-time\nTotal: $898/mo\n\nBandwidth (500 symbols × 10 updates/sec × 24 hours):\n= 500 × 10 × 86,400 = 432M updates/day\n@ 200 bytes/update = 86 GB/day × 2 feeds = 172 GB/day\n\nLatency: ~50-100ms (WebSocket) vs 200-500ms (REST polling)\n\n**Benefits**: 99.9% uptime (single feed = 99% uptime), data validation (detect bad data), vendor independence (not locked into one vendor).',
    keyPoints: [
      'Architecture: Primary feed (IEX) + secondary feed (Polygon) running in parallel, use primary for decisions',
      'Failover trigger: Switch to secondary if primary stale > 5s for > 10% of symbols (automatic)',
      'Health monitoring: Track last update time per symbol, check every 1 second for staleness',
      'Discrepancy detection: Compare mid prices, alert if > 10 bps difference, log for analysis',
      'Cost: $898/mo for dual feeds (IEX $499 + Polygon $399), 172 GB/day bandwidth for 500 symbols',
    ],
  },
  {
    id: 'market-data-vendors-apis-q-2',
    question:
      'Compare market data costs for different trading volumes using IEX Cloud, Polygon.io, and Bloomberg Terminal. Calculate total cost of ownership for: (1) Hobbyist: 5 symbols, 1 user, backtesting + paper trading. (2) Small firm: 100 symbols, 5 users, live trading $500K AUM. (3) Large firm: 5000 symbols, 50 users, live trading $50M AUM. Include data costs, API fees, user licenses, and infrastructure. Recommend optimal vendor for each tier.',
    sampleAnswer:
      'Market data TCO analysis by trading tier:\n\n**Tier 1: Hobbyist (5 symbols, 1 user, backtesting)**\n\nIEX Cloud: Free tier (100 API calls/day) or $9/mo unlimited\n- Data: $0-9/mo\n- API: Included\n- Historical: 5 years included\n- Total: $9/mo\n\nPolygon.io: Starter $29/mo\n- Data: $29/mo (15-min delayed) or $99/mo real-time\n- API: Unlimited\n- Historical: 2 years included\n- Total: $29-99/mo\n\nBloomberg Terminal: $2,000/mo (annual contract $24K)\n- Not realistic for hobbyist\n- Total: $2,000/mo\n\n**Recommendation Tier 1**: IEX Cloud free tier ($0) or Alpha Vantage free. For serious backtesting, IEX Cloud $9/mo or Polygon $29/mo (more historical data). Bloomberg not justified.\n\nTier 1 Winner: **IEX Cloud ($9/mo)** - best value for learning/prototyping.\n\n**Tier 2: Small Firm (100 symbols, 5 users, $500K AUM)**\n\nIEX Cloud: Core plan $499/mo\n- Data: $499/mo (unlimited real-time)\n- API: WebSocket included\n- Users: Unlimited API keys (no per-user fee)\n- Infrastructure: $100/mo (AWS for data processing)\n- Total: $600/mo\n\nPolygon.io: Pro plan $399/mo\n- Data: $399/mo (real-time unlimited)\n- API: Unlimited\n- Users: No per-user fee\n- Infrastructure: $100/mo\n- Total: $500/mo\n\nBloomberg Terminal: $2,000/mo × 5 users = $10,000/mo\n- Data: Included\n- API: Limited (B-PIPE extra $1K/mo)\n- Users: $2K per terminal\n- Total: $10,000+/mo\n\n**Cost as % of AUM**:\n- IEX: $600/mo / $500K AUM = 0.12% annually = 1.44% (high)\n- Polygon: $500/mo / $500K = 1.20% annually (high)\n- Bloomberg: $10K/mo / $500K = 24% annually (unsustainable)\n\n**Recommendation Tier 2**: Polygon.io ($500/mo) for lowest cost, or IEX Cloud ($600/mo) for better developer experience. Bloomberg not justified until > $5M AUM or need for Bloomberg-specific datasets (fixed income, commodities).\n\nTier 2 Winner: **Polygon.io ($500/mo)** - best price/performance.\n\n**Tier 3: Large Firm (5000 symbols, 50 users, $50M AUM)**\n\nIEX Cloud: Custom enterprise pricing\n- Data: ~$2,000-5,000/mo (negotiated)\n- API: Unlimited\n- Users: API-based (no per-user fee)\n- Infrastructure: $2,000/mo (dedicated servers, redundancy)\n- Total: $4,000-7,000/mo\n\nPolygon.io: Enterprise plan\n- Data: ~$3,000-5,000/mo\n- API: Unlimited\n- Infrastructure: $2,000/mo\n- Total: $5,000-7,000/mo\n\nBloomberg Terminal: $1,500/mo × 50 users = $75,000/mo\n- Data: All datasets included\n- API: B-PIPE included at scale\n- Research: Bloomberg News, analytics\n- Total: $75,000/mo\n\nRefinitiv Eikon: $1,200/mo × 50 = $60,000/mo\n- Alternative to Bloomberg\n- Strong in fixed income/FX\n- Total: $60,000/mo\n\n**Cost as % of AUM**:\n- IEX/Polygon: $7K/mo / $50M = 0.17% annually (reasonable)\n- Bloomberg: $75K/mo / $50M = 1.8% annually (expensive but acceptable)\n\n**Recommendation Tier 3**: Multi-vendor approach: Primary = IEX/Polygon ($7K/mo) for automated trading. Secondary = 5-10 Bloomberg terminals ($10-20K/mo) for research/PM teams. Total: ~$17-27K/mo = 0.4-0.65% of AUM.\n\nTier 3 Winner: **Hybrid approach** (Polygon.io for algos + 10 Bloomberg for PMs) = $22K/mo.\n\n**Summary Table**:\n\n| Tier | AUM | Symbols | Users | Vendor | Monthly Cost | Cost % AUM |\n|------|-----|---------|-------|--------|--------------|------------|\n| 1 | $0 | 5 | 1 | IEX Cloud | $9 | N/A |\n| 2 | $500K | 100 | 5 | Polygon.io | $500 | 1.2% |\n| 3 | $50M | 5000 | 50 | Polygon + BBG | $22,000 | 0.53% |\n\n**Key Insight**: Bloomberg justification requires > $5M AUM OR specific use cases (fixed income research, client reporting, regulatory feeds). For pure equities algorithmic trading, Polygon/IEX are 10-15× cheaper with comparable data quality.',
    keyPoints: [
      'Hobbyist (5 symbols): IEX Cloud $9/mo wins, Bloomberg $2K/mo unjustified',
      'Small firm ($500K AUM, 100 symbols): Polygon.io $500/mo (1.2% of AUM), Bloomberg $10K/mo too expensive (24% of AUM)',
      'Large firm ($50M AUM, 5000 symbols): Hybrid approach (Polygon $5K + 10 Bloomberg terminals $20K = $25K total = 0.6% AUM)',
      'Cost threshold: Bloomberg justified when AUM > $5M (cost < 5% of AUM) or need for non-equity data',
      'TCO includes: Data fees + API costs + infrastructure ($100-2K/mo) + user licenses (Bloomberg = per seat)',
    ],
  },
  {
    id: 'market-data-vendors-apis-q-3',
    question:
      "You're rate-limited by IEX Cloud API (100 requests/second). You need to fetch real-time quotes for 1000 symbols every second. Design a solution: (1) Minimize API calls while maintaining 1-second latency, (2) Handle rate limits gracefully, (3) Optimize for cost (minimize API tier upgrades), (4) Provide Python implementation with request batching and caching. Calculate cost savings vs naive approach.",
    sampleAnswer:
      'Rate limit optimization strategy:\n\n**Problem Analysis**:\n\nNaive approach: 1000 symbols × 1 request/symbol/second = 1000 req/sec ❌ (exceeds 100 req/sec limit by 10×)\n\nCost: Would require Enterprise tier $5K/mo (vs Core tier $500/mo)\n\n**Optimized Solution**: Use batch endpoints + WebSocket + caching\n\n```python\nimport asyncio\nimport aiohttp\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List\nimport time\n\nclass RateLimitedAPI:\n    """IEX Cloud API with intelligent rate limiting"""\n    \n    def __init__(self, api_key: str, rate_limit: int = 100):\n        self.api_key = api_key\n        self.base_url = "https://cloud.iexapis.com/stable"\n        \n        # Rate limiting\n        self.rate_limit = rate_limit  # requests per second\n        self.request_times = []\n        \n        # Caching\n        self.quote_cache: Dict[str, dict] = {}\n        self.cache_ttl = 1.0  # seconds\n        \n        # Batch configuration\n        self.batch_size = 100  # symbols per batch request\n        \n        # WebSocket (alternative)\n        self.websocket_conn = None\n        self.use_websocket = True\n    \n    async def get_quotes_optimized(self, symbols: List[str]) -> Dict[str, dict]:\n        """Get quotes with optimization"""\n        # Strategy 1: Check cache first\n        now = time.time()\n        fresh_quotes = {}\n        stale_symbols = []\n        \n        for symbol in symbols:\n            cached = self.quote_cache.get(symbol)\n            if cached and (now - cached[\'cached_at\']) < self.cache_ttl:\n                fresh_quotes[symbol] = cached\n            else:\n                stale_symbols.append(symbol)\n        \n        print(f"Cache hit: {len(fresh_quotes)}/{len(symbols)}")\n        \n        if not stale_symbols:\n            return fresh_quotes\n        \n        # Strategy 2: Use WebSocket if available (0 API calls)\n        if self.use_websocket and self.websocket_conn:\n            # WebSocket provides real-time updates without API calls\n            # Quotes are already in cache via WebSocket\n            return fresh_quotes\n        \n        # Strategy 3: Batch API requests\n        quotes = await self._fetch_batched(stale_symbols)\n        \n        # Update cache\n        for symbol, quote in quotes.items():\n            quote[\'cached_at\'] = now\n            self.quote_cache[symbol] = quote\n        \n        # Combine cached and fresh\n        fresh_quotes.update(quotes)\n        return fresh_quotes\n    \n    async def _fetch_batched(self, symbols: List[str]) -> Dict[str, dict]:\n        """Fetch quotes in batches to minimize API calls"""\n        all_quotes = {}\n        \n        # Split into batches\n        batches = [symbols[i:i+self.batch_size] \n                  for i in range(0, len(symbols), self.batch_size)]\n        \n        print(f"Fetching {len(symbols)} symbols in {len(batches)} batches")\n        \n        # Fetch batches with rate limiting\n        for batch in batches:\n            await self._wait_for_rate_limit()\n            \n            # Batch request (single API call for multiple symbols)\n            url = f"{self.base_url}/stock/market/batch"\n            params = {\n                \'symbols\': \',\'.join(batch),\n                \'types\': \'quote\',\n                \'token\': self.api_key\n            }\n            \n            async with aiohttp.ClientSession() as session:\n                async with session.get(url, params=params) as response:\n                    data = await response.json()\n                    \n                    for symbol, info in data.items():\n                        quote = info[\'quote\']\n                        all_quotes[symbol] = {\n                            \'bid\': quote[\'iexBidPrice\'],\n                            \'ask\': quote[\'iexAskPrice\'],\n                            \'last\': quote[\'latestPrice\'],\n                            \'timestamp\': quote[\'latestUpdate\']\n                        }\n        \n        return all_quotes\n    \n    async def _wait_for_rate_limit(self):\n        """Enforce rate limit"""\n        now = time.time()\n        \n        # Remove requests older than 1 second\n        self.request_times = [t for t in self.request_times if now - t < 1.0]\n        \n        # If at limit, wait\n        if len(self.request_times) >= self.rate_limit:\n            sleep_time = 1.0 - (now - self.request_times[0])\n            if sleep_time > 0:\n                await asyncio.sleep(sleep_time)\n                # Clear old requests\n                now = time.time()\n                self.request_times = [t for t in self.request_times if now - t < 1.0]\n        \n        self.request_times.append(now)\n    \n    async def start_websocket(self, symbols: List[str]):\n        """Start WebSocket connection (0 API calls)"""\n        # IEX Cloud WebSocket (included in Core plan)\n        # Provides real-time updates without consuming API quota\n        self.use_websocket = True\n        # WebSocket continuously updates self.quote_cache\n        # No API calls needed after initial connection\n```\n\n**Optimization Results**:\n\n**Naive Approach**:\n- API calls: 1000 symbols × 1 req/sec = 1000 req/sec\n- Exceeds limit: 1000 / 100 = 10× over\n- Required tier: Enterprise ($5,000/mo)\n- Latency: 1 second (as requested)\n\n**Optimized Approach**:\n\n**Option 1: Batch + Cache**\n- Batch size: 100 symbols/request\n- API calls: 1000 / 100 = 10 req/sec ✓ (90% reduction)\n- Cache hit rate: ~80% after warmup\n- Effective calls: 10 × 0.2 = 2 req/sec\n- Required tier: Core ($500/mo) ✓\n- Latency: ~1.2 seconds (slight increase due to batching)\n- **Cost savings: $4,500/mo (90% reduction)**\n\n**Option 2: WebSocket (Best)**\n- API calls: 0 req/sec (WebSocket doesn\'t count against quota)\n- Initial connection: 1 WebSocket connection\n- Updates: Real-time push (no polling)\n- Required tier: Core ($500/mo) ✓\n- Latency: 50-100ms (10× better than polling!)\n- **Cost savings: $4,500/mo (90% reduction) + lower latency**\n\n**Recommendation**: Use WebSocket for real-time quotes (Option 2). Falls back to batched REST API if WebSocket disconnects. This provides best of both worlds: Real-time updates, no API quota consumption, automatic failover.\n\n**Implementation Note**: IEX Cloud WebSocket is included in Core plan ($500/mo) and supports unlimited symbols with push updates (no polling). This is the optimal solution for high-frequency quote retrieval.',
    keyPoints: [
      'Problem: 1000 symbols × 1 req/sec = 1000 req/sec exceeds 100 req/sec limit by 10×',
      'Solution 1: Batch requests (100 symbols per call) = 10 req/sec, add caching (80% hit rate) = 2 effective req/sec',
      'Solution 2: WebSocket (0 API calls, push updates) = best solution, 50-100ms latency vs 1s polling',
      'Cost savings: Naive approach requires Enterprise $5K/mo, optimized needs Core $500/mo = $4,500/mo savings (90%)',
      'Best practice: Use WebSocket for real-time (0 quota), fallback to batched REST API on disconnect',
    ],
  },
];
