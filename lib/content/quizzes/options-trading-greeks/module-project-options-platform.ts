export const moduleProjectOptionsPlatformQuiz = [
  {
    id: 'module-project-options-platform-q-1',
    question:
      "For the Module Project Phase 1 (Options Pricing Engine), implement a complete implied volatility calculator using BOTH Newton-Raphson and Bisection methods. The system should: (1) Take market option price as input and find IV that matches it, (2) Try Newton-Raphson first (fast), fallback to Bisection if doesn't converge, (3) Handle edge cases (price below intrinsic, extreme strikes, near expiration), (4) Optimize performance for calculating IV across entire options chain (100+ strikes), (5) Validate results against known benchmarks. Provide complete implementation with error handling and optimization techniques.",
    sampleAnswer:
      "Complete Implied Volatility Calculator: **Newton-Raphson Method (Primary)**: def newton_raphson_iv(market_price, S, K, T, r, option_type, initial_sigma=0.25, max_iter=100, tol=1e-6): sigma = initial_sigma; intrinsic = max(S-K, 0) if option_type=='call' else max(K-S, 0); if market_price < intrinsic - 0.01: return None, 'Price below intrinsic'; for i in range(max_iter): bs_price = black_scholes(S, K, T, r, sigma, option_type); vega = calculate_vega(S, K, T, r, sigma); diff = bs_price - market_price; if abs(diff) < tol: return sigma, 'Converged'; if vega < 1e-10: return None, 'Vega too small'; sigma = sigma - diff/vega; sigma = np.clip(sigma, 0.01, 5.0); return None, 'Max iterations'. **Bisection Method (Fallback)**: def bisection_iv(market_price, S, K, T, r, option_type, vol_min=0.01, vol_max=5.0, max_iter=100, tol=1e-6): price_min = black_scholes(S, K, T, r, vol_min, option_type); price_max = black_scholes(S, K, T, r, vol_max, option_type); if market_price < price_min or market_price > price_max: return None, 'Outside bounds'; for i in range(max_iter): vol_mid = (vol_min + vol_max) / 2; price_mid = black_scholes(S, K, T, r, vol_mid, option_type); if abs(price_mid - market_price) < tol: return vol_mid, 'Converged'; if price_mid < market_price: vol_min = vol_mid; else: vol_max = vol_mid; return (vol_min + vol_max)/2, 'Max iterations'. **Combined Robust Calculator**: def calculate_implied_volatility(market_price, S, K, T, r, option_type): # Try Newton first; iv, status = newton_raphson_iv(market_price, S, K, T, r, option_type); if iv and 0.05 <= iv <= 2.0: return {'iv': iv, 'method': 'Newton', 'status': status}; # Fallback to bisection; iv, status = bisection_iv(market_price, S, K, T, r, option_type); return {'iv': iv, 'method': 'Bisection', 'status': status}. **Edge Cases**: Near expiration (T < 0.01): Return intrinsic value, IV â†’ infinity as T â†’ 0. Extreme ITM/OTM: Wide bid-ask, IV unstable, Skip if |moneyness| > 0.5. Price validation: Reject if price < intrinsic or > stock price (call). **Optimization for Options Chain**: Vectorize: Use NumPy arrays for 100 strikes at once, Parallel: Use multiprocessing for separate expirations, Cache: Store vega calculations (reused in Newton), Smart initial guesses: Use ATM IV for nearby strikes, Adaptive tolerance: Tighter for ATM, looser for OTM. **Implementation**: def calculate_chain_ivs(option_chain, S, T, r): results = {}; atm_iv = None; sorted_strikes = sorted(option_chain.keys()); for K in sorted_strikes: market_price = option_chain[K]; # Smart initial guess; if atm_iv is None: initial = 0.25; else: initial = atm_iv; # Use ATM as seed; result = calculate_implied_volatility(market_price, S, K, T, r, 'call', initial); if result['iv'] and abs(K - S) < 5: atm_iv = result['iv']; results[K] = result; return results. **Validation**: Test against known values: SPY $100, $100 call, 30 days, 20% IV: Theoretical price = $2.51, Reverse calculate IV from $2.51 â†’ should get 20%, Actual: 19.99% (within tolerance). Benchmark performance: 100 strikes: Newton avg 4 iterations, 0.2ms total, Bisection avg 15 iterations, 0.8ms total, Combined: 99% Newton success rate.",
    keyPoints: [
      'Newton-Raphson primary: sigma_new = sigma - (BS_price - market_price) / vega; converges in ~4 iterations',
      'Bisection fallback: Binary search between vol_min and vol_max; slower (15 iterations) but always converges',
      'Edge cases: Check price â‰¥ intrinsic, clip sigma to [0.01, 5.0], handle T < 0.01 specially',
      'Optimization: Use ATM IV as initial guess for nearby strikes; vectorize 100 strikes in 0.2ms total',
      'Validation: Test on known benchmarks (e.g., $100 strike, 20% IV â†’ $2.51 price, reverse to 19.99% IV)',
    ],
  },
  {
    id: 'module-project-options-platform-q-2',
    question:
      'For the Module Project Phase 3 (Portfolio Manager), implement a comprehensive risk monitoring system with real-time alerts. The system should: (1) Calculate aggregate portfolio Greeks every second, (2) Check against risk limits and generate alerts, (3) Recommend specific hedging trades when limits breached, (4) Track P&L attribution to each Greek in real-time, (5) Generate end-of-day risk report, (6) Implement automated hedging (optional: with approval workflow). Provide architecture, algorithms, and sample output.',
    sampleAnswer:
      "Portfolio Risk Monitoring System Architecture: **Components**: 1. GreeksCalculator: Aggregates Greeks across all positions, 2. RiskMonitor: Checks limits, generates alerts, 3. HedgeRecommender: Suggests hedging trades, 4. PnLAttributor: Tracks daily P\\'&\\'L by Greek, 5. ReportGenerator: EOD risk reports, 6. AlertManager: Sends notifications. **GreeksCalculator**: class GreeksCalculator: def calculate_portfolio_greeks(self, positions, market_data): total_greeks = {\\'delta\\': 0, \\'gamma\\': 0, \\'theta\\': 0, \\'vega\\': 0}; for pos in positions: S = market_data[pos.symbol][\\'price\\']; IV = market_data[pos.symbol][\\'iv\\']; for leg in pos.legs: T = leg.expiration_days / 365; pricing = self.engine.price_option(S, leg.strike, T, IV, leg.type); multiplier = leg.quantity Ã— 100; total_greeks[\\'delta\\'] += pricing.delta Ã— multiplier; # ... other Greeks; return total_greeks; self.update_frequency = 1; # second. **RiskMonitor with Alerts**: class RiskMonitor: def __init__(self): self.limits = {\\'delta\\': (8000, 10000), \\'gamma\\': (400, 500), \\'theta\\': (-500, 5000), \\'vega\\': (40000, 50000)}; # (orange, red); def check_limits(self, greeks): alerts = []; for greek, value in greeks.items(): orange, red = self.limits[greek]; if abs(value) > red: alerts.append({\\'severity\\': \\'RED\\', \\'greek\\': greek, \\'value\\': value, \\'limit\\': red, \\'message\\': f\\'CRITICAL: {greek} = {value:.0f} exceeds limit {red}\\'}); elif abs(value) > orange: alerts.append({\\'severity\\': \\'ORANGE\\', \\'greek\\': greek, \\'value\\': value, \\'limit\\': orange}); return alerts. **HedgeRecommender**: class HedgeRecommender: def recommend_hedge(self, greek, value, limit, portfolio): if greek == \\'delta\\': target_delta = 0; # Delta-neutral; delta_to_hedge = target_delta - value; shares_to_trade = delta_to_hedge; action = \\'BUY\\' if shares_to_trade > 0 else \\'SELL\\'; return {\\'action\\': action, \\'quantity\\': abs(shares_to_trade), \\'instrument\\': \\'SPY shares\\', \\'notional\\': abs(shares_to_trade) Ã— current_spy_price}; elif greek == \\'gamma\\': # Close high-gamma positions; high_gamma_positions = self.find_high_gamma(portfolio); return {\\'action\\': \\'CLOSE\\', \\'positions\\': high_gamma_positions[:3]}; elif greek == \\'vega\\': # Add negative vega; return {\\'action\\': \\'SELL\\', \\'strategy\\': \\'10 SPY strangles\\', \\'vega_impact\\': -25000}. **P&L Attributor**: class PnLAttributor: def __init__(self): self.last_greeks = None; self.last_prices = {}; self.last_iv = {}; def calculate_attribution(self, current_greeks, current_prices, current_iv): if self.last_greeks is None: self.last_greeks = current_greeks; self.last_prices = current_prices; self.last_iv = current_iv; return {\\'delta\\': 0, \\'gamma\\': 0, \\'theta\\': 0, \\'vega\\': 0}; # Calculate changes; price_change = current_prices[\\'SPY\\'] - self.last_prices[\\'SPY\\']; iv_change = current_iv[\\'SPY\\'] - self.last_iv[\\'SPY\\']; time_passed = 1/252; # 1 day; # Attribute P&L; delta_pnl = self.last_greeks[\\'delta\\'] Ã— price_change; gamma_pnl = 0.5 Ã— self.last_greeks[\\'gamma\\'] Ã— (price_change ** 2); theta_pnl = self.last_greeks[\\'theta\\'] Ã— time_passed; vega_pnl = self.last_greeks[\\'vega\\'] Ã— iv_change Ã— 100; # Update state; self.last_greeks = current_greeks; self.last_prices = current_prices; self.last_iv = current_iv; return {\\'delta\\': delta_pnl, \\'gamma\\': gamma_pnl, \\'theta\\': theta_pnl, \\'vega\\': vega_pnl, \\'total\\': delta_pnl + gamma_pnl + theta_pnl + vega_pnl}. **Real-Time Monitoring Loop**: def monitor_portfolio(portfolio): calculator = GreeksCalculator(); monitor = RiskMonitor(); recommender = HedgeRecommender(); attributor = PnLAttributor(); while market_open(): # Every second; greeks = calculator.calculate_portfolio_greeks(portfolio.positions, get_market_data()); # Check limits; alerts = monitor.check_limits(greeks); if alerts: for alert in alerts: if alert[\\'severity\\'] == \\'RED\\': send_sms(alert[\\'message\\']); hedge_rec = recommender.recommend_hedge(alert[\\'greek\\'], alert[\\'value\\'], alert[\\'limit\\'], portfolio); log_recommendation(hedge_rec); elif alert[\\'severity\\'] == \\'ORANGE\\': send_email(alert); # P&L attribution; pnl = attributor.calculate_attribution(greeks, get_prices(), get_ivs()); update_dashboard(greeks, alerts, pnl); time.sleep(1). **Sample Dashboard Output**: Current Time: 2:15:32 PM ET; Portfolio Greeks: Delta: +5,234 (WITHIN LIMITS âœ“), Gamma: +487 (ORANGE ALERT âš ï¸), Theta: +$1,250/day (âœ“), Vega: +$52,341 (RED ALERT ðŸš¨). ALERTS: [RED] Vega $52,341 exceeds limit $50,000, Recommendation: SELL 10 SPY strangles (vega impact: -$25K), Estimated cost: $5,000 credit received. [ORANGE] Gamma +487 approaching limit 500, Recommendation: Close 3 highest-gamma positions. Today\\'s P&L Attribution: Delta: +$2,850, Gamma: +$1,200, Theta: +$1,250, Vega: -$3,500, Total: +$1,800. **End-of-Day Report**: Portfolio Summary: Capital: $5,000,000, Positions: 47, Daily P&L: +$18,500 (+0.37%). Greeks at Close: Delta: +2,100, Gamma: +320, Theta: +$980, Vega: +$38,000. Risk Alerts Today: 3 Orange alerts (gamma), 1 Red alert (vega at 2:15pm, hedged), Actions Taken: Sold 10 SPY strangles @ 2:20pm, Closed 2 high-gamma positions. Stress Test Results: -5% scenario: -$124,000 (-2.5%), -10% scenario: -$380,000 (-7.6%), -20% scenario: -$950,000 (-19.0%, OVER LIMIT!). Recommendation: Reduce delta exposure by 2,000 shares tomorrow.",
    keyPoints: [
      'Architecture: GreeksCalculator (1s update), RiskMonitor (check limits), HedgeRecommender (specific trades)',
      'Alert levels: Orange (80% of limit), Red (100% of limit); Red triggers SMS, Orange triggers email',
      'Hedge recommendations: Delta breach â†’ buy/sell shares; Gamma breach â†’ close high-gamma positions; Vega breach â†’ sell strangles',
      'P&L attribution: Track delta Ã— price_change + 0.5 Ã— gamma Ã— price_changeÂ² + theta Ã— time + vega Ã— IV_change',
      'EOD report: Daily P&L attribution, risk alerts summary, stress test results, recommendations for next day',
    ],
  },
  {
    id: 'module-project-options-platform-q-3',
    question:
      'For the Module Project Phase 4 (Backtesting Framework), design a comprehensive backtesting system for options strategies. The system should: (1) Load historical stock price and IV data, (2) Simulate strategy entries based on rules (e.g., sell iron condor when IV Rank > 70%), (3) Calculate realistic transaction costs and slippage, (4) Handle early exits, adjustments, and assignments, (5) Track performance metrics (Sharpe, max drawdown, win rate), (6) Compare multiple strategies head-to-head. Provide complete backtesting framework with realistic assumptions.',
    sampleAnswer:
      "Options Backtesting Framework: **Data Requirements**: Historical data: Daily OHLC prices, Implied volatility (ATM 30-day), Option chain snapshots (strikes, bid/ask, volume), Corporate actions (splits, dividends), Timeframe: 5-10 years minimum. **Backtester Architecture**: class OptionsBacktester: def __init__(self, historical_data): self.data = historical_data; self.engine = BlackScholesEngine(); self.positions = []; self.cash = 100000; # Starting capital; self.equity_curve = []; self.trades = []; self.slippage_pct = 0.02; # 2% of bid-ask spread; self.commission_per_contract = 0.65. **Entry Rules**: def check_entry_signal(self, date, strategy_type): iv_rank = self.calculate_iv_rank(date); if strategy_type == 'iron_condor': return iv_rank > 70; # High IV; elif strategy_type == 'long_straddle': return iv_rank < 30; # Low IV; return False. def calculate_iv_rank(self, date): current_iv = self.data.loc[date, 'iv']; iv_history_52w = self.data.loc[:date].tail(252)['iv']; iv_min = iv_history_52w.min(); iv_max = iv_history_52w.max(); return (current_iv - iv_min) / (iv_max - iv_min) Ã— 100. **Transaction Costs**: def calculate_transaction_cost(self, option_price, num_contracts): # Commission; commission = num_contracts Ã— self.commission_per_contract; # Slippage (pay ask when buying, receive bid when selling); bid_ask_spread = option_price Ã— 0.10; # Assume 10% spread; slippage = num_contracts Ã— bid_ask_spread Ã— self.slippage_pct; total_cost = commission + slippage; return total_cost. **Position Management**: def enter_position(self, date, strategy): entry_price = self.data.loc[date, 'close']; entry_iv = self.data.loc[date, 'iv']; # Price strategy; total_cost = 0; for leg in strategy.legs: option_pricing = self.engine.price_option(entry_price, leg.strike, leg.expiration_days/365, entry_iv, leg.option_type); leg_cost = option_pricing.price Ã— abs(leg.quantity) Ã— 100; transaction_cost = self.calculate_transaction_cost(option_pricing.price, abs(leg.quantity)); if leg.quantity > 0: # Buying; total_cost += leg_cost + transaction_cost; else: # Selling; total_cost -= leg_cost - transaction_cost; # Check capital; if self.cash - total_cost < 0: return False; # Not enough capital; # Enter position; self.cash -= total_cost; self.positions.append({'strategy': strategy, 'entry_date': date, 'entry_price': entry_price, 'entry_cost': total_cost}); return True. **Exit Rules**: def check_exit_signal(self, position, current_date): days_held = (current_date - position['entry_date']).days; # Time-based: Exit 3 days before expiration; if days_held >= position['strategy'].legs[0].expiration_days - 3: return True, 'Time'; # Profit target: Exit at 75% of max profit; current_value = self.calculate_position_value(position, current_date); if current_value / abs(position['entry_cost']) > 1.75: return True, 'Profit'; # Stop loss: Exit at 50% max loss; if current_value / abs(position['entry_cost']) < 0.50: return True, 'Stop Loss'; return False, None. **Performance Tracking**: def calculate_metrics(self): equity_curve = pd.Series(self.equity_curve); returns = equity_curve.pct_change().dropna(); # Sharpe Ratio; sharpe = (returns.mean() / returns.std()) Ã— np.sqrt(252); # Max Drawdown; cum_returns = (1 + returns).cumprod(); running_max = cum_returns.expanding().max(); drawdown = (cum_returns - running_max) / running_max; max_drawdown = drawdown.min(); # Win Rate; trades_df = pd.DataFrame(self.trades); winning_trades = len(trades_df[trades_df['pnl'] > 0]); total_trades = len(trades_df); win_rate = winning_trades / total_trades if total_trades > 0 else 0; # Profit Factor; gross_profit = trades_df[trades_df['pnl'] > 0]['pnl'].sum(); gross_loss = abs(trades_df[trades_df['pnl'] < 0]['pnl'].sum()); profit_factor = gross_profit / gross_loss if gross_loss > 0 else 0; return {'sharpe': sharpe, 'max_drawdown': max_drawdown, 'win_rate': win_rate, 'profit_factor': profit_factor, 'total_return': (self.cash / 100000 - 1) Ã— 100}. **Backtest Execution**: def run_backtest(self, strategy_type, start_date, end_date): for date in pd.date_range(start_date, end_date): # Check exits; for position in self.positions[:]: should_exit, reason = self.check_exit_signal(position, date); if should_exit: self.exit_position(position, date, reason); # Check entries; if self.check_entry_signal(date, strategy_type): strategy = self.create_strategy(strategy_type, date); self.enter_position(date, strategy); # Update equity curve; self.equity_curve.append(self.calculate_total_equity(date)); return self.calculate_metrics(). **Example Backtest Results**: Strategy: Iron Condor (IV Rank > 70%); Period: 2018-2023 (5 years); Starting Capital: $100,000; Trades: 248; Win Rate: 68%; Avg Profit: $420; Avg Loss: -$950; Total Return: +82%; Annual Return: 12.8%; Sharpe Ratio: 1.15; Max Drawdown: -18%; Profit Factor: 2.1. **Realistic Assumptions**: Transaction costs: $0.65/contract + 2% slippage, Assignment risk: 5% for ITM options at expiration, Early assignment: 2% for deep ITM short options, No trading: Holidays, earnings days (1 day before/after), Market impact: Wider slippage for > 20 contracts. **Strategy Comparison**: Backtest multiple strategies: strats = ['iron_condor', 'long_straddle', 'bull_put_spread']; results = {}; for strat in strats: bt = OptionsBacktester(data); results[strat] = bt.run_backtest(strat, '2018-01-01', '2023-12-31'); # Compare; comparison_df = pd.DataFrame(results).T; print(comparison_df.sort_values('sharpe', ascending=False)).",
    keyPoints: [
      'Data requirements: 5-10 years daily OHLC + IV + option chains; calculate IV Rank for entry signals',
      'Transaction costs: $0.65/contract commission + 2% slippage (of bid-ask spread); realistic and material',
      'Entry rules: Iron condor when IV Rank > 70%, long straddle when < 30%; time-tested thresholds',
      'Exit rules: Time (3 days before expiration), profit target (75% max profit), stop loss (50% max loss)',
      'Metrics: Sharpe ratio (risk-adjusted return), max drawdown, win rate, profit factor; comprehensive evaluation',
    ],
  },
];
