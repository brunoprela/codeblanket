export const callPutDeepDiveQuiz = [
  {
    id: 'call-put-deep-dive-q-1',
    question:
      'A portfolio manager wants to implement a "wheel strategy" that systematically sells cash-secured puts to acquire stock at favorable prices, then sells covered calls for income. Design a production system that: (1) Scans for high-premium, quality stocks (IV > 40th percentile, market cap > $10B), (2) Sells puts at technical support levels (e.g., 5-10% OTM), (3) If assigned, immediately sells covered calls (2-5% OTM), (4) Tracks rolling returns and adjusts strikes based on volatility regime, (5) Implements risk management (max 5 positions, stop loss if stock drops 20% post-assignment). Provide the complete algorithm, position management logic, and explain optimal strike selection for both puts and calls based on IV rank.',
    sampleAnswer:
      'Production "Wheel Strategy" System: **Phase 1: Stock Screening** - Criteria: Market cap > $10B (liquid, stable), IV Rank > 40% (elevated premium), Price > $50 (avoid penny stocks), Average volume > 1M shares/day, Fundamental quality: Positive earnings, low debt-to-equity. Implementation: def screen_wheel_candidates(): stocks = get_sp500_constituents(); for stock in stocks: current_iv = get_implied_vol(stock); iv_rank = calculate_iv_percentile(current_iv, lookback=252); if iv_rank > 0.40 and meets_quality_criteria(stock): candidates.append(stock). **Phase 2: Put Strike Selection** - Technical Analysis: Identify support level (recent lows, moving averages, Fibonacci retracements). Strike placement: 5-10% OTM (below support), Delta target: 0.20-0.30 (20-30% probability of assignment), Premium threshold: >1% of strike price per 30 days (>12% annualized). Example: AAPL at $180, support at $170. Sell 170 put (6% OTM) for $3.50 (2.1% premium, 25% annualized). Risk: Max capital at risk = $170 × 100 = $17,000 per contract. **Phase 3: Assignment and Call Selling** - Upon assignment: Immediately logged as "wheel position" with cost basis = strike - premium collected. Call strike selection: 2-5% OTM (above resistance), Delta target: 0.30-0.40 (30-40% probability of assignment), Target premium: 1-2% of stock price per 30 days. Example: Assigned AAPL at $170, net basis $166.50. Resistance at $178. Sell 175 call for $2.80 (1.6% yield, 19% annualized). **Phase 4: Rolling Management** - If calls about to be assigned (stock > strike): Let it happen → realize gains, restart with new put. If puts about to be assigned (stock < strike): If still want stock: Accept assignment. If changed view: Roll put down and out (lower strike, longer expiration) for credit. If stock drops 20% post-assignment: Stop loss triggered → sell stock, realize loss, restart cycle. **Phase 5: Position Management** - Max positions: 5 simultaneous wheels (diversification). Capital allocation: Equal-weight, Max $20K per position. IV-based adjustments: High IV (>60%ile): Sell closer to ATM (higher premium, higher assignment risk). Low IV (<30%ile): Pause new puts, focus on managing existing positions. **Performance Tracking**: Track per position: Entry date, cost basis, premiums collected, current P&L, Days in position, Annualized return. Target metrics: 15-25% annualized return, Win rate >70% (puts expire worthless or calls assigned profitably), Max drawdown <15%. **Risk Management**: Diversification: Max 2 positions in same sector. Earnings avoidance: Close positions before earnings (volatility spike risk). Black swan protection: Keep 20% cash for market crashes (opportunity to sell puts at extreme premiums). **Example Execution**: Week 1: Screen shows MSFT at $380, IV rank 55%, support at $360. Sell 360 put (30 days) for $6 → $600 credit. Week 4: MSFT at $365 → assigned at $360. Net basis: $354. Week 5: Sell 365 call (30 days) for $5 → $500 credit. Week 8: MSFT at $370 → called away at $365. Total: Premiums = $600 + $500 = $1,100. Capital gain = ($365 - $354) × 100 = $1,100. Total profit = $2,200 on $36,000 capital (6.1% in 2 months = 37% annualized). **Code Structure**: class WheelStrategy: positions = []; def scan_candidates(): ...; def sell_put(stock, strike, expiration): ...; def handle_assignment(position): ...; def sell_covered_call(position): ...; def check_stop_losses(): ...; def calculate_performance(): ...',
    keyPoints: [
      'Sell puts at technical support (5-10% OTM) with IV rank > 40% for elevated premium',
      'Upon assignment, immediately sell covered calls 2-5% OTM (above resistance) for income',
      'Position management: Max 5 positions, equal-weight, 20% stop loss post-assignment',
      'IV-based adjustments: High IV → sell closer to ATM; low IV → pause new puts',
      'Target: 15-25% annualized return, >70% win rate, focus on quality stocks only',
    ],
  },
  {
    id: 'call-put-deep-dive-q-2',
    question:
      'Design a "put-call parity arbitrage scanner" for algorithmic traders that monitors option chains in real-time and executes risk-free arbitrage when violations exceed transaction costs. The system must: (1) Subscribe to real-time options quotes (bid/ask), (2) Calculate theoretical put-call parity for each strike/expiration, (3) Detect deviations > $0.20 (after costs), (4) Simulate execution with legs executed simultaneously (avoid leg risk), (5) Backtest on historical data to measure false positive rate and expected daily P&L. Explain the arbitrage execution flow, handling of dividends/interest rates, and why these opportunities are rare (HFT competition). Include code for violation detection and explain risks even in "risk-free" arbitrage.',
    sampleAnswer:
      'Real-time Put-Call Parity Arbitrage System: **Architecture**: Data feed: FIX protocol connection to exchange (OPRA for options). Latency: Co-located servers at exchange (sub-millisecond). Compute: C++ pricing engine, Python strategy logic. Execution: Smart order router with simultaneous leg execution. **Put-Call Parity Violation Detection**: Theory: C - P = S - K×e^(-rT) + PV(dividends). Deviation: If |C_market - P_market - (S - K×e^(-rT) + PV(div))| > cost_threshold → arbitrage. Algorithm: def detect_arbitrage(option_chain): for strike in strikes: call_mid = (call_bid + call_ask) / 2; put_mid = (put_bid + put_ask) / 2; stock_price = get_stock_price(); pv_strike = strike × exp(-r × T); pv_dividends = calculate_dividend_pv(); theoretical = stock_price - pv_strike + pv_dividends; market = call_mid - put_mid; deviation = abs(market - theoretical); if deviation > cost_threshold: yield ArbitrageOpportunity(call, put, stock, deviation). **Transaction Cost Modeling**: Per-leg costs: Call/put: $0.10 commission + $0.03 bid-ask slippage = $0.13 each. Stock: $0.001 per share = $0.10 per 100 shares. Borrowing/lending: Strike×e^(-rT) has interest rate spread. Total: ~$0.40 per share round-trip. Threshold: Need deviation > $0.40 to profit. **Execution Flow (Call Overpriced Case: C - P > S - K×e^(-rT))**: Simultaneous legs: (1) Sell call at bid price. (2) Buy put at ask price. (3) Buy stock at ask price. (4) Borrow cash = K×e^(-rT) at risk-free rate. At expiration: If S_T > K: Call assigned → deliver stock at K, put expires, receive K from assignment. If S_T < K: Put exercise → sell stock at K, call expires, receive K from exercise. Either way: Receive K at expiration. Repay loan: K×e^(-rT) grows to K. Profit = (C_market - P_market) - (S - K×e^(-rT)) - costs. **Dividend Adjustment**: Critical: Must adjust for dividends paid before expiration. If ex-div date during option life: PV(dividends) = div × e^(-r × t_div); Add to RHS: C - P = S - K×e^(-rT) + PV(div). Example: Stock at $100, $1 dividend in 15 days. PV(div) ≈ $0.998. Adjusted parity: C - P = 100 - 100×e^(-0.05×0.25) + 0.998 = $2.24. **Interest Rate Handling**: Use appropriate risk-free rate: For T < 1 year: Use Treasury bill rate matching expiration. For stock lending: May use different rate (repo rate). Fed funds rate: Overnight rate, relevant for very short-term. **Why Arbitrage Is Rare**: HFT competition: Firms with sub-microsecond latency exploit instantly. Co-location: Servers physically at exchange (speed of light advantage). Algo sophistication: Thousands of firms running similar scanners. Transaction costs: Retail pays $0.65/contract, killing most opportunities. Wide spreads: Illiquid options have large bid-ask, preventing tight arbitrage. Expected daily opportunities: 1-3 per day across all strikes/expirations. Expected profit per opportunity: $20-80 (after costs). **Execution Risks (Despite "Risk-Free" Label)**: Leg risk: May fill on 1-2 legs but not all → naked exposure. Example: Sell call, buy put, but stock order doesn\'t fill. Now have synthetic short stock without offsetting long. Pin risk: Stock closes exactly at strike → assignment uncertain. Early exercise: American options assigned early, disrupting arbitrage. Quote latency: Quotes stale by milliseconds, opportunity vanishes. Corporate actions: Dividend announcement mid-trade changes valuation. **Backtest Implementation**: Historical data: Tick-by-tick options quotes (expensive datasets). Simulate: For each timestamp, check all strikes for violations. Model execution: Assume fill at mid-price (optimistic) or worse (realistic). Account for: Bid-ask slippage (uniform random between bid-mid-ask), Partial fills (probability based on liquidity), Cancellation risk (orders cancelled if quotes move). Results: False positive rate: ~90% (quotes stale or disappeared by execution). True arbitrage rate: ~10% of detected violations. Expected daily P&L: $100-500 (after costs, assuming 10-50 contracts per day). Sharpe ratio: 2-3 (low volatility, consistent small profits). **Production Considerations**: Capital requirements: $500K+ minimum (simultaneous stock + option positions). Broker requirements: Portfolio margin account, Options level 5 (naked), Direct market access (DMA) for speed. Monitoring: Real-time P&L tracking, Auto-kill switch if daily loss > $5K. Compliance: Ensure no wash sales, Track all trades for tax reporting. **Code Example**: class PutCallArbitrage: def calculate_theoretical_parity(S, K, r, T, div): pv_strike = K × exp(-r × T); pv_div = div × exp(-r × t_div); return S - pv_strike + pv_div; def check_opportunity(call, put, stock, strike, rate, tte, div): theoretical = self.calculate_theoretical_parity(stock.price, strike, rate, tte, div); market = call.mid - put.mid; deviation = abs(market - theoretical); if deviation > 0.40: return Opportunity(deviation, call, put, stock); def execute_arbitrage(opp): # Simultaneous order submission: orders = [SellOrder(opp.call), BuyOrder(opp.put), BuyOrder(opp.stock)]; results = submit_simultaneously(orders); if all_filled(results): log_profit(opp.deviation - 0.40); else: cancel_all_and_exit(results).',
    keyPoints: [
      'Put-call parity: C - P = S - K×e^(-rT) + PV(dividends); violations > $0.40 may be arbitrage',
      'Execution: Simultaneous legs (sell call, buy put, buy stock, borrow cash) to avoid leg risk',
      'Rare due to HFT: Sub-millisecond competition, co-location, sophisticated algos',
      'Risks: Leg risk (partial fills), pin risk (assignment uncertainty), stale quotes, early exercise',
      'Expected P&L: $100-500/day across all opportunities, but 90% false positive rate',
    ],
  },
  {
    id: 'call-put-deep-dive-q-3',
    question:
      'Explain the concept of "synthetic positions" and their practical applications in professional trading. Design a system that automatically identifies when synthetics offer advantages over direct positions due to: (1) Better execution prices (tighter bid-ask on options vs stock), (2) Margin efficiency (lower capital requirements), (3) Tax treatment (e.g., constructive sale rules), (4) Hard-to-borrow stocks (expensive to short). For each advantage, provide concrete examples with calculations. Implement a "synthetic optimizer" that recommends whether to trade the natural position or synthetic based on current market conditions.',
    sampleAnswer:
      'Synthetic Positions Optimizer: **Synthetic Position Definitions**: Synthetic long stock = Long call + Short put (same strike/expiration). Synthetic short stock = Short call + Long put. Synthetic long call = Long stock + Long put (protective put). Synthetic short call = Short stock + Short put. Synthetic long put = Short stock + Long call. Synthetic short put = Long stock + Short call (covered call). **Advantage 1: Better Execution (Bid-Ask Savings)**: Scenario: Want to buy 100 shares of illiquid stock. Natural: Buy stock, bid-ask spread = $0.50 → cost $50. Synthetic: Buy ATM call ($3.50 bid, $3.60 ask), Sell ATM put ($3.40 bid, $3.50 ask), Net cost: $3.60 - $3.40 = $0.20 (vs $0.50 for stock) → save $30. Calculation: def compare_execution_cost(stock_spread, call_spread, put_spread): stock_cost = stock_spread × 100; synthetic_cost = (call_spread + put_spread) × 100; savings = stock_cost - synthetic_cost; return savings. Example: Illiquid stock with $0.50 spread vs liquid ATM options with $0.10 spreads → save $30 per 100 shares. **Advantage 2: Margin Efficiency**: Scenario: Want $100K stock exposure. Natural: Buy 1000 shares at $100 = $100K capital. Margin account: 50% margin = $50K required. Synthetic: Sell 10 × 100-strike puts (cash-secured) = $100K collateral. But: Can use portfolio margin (risk-based) → only $20K required. Capital efficiency: 5× leverage vs buying stock. Calculation: def compare_margin_requirements(stock_price, shares, portfolio_margin_pct): stock_margin = stock_price × shares × 0.50; # Reg T: 50%. synthetic_margin = stock_price × shares × portfolio_margin_pct; # e.g., 20%. savings = stock_margin - synthetic_margin; return savings. Example: $100K exposure with portfolio margin → only $20K tied up vs $50K for stock. **Advantage 3: Tax Treatment (Constructive Sale Rules)**: Scenario: Own stock with large unrealized gain, want to hedge but avoid constructive sale. Natural: Short stock or buy put → triggers constructive sale (taxable event). Synthetic: Sell call + Buy put = collar → if strikes too close (within 85%), constructive sale. Compliant strategy: Sell call 15% OTM + Buy put 15% OTM → no constructive sale. Can defer taxes while still protecting downside. Example: Stock at $100, gain from $50 cost basis. Hedge: Sell 115 call + Buy 85 put (30% collar width) → no taxable event. Protection: Downside limited to $85, upside capped at $115. **Advantage 4: Hard-to-Borrow Stocks**: Scenario: Want to short stock with high borrow cost (10% annually = $10K per $100K position). Natural: Short stock → pay $10K/year borrow fee + locate fee + dividends. Synthetic: Sell call + Buy put (synthetic short) → no borrow cost. Cost comparison: Stock short: $10K borrow fee. Synthetic: Spread costs ~$100-300 → save $9,700/year! Calculation: def compare_short_costs(stock_value, borrow_rate, option_spreads): stock_borrow_cost = stock_value × borrow_rate; synthetic_spread_cost = option_spreads × 100; savings = stock_borrow_cost - synthetic_spread_cost; return savings. Example: Short $100K of hard-to-borrow stock (10% borrow) vs synthetic short → save $9,700 annually. **Synthetic Optimizer Algorithm**: def recommend_position(position_type, stock, strikes): # Fetch current market data: stock_price, stock_spread, call_bid, call_ask, put_bid, put_ask, borrow_rate = get_market_data(stock); # Calculate costs for natural position: if position_type == "long_stock": natural_cost = stock_price × shares + stock_spread × shares / 2; natural_margin = stock_price × shares × 0.50; elif position_type == "short_stock": natural_cost = stock_price × shares; natural_cost += stock_price × shares × borrow_rate; # Annual borrow; # Calculate costs for synthetic: if position_type == "long_stock": synthetic_cost = (call_ask - put_bid) × shares × 100; synthetic_margin = calculate_portfolio_margin(call, put); elif position_type == "short_stock": synthetic_cost = (call_bid - put_ask) × shares × 100; synthetic_margin = 0; # No borrow; # Compare: total_natural_cost = natural_cost + natural_margin × cost_of_capital; total_synthetic_cost = synthetic_cost + synthetic_margin × cost_of_capital; if total_synthetic_cost < total_natural_cost: return "Use Synthetic", total_natural_cost - total_synthetic_cost; else: return "Use Natural", total_synthetic_cost - total_natural_cost. **Production Implementation**: Real-time monitoring: Check every position for synthetic advantage. Auto-recommend: If savings > $100, alert trader. Execution: One-click synthetic order submission. Risk management: Monitor both legs, ensure fills. Tax optimization: Flag constructive sale violations. **Example Output**: Position: Long 100 shares AAPL at $180. Natural cost: $18,000 + $25 spread = $18,025. Margin required: $9,000. Synthetic (buy 180 call, sell 180 put): Cost: $3.60 - $3.40 = $0.20 per share = $20. Margin required: $5,000 (portfolio margin). Comparison: Synthetic saves $5 on execution + $4,000 on margin = $4,005 advantage. Recommendation: Use synthetic long (buy call + sell put). **When NOT to Use Synthetics**: Dividend capture: Stock pays dividend, synthetics miss it. Early exercise: American options assigned early, disrupting position. Complexity: More legs = more things to go wrong. Liquidity: If options illiquid, spreads negate advantage. Simplicity: For small positions (<$10K), not worth the complexity.',
    keyPoints: [
      'Synthetic long stock = Long call + Short put; offers execution, margin, tax, and borrow advantages',
      'Execution savings: Illiquid stock ($0.50 spread) vs liquid options ($0.10 spreads) → save $30',
      'Margin efficiency: Portfolio margin on synthetics (20%) vs stock (50%) → 2.5× leverage',
      'Hard-to-borrow: Shorting expensive stock (10% borrow) vs synthetic short ($100 spreads) → save $9,700/year',
      'Optimizer: Compare total costs (execution + margin + borrow) and recommend natural vs synthetic',
    ],
  },
];
