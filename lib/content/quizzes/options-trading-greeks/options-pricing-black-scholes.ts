export const optionsPricingBlackScholesQuiz = [
  {
    id: 'options-pricing-black-scholes-q-1',
    question:
      'Design a production-grade "options pricing engine" that uses Black-Scholes as the base model but adjusts for real-world violations of BS assumptions. The system should: (1) Implement standard BS for European options, (2) Add dividend adjustments for discrete dividends (not continuous yield), (3) Implement Bjerksund-Stensland approximation for American options, (4) Apply volatility smile adjustment (interpolate IV by strike), (5) Cache calculations for performance, (6) Handle edge cases (T→0, extreme strikes, splits). Provide the complete architecture, explain when each model component is used, and discuss accuracy vs performance trade-offs.',
    sampleAnswer:
      'Production Options Pricing Engine Architecture: **Layer 1: Base Black-Scholes Engine** - Standard BS implementation for European options (covered in section). Optimizations: Vectorized calculations using numpy for entire option chains. LRU cache for repeated calculations (same inputs). Pre-compute norm.cdf values for common ranges. **Layer 2: Dividend Adjustment** - Problem: BS assumes no dividends; real stocks pay quarterly dividends. Solution: Discrete dividend adjustment: For each dividend with ex-date before expiration: Subtract PV of dividend from stock price: S_adjusted = S - Σ(Div_i × e^(-r × t_i)). Use S_adjusted in BS formula. Algorithm: def adjust_for_dividends(S, dividends, r, T): S_adjusted = S; for div_amount, ex_date_days in dividends: if ex_date_days < T × 365: t = ex_date_days / 365; S_adjusted -= div_amount × exp(-r × t); return S_adjusted. Example: Stock at $100, $1 dividend in 30 days, option expires in 90 days. S_adjusted = $100 - $1×e^(-0.05×30/365) = $100 - $0.996 = $99.00. Use $99 in BS formula. **Layer 3: American Option Pricing** - Problem: BS is for European options; most equity options are American. Solution: Bjerksund-Stensland 2002 approximation (closed-form, very fast). For American calls on non-dividend stocks: Use BS (early exercise never optimal). For American calls with dividends: Check if early exercise optimal (if dividend > time value). For American puts: Always use B-S approximation (early exercise can be optimal). Implementation: def price_american_option(S, K, T, r, sigma, q, option_type): if option_type == "call" and q == 0: return black_scholes(S, K, T, r, sigma, "call"); # European = American; else: return bjerksund_stensland_2002(S, K, T, r, sigma, q, option_type). B-S formula (complex, see research papers): Involves beta, B_0, B_infinity calculations. Approximates optimal exercise boundary. Accuracy: Within $0.01 of binomial tree (1000 steps). Speed: 100× faster than binomial trees. **Layer 4: Volatility Smile Adjustment** - Problem: BS assumes constant vol; reality has smile/skew. Solution: Implied volatility surface: Store IV by (strike, expiration). Interpolate for any strike using cubic spline. Algorithm: def get_adjusted_volatility(strike, expiration, iv_surface): # Get IVs for this expiration; ivs_for_expiry = iv_surface[expiration]; strikes_for_expiry = [s for s, iv in ivs_for_expiry]; ivs = [iv for s, iv in ivs_for_expiry]; # Cubic spline interpolation; from scipy.interpolate import CubicSpline; cs = CubicSpline(strikes_for_expiry, ivs); return cs(strike). Example: Option chain shows: 95 strike: IV = 22%, 100 strike: IV = 20%, 105 strike: IV = 19%. For 102 strike: Interpolate → IV ≈ 19.4%. Use 19.4% in BS instead of flat 20%. **Layer 5: Edge Case Handling** - Case 1: T → 0 (expiration today): Use intrinsic value, bypass BS (numerical instability). if T < 1/365: return max(S - K, 0) if call else max(K - S, 0). Case 2: Deep ITM (S >> K or K >> S): Use approximations to avoid overflow. if S / K > 100: return S - K × exp(-r×T) if call else 0. Case 3: Very low volatility (σ < 0.1%): Return intrinsic value (option won\'t move). Case 4: Stock splits: Adjust strike and quantity. New_strike = Old_strike / split_ratio; New_quantity = Old_quantity × split_ratio. **Layer 6: Caching Strategy** - Cache key: Hash of (S rounded to $0.01, K, T in hours, r, σ, option_type, dividends). LRU cache with 10,000 entry limit. Invalidation: Clear cache on: Market open (stale yesterday\'s prices), Corporate action announcements, Volatility regime change (VIX move > 5 points). Performance: 1000× speedup on repeated calculations. Memory: ~50MB for 10,000 cached entries. **Complete System Flow**: def price_option(ticker, strike, expiration, option_type): # 1. Get market data; S = get_stock_price(ticker); r = get_risk_free_rate(expiration); # 2. Get dividends; dividends = get_dividends_before(ticker, expiration); S_adjusted = adjust_for_dividends(S, dividends, r, time_to_exp); # 3. Get IV (smile-adjusted); iv = get_adjusted_volatility(strike, expiration, iv_surface[ticker]); # 4. Check cache; cache_key = hash_inputs(S_adjusted, strike, time_to_exp, r, iv, option_type); if cache_key in price_cache: return price_cache[cache_key]; # 5. Select model; if is_american(ticker, option_type): price = price_american_option(...); else: price = black_scholes(...); # 6. Cache result; price_cache[cache_key] = price; return price. **Accuracy vs Performance Trade-offs**: High accuracy: Binomial trees (1000+ steps) or Monte Carlo (10k+ paths). Time: 10-100ms per option. Use case: Exotic options, regulatory reporting. Medium accuracy: B-S with smile adjustment. Time: 0.1-1ms per option. Use case: Most trading applications, market making. Low accuracy: Raw Black-Scholes (no adjustments). Time: 0.01ms per option. Use case: Quick estimates, backtesting. **Production Metrics**: Latency: p50: 0.5ms, p99: 5ms. Throughput: 10,000 prices/second (single threaded). Accuracy: MAE < $0.05 vs market prices for liquid options. Memory: 200MB resident (includes cache). **Testing Strategy**: Unit tests: Each component (BS, dividends, American, smile). Integration tests: Full pricing flow. Benchmark against: Binomial trees (1000 steps) as ground truth, Market prices for liquid options. Stress tests: Extreme strikes, very short/long expirations, High/low volatility regimes.',
    keyPoints: [
      'Discrete dividend adjustment: Subtract PV of dividends from stock price before BS calculation',
      'American options: Bjerksund-Stensland approximation (100× faster than binomial, <$0.01 error)',
      'Volatility smile: Interpolate IV by strike using cubic spline instead of flat volatility',
      'Edge cases: Use intrinsic value for T<1 day, approximations for deep ITM, handle splits',
      'Caching: LRU cache with 10k entries provides 1000× speedup on repeated calculations',
    ],
  },
  {
    id: 'options-pricing-black-scholes-q-2',
    question:
      'Explain the concept of "implied volatility" and its relationship to Black-Scholes pricing. Design an "IV calculator" that: (1) Takes option market price as input and solves for IV using Newton-Raphson method, (2) Handles edge cases where IV solving fails (extreme OTM, near expiration), (3) Implements bisection method as fallback, (4) Validates IV is in reasonable range (5%-200%), (5) Optimizes for speed (target <1ms per calculation). Provide the complete algorithm with numerical methods, explain why IV is the "language of options markets," and discuss the volatility smile phenomenon.',
    sampleAnswer:
      'Implied Volatility (IV) Deep Dive: **What is Implied Volatility?** - Definition: The volatility value that, when input to Black-Scholes, produces the observed market price. Given: Market price C_market, solve for σ such that BS(S, K, T, r, σ) = C_market. Why it matters: Volatility is the ONLY unknown input to BS (S, K, T, r are observable). IV represents market\'s expectation of future volatility. Options are quoted in IV terms, not dollar prices (traders say "20 vol" not "$3.50"). **IV as "Language of Options"**: Dollar prices are misleading: $3.50 call could be cheap or expensive depending on strike/time/stock price. IV normalizes: 20% IV is directly comparable across all strikes and expirations. Trading in IV space: Market makers quote "25 vol bid, 26 vol offer" not dollar prices. Relative value: If one strike trades at 22% IV and another at 19%, you know which is "cheap". **Newton-Raphson Method for IV Solving**: Algorithm: Start with initial guess σ_0 (e.g., 0.20 = 20%). Iterate: σ_{n+1} = σ_n - f(σ_n) / f\'(σ_n), where f(σ) = BS(S,K,T,r,σ) - C_market, f\'(σ) = vega (sensitivity to σ). Convergence: Usually 3-5 iterations to reach accuracy of 0.0001. Implementation: def implied_volatility_newton(S, K, T, r, market_price, option_type, initial_guess=0.20, max_iter=100, tolerance=1e-6): sigma = initial_guess; for i in range(max_iter): # Calculate BS price and vega; bs_price = black_scholes(S, K, T, r, sigma, option_type); vega = calculate_vega(S, K, T, r, sigma); # Newton step; diff = bs_price - market_price; if abs(diff) < tolerance: return sigma; if vega < 1e-10: # Vega too small, Newton fails; return None; sigma = sigma - diff / vega; # Keep sigma positive and reasonable; sigma = max(0.01, min(sigma, 5.0)); # Check if sigma is reasonable; if sigma < 0.01 or sigma > 5.0: return None; return sigma. **Edge Cases Where Newton Fails**: Case 1: Deep OTM options (vega ≈ 0). Problem: Vega near zero → division by zero. Solution: Use bisection method (slower but robust). Case 2: Near expiration (T < 1 day). Problem: Vega collapses, price dominated by intrinsic. Solution: If T < 1/365, estimate IV from previous day or use intrinsic-based heuristic. Case 3: Market price below intrinsic value. Problem: No positive IV can produce price < intrinsic. Solution: Return error, flag as bad data. Case 4: Market price above theoretical max. For calls: Max = S (if K = 0); For puts: Max = K. Solution: Return error or cap IV at 200%. **Bisection Method (Fallback)**: More robust but slower (10-20 iterations vs 3-5 for Newton). Algorithm: def implied_volatility_bisection(S, K, T, r, market_price, option_type, max_iter=50): sigma_low, sigma_high = 0.01, 5.0; for i in range(max_iter): sigma_mid = (sigma_low + sigma_high) / 2; bs_price = black_scholes(S, K, T, r, sigma_mid, option_type); if abs(bs_price - market_price) < 1e-6: return sigma_mid; if bs_price < market_price: sigma_low = sigma_mid; else: sigma_high = sigma_mid; return (sigma_low + sigma_high) / 2. **Combined Robust IV Solver**: def calculate_implied_volatility(S, K, T, r, market_price, option_type): # 1. Validate inputs; intrinsic = max(S - K, 0) if option_type == "call" else max(K - S, 0); if market_price < intrinsic - 0.01: return None, "Price below intrinsic"; if market_price > S + 0.01 (for calls) or market_price > K + 0.01 (for puts): return None, "Price above theoretical max"; # 2. Try Newton-Raphson first (fast); iv_newton = implied_volatility_newton(S, K, T, r, market_price, option_type); if iv_newton and 0.05 <= iv_newton <= 2.0: return iv_newton, "Newton"; # 3. Fallback to bisection (robust); iv_bisection = implied_volatility_bisection(S, K, T, r, market_price, option_type); if iv_bisection: return iv_bisection, "Bisection"; # 4. Failed; return None, "IV calculation failed". **Performance Optimization**: Initial guess: Use ATM IV as starting point (converges faster). Vectorization: Calculate IV for entire option chain in parallel. Caching: Cache IVs for recent calculations. Target: <1ms per IV calculation (achieved with optimized implementation). **Volatility Smile/Skew Phenomenon**: Observation: For same expiration, IV varies by strike. Volatility Smile: IV high for OTM calls and puts (U-shaped curve). Common in: FX options, commodities. Volatility Skew: IV decreases as strike increases (left skew). Common in: Equity options (crash protection premium on puts). Example SPY option chain: 95% strike (5% OTM put): IV = 22%, 100% strike (ATM): IV = 20%, 105% strike (5% OTM call): IV = 19%. Why smile exists: Fat tails: Market crashes more common than normal distribution predicts, Supply/demand: Puts in high demand (portfolio insurance), Leverage effect: Stock down → leverage up → volatility up. **Why Smile Matters**: Trading: Can\'t use single IV for all strikes, Arbitrage: Mispriced options relative to smile, Hedging: Different IVs mean different Greeks. **IV Surface**: 3D surface: IV = f(strike, expiration). Term structure: IV can vary by expiration too. Models: Practitioners use SABR, SVI models to fit smile. **Real-World IV Analysis**: # Calculate IV for option chain; strikes = [95, 97.5, 100, 102.5, 105]; market_prices = [6.20, 4.10, 2.80, 1.90, 1.30]; ivs = []; for strike, price in zip(strikes, market_prices): iv, method = calculate_implied_volatility(100, strike, 0.25, 0.05, price, "call"); ivs.append(iv); print(f"Strike ${strike}: IV = {iv*100:.1f}%"); # Plot smile; plt.plot(strikes, [iv*100 for iv in ivs]); plt.xlabel("Strike"); plt.ylabel("Implied Volatility (%)"); plt.title("Volatility Smile"); plt.show().',
    keyPoints: [
      "Implied volatility: The σ that makes BS(σ) = market price; represents market's future volatility expectation",
      'Newton-Raphson: Fast method (3-5 iterations) using vega as derivative: σ_{n+1} = σ_n - (BS - Price) / vega',
      'Bisection fallback: Robust for edge cases (deep OTM, near expiration) when Newton fails',
      'Volatility smile: IV varies by strike; OTM puts have higher IV (crash protection premium)',
      'Performance: Initial guess at ATM IV, vectorization, caching achieves <1ms per calculation',
    ],
  },
  {
    id: 'options-pricing-black-scholes-q-3',
    question:
      'Compare Black-Scholes to alternative option pricing models (Binomial Trees, Monte Carlo, Heston, SABR). For each model, explain: (1) Key differences from BS, (2) Advantages and disadvantages, (3) When to use each model, (4) Computational complexity (time and space), (5) Implementation considerations. Design a "model selector" that automatically chooses the appropriate pricing model based on option characteristics (American vs European, vanilla vs exotic, time to expiration, etc.). Include performance benchmarks and accuracy comparisons.',
    sampleAnswer:
      'Options Pricing Model Comparison: **Model 1: Black-Scholes (BS)** - Characteristics: Closed-form solution, European options only, Constant volatility assumption, Log-normal stock prices, No early exercise. Advantages: Extremely fast (microseconds), Easy to implement, Analytical Greeks, Industry standard. Disadvantages: European only (poor for American), Ignores volatility smile, Assumes constant volatility, No jumps or stochastic vol. When to use: Liquid European options, Quick fair value estimates, When speed matters (HFT, market making), ATM options on non-dividend stocks. Computational complexity: O(1) - constant time. Implementation: One function call, ~50 lines of code. Accuracy: Good for ATM European options (±5% of true value), Poor for American puts (underprices by 5-15%). **Model 2: Binomial Trees (Cox-Ross-Rubinstein)** - Characteristics: Discrete time steps, Models stock path as up/down moves, Can handle American exercise, Backward induction from expiration. Advantages: Handles American options correctly, Can incorporate dividends easily, Intuitive (tree visualization), Flexible (can add features). Disadvantages: Slow (O(n²) for n steps), Requires many steps for accuracy (n>1000), Memory intensive for long-dated options. When to use: American options (puts especially), Options with discrete dividends, When accuracy matters > speed, For benchmark/validation. Computational complexity: Time O(n²), Space O(n) with optimization. Steps needed: n=100: ±$0.50 error, n=1000: ±$0.05 error, n=10000: ±$0.01 error. Implementation: def binomial_tree(S, K, T, r, sigma, n, option_type, american=True): dt = T / n; u = exp(sigma × sqrt(dt)); d = 1/u; p = (exp(r×dt) - d) / (u - d); # Build tree; prices = [[S × u^j × d^(i-j) for j in range(i+1)] for i in range(n+1)]; values = [max(prices[n][j] - K, 0) for j in range(n+1)] if call else [...]; # Backward induction; for i in range(n-1, -1, -1): for j in range(i+1): discounted = exp(-r×dt) × (p × values[j+1] + (1-p) × values[j]); if american: early_exercise = max(prices[i][j] - K, 0); values[j] = max(discounted, early_exercise); else: values[j] = discounted; return values[0]. Time: n=1000 steps: ~10ms per option. **Model 3: Monte Carlo Simulation** - Characteristics: Simulate thousands of stock price paths, Average discounted payoffs, Good for path-dependent options, Converges slowly (√n). Advantages: Handles exotic options (Asians, barriers, lookbacks), Multi-asset options (baskets, rainbows), Flexible (any payoff structure), Scales well to high dimensions. Disadvantages: Very slow (seconds per option), No early exercise (without Longstaff-Schwartz), High variance (need many paths), Difficult to compute Greeks. When to use: Exotic/path-dependent options, Multi-asset options, When accuracy matters and you have time, Validation of other models. Computational complexity: O(n×m) for n paths, m time steps. Paths needed: n=10k: ±$0.50, n=100k: ±$0.15, n=1M: ±$0.05. Implementation: def monte_carlo(S, K, T, r, sigma, n_paths, n_steps): dt = T / n_steps; paths = np.zeros((n_paths, n_steps+1)); paths[:,0] = S; for t in range(n_steps): Z = np.random.standard_normal(n_paths); paths[:,t+1] = paths[:,t] × exp((r - 0.5×sigma²)×dt + sigma×sqrt(dt)×Z); payoffs = np.maximum(paths[:,-1] - K, 0); # Calls; price = exp(-r×T) × np.mean(payoffs); return price. Time: 100k paths: ~500ms per option. **Model 4: Heston (Stochastic Volatility)** - Characteristics: Volatility follows mean-reverting process, dV = κ(θ - V)dt + ξ√V dW_v, Correlated with stock price, Semi-closed form via Fourier transform. Advantages: Captures volatility smile naturally, More realistic than constant vol, Still relatively fast (via characteristic function), Handles correlation between price and vol. Disadvantages: 5 parameters to calibrate (κ, θ, ξ, ρ, V_0), More complex than BS, Requires numerical integration, Calibration unstable. When to use: When volatility smile is important, Medium to long-dated options, Volatility derivatives (VIX options), Structured products. Computational complexity: O(n) for n integration points. Calibration: Fit parameters to market smile (optimization problem, 10-60 seconds). Time: ~5ms per option after calibration. **Model 5: SABR (Stochastic Alpha Beta Rho)** - Characteristics: Models forward price and vol together, dF = σF^β dW_1, dσ = ασ dW_2, dW_1 dW_2 = ρ dt, Produces closed-form implied vol formula. Advantages: Perfect for fitting volatility smile, Used by practitioners for FX and rates, Fast (closed-form approximation), Only 4 parameters (α, β, ρ, ν). Disadvantages: Approximation (not exact), Can produce arbitrage under certain parameters, Complex calibration. When to use: Market making (need to quote IVs), Interpolating/extrapolating smile, FX and interest rate options, When speed + smile matters. Time: <1ms per option. **Model Selector Algorithm**: def select_pricing_model(option): # American options with dividends; if option.style == "American" and option.dividends and option.time_to_exp > 0.1: if option.accuracy_requirement == "high": return BinomialTree(steps=1000), "High accuracy needed"; else: return BjerkstundStensland(), "American approx fast"; # European vanilla; elif option.style == "European" and option.is_vanilla(): if option.time_to_exp < 0.01: # < 4 days; return IntrinsicValue(), "Near expiration"; elif option.requires_smile: return BlackScholes WithSmile(), "Smile adjustment needed"; else: return BlackScholes(), "Standard BS sufficient"; # Exotic options; elif option.is_exotic(): if option.is_path_dependent(): return MonteCarlo(paths=100000), "Path-dependent exotic"; elif option.is_multi_asset(): return MonteCarlo(paths=50000), "Multi-asset option"; else: return BinomialTree(steps=500), "Non-vanilla exotic"; # Vol products; elif option.underlying == "VIX": return HestonModel(), "Volatility derivative"; else: return BlackScholes(), "Default to BS". **Performance Benchmark (1000 options)**: Black-Scholes: 10ms total (0.01ms each), B-S with smile: 50ms total (0.05ms each), Bjerksund-Stensland: 100ms total (0.1ms each), Binomial (n=100): 5,000ms (5ms each), Binomial (n=1000): 50,000ms (50ms each), Monte Carlo (10k paths): 300,000ms (300ms each), Heston: 5,000ms (5ms each, after calibration). **Accuracy Comparison (American put, S=K=100, T=0.25, σ=0.20)**: True value (Binomial n=10000): $3.85, Black-Scholes: $3.54 (underprices by $0.31 = 8%), Bjerksund-Stensland: $3.84 (within $0.01), Binomial n=100: $3.82 (±$0.03), Binomial n=1000: $3.85 (±$0.00), Monte Carlo 10k paths: $3.87 ± $0.15 (high variance), Heston: $3.86 (if calibrated well). **Practical Recommendations**: High-frequency trading: Black-Scholes only (speed critical). Market making: BS with smile adjustment. Prop trading: Binomial trees for American, BS for European. Risk management: Binomial n=1000 for book revaluation. Exotic structuring: Monte Carlo with variance reduction. Research/validation: Multiple models + comparison.',
    keyPoints: [
      'Black-Scholes: Fastest (0.01ms), European only, good for ATM vanilla options',
      'Binomial trees: O(n²), handles American correctly, need n>1000 for accuracy, 10-50ms',
      'Monte Carlo: Flexible for exotics, very slow (300ms), high variance, hard to compute Greeks',
      'Heston: Stochastic vol, captures smile naturally, 5ms after calibration, 5 parameters',
      'Model selection: Use BS for speed, binomial for American, Monte Carlo for path-dependent exotics',
    ],
  },
];
