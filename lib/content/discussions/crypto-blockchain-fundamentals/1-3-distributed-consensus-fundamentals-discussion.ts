export const distributedConsensusFundamentalsDiscussion = [
  {
    id: 1,
    question:
      "A new blockchain claims to have 'solved the blockchain trilemma' by achieving decentralization, security, and scalability simultaneously through a novel consensus mechanism. Their whitepaper shows impressive benchmarks (100,000 TPS) with 10,000 validator nodes. As a technical advisor, what questions would you ask to verify these claims? What are the likely hidden trade-offs? How would you design tests to validate their consensus mechanism under adversarial conditions?",
    answer: `The "blockchain trilemma solved" claim is a massive red flag. The trilemma exists because of fundamental constraints in distributed systems (CAP theorem, network latency, Byzantine agreement complexity). Any claim to solve it requires extraordinary scrutiny. Key questions: (1) What's the validator selection mechanism? (10,000 validators suggests permissioned or high barrier to entry), (2) What's communication complexity? (O(nÂ²) for 10,000 nodes = 100M messages per round), (3) What's actual network latency? (100K TPS meaningless if 10-second finality), (4) What's the Byzantine fault tolerance threshold? (If < 33% malicious tolerance, it's weaker than standard BFT). Hidden trade-offs likely include: Strong synchrony assumptions (doesn't work with network partitions), High bandwidth requirements (each validator needs gigabit connection), Centralized validator set (permissioned entry), Economic barriers (expensive to run validator). Testing approach: (1) Network partition test (split 10K validators, see if consensus breaks), (2) Byzantine validator test (make 33% malicious, try double-spend), (3) Latency stress test (add 500ms delays, measure impact), (4) Sybil attack (try to flood with fake validators). Most "trilemma solved" projects sacrifice decentralization through high validator costs or permissioned entry.`,
  },
  {
    id: 2,
    question:
      'Explain why FLP impossibility means perfect consensus is impossible, yet Bitcoin achieves consensus in practice. What assumptions does Bitcoin make that circumvent FLP? If a powerful adversary (nation-state) wanted to prevent Bitcoin consensus, how would they exploit these assumptions? Design a realistic attack scenario.',
    answer: `FLP impossibility proves deterministic consensus is impossible in asynchronous systems with one faulty process. Bitcoin circumvents this through: (1) Synchrony assumptions (10-minute blocks assume bounded message delays), (2) Probabilistic finality (never 100% certain, only exponentially likely), (3) Incentive assumptions (miners prefer honest behavior), (4) Honest majority assumption (>50% hash power honest). Nation-state attack on these assumptions: Target synchrony by controlling internet routing (BGP hijacking) to partition network into isolated islands. Each island mines its own chain. When partition heals, longest chain wins, others lose rewards. Cost: Control major internet exchange points (IXPs) or submarine cables. Realistic scenario: China's Great Firewall plus ISP cooperation could partition 60% of hash power, causing 40% to waste resources on orphaned blocks. Alternative attack: Corner ASIC market through export controls, concentrate 51% hash power. Cost: ~$10-20B for manufacturing control. More subtle: Introduce network delays targeting specific mining pools through traffic shaping, making their blocks arrive late and get orphaned. This doesn't break Bitcoin but makes it unreliable. Defense: Bitcoin can't fully prevent this; relies on globally distributed hash power and no single government controlling internet infrastructure.`,
  },
  {
    id: 3,
    question:
      'Compare safety vs liveness trade-offs in Bitcoin (Nakamoto consensus) versus Ethereum 2.0 (Gasper consensus). Under what attack scenarios does each prioritize safety over liveness, and vice versa? If you had to design consensus for a central bank digital currency (CBDC) handling $10 trillion daily, would you prioritize safety or liveness, and how would that influence your design choices?',
    answer: `Safety (no bad thing happens) vs Liveness (good thing eventually happens) trade-off is fundamental. Bitcoin prioritizes liveness: During network partition, both sides keep producing blocks (liveness preserved), but creates conflicting chains (safety violated temporarily). When partition heals, longest chain wins, achieving eventual safety. Ethereum 2.0 (Gasper) prioritizes safety: Uses finality gadget (Casper FFG) - once block finalized, cannot be reverted even if chain splits. During network partition where neither side has 2/3 validators, network STOPS finalizing (liveness sacrificed) but never finalizes conflicting blocks (safety preserved). Attack scenarios - Bitcoin: Network partition causes temporary safety violation (two chains), but maintains liveness (keeps producing blocks). Ethereum: Network partition with <2/3 validators on either side halts finality (liveness violated) but maintains safety (no conflicting finalized blocks). For CBDC ($10T daily): MUST prioritize safety over liveness. Reason: Double-spending $10T is catastrophic, while temporary unavailability is acceptable. Design choices: (1) Use BFT consensus requiring 2/3 honest (Tendermint-style), (2) Absolute finality - no probabilistic, (3) Permissioned validators (central banks/major banks), (4) Sacrifice liveness during partition rather than risk conflicting transactions, (5) 1-3 second finality when available, (6) Circuit breaker halts system if partition detected. Trade-off: System may stop during network issues, but NEVER allows double-spend. This is opposite of Bitcoin's philosophy but correct for financial infrastructure.`,
  },
];
