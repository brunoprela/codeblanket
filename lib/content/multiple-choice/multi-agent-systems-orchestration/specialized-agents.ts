/**
 * Multiple choice questions for Specialized Agents section
 */

export const specializedagentsMultipleChoice = [
  {
    id: 'maas-spec-mc-1',
    question:
      'When designing system prompts for specialized agents, what is the MOST important principle for ensuring agents stay focused on their roles?',
    options: [
      'Make prompts as long as possible to cover every edge case',
      'Explicitly define what the agent SHOULD do and what it SHOULD NOT do',
      'Use the same prompt for all agents to maintain consistency',
      "Avoid giving examples, as they constrain the agent's creativity",
    ],
    correctAnswer: 1,
    explanation:
      "Explicitly defining boundaries (do's and don'ts) keeps agents focused. Example: \"You are a Code Agent. DO: Write code. DON'T: Modify requirements or make architectural decisions.\" This prevents role confusion. Option A is counterproductive—long prompts dilute focus and waste tokens. Option C defeats the purpose of specialization. Option D is incorrect—few-shot examples actually improve adherence to role.",
  },
  {
    id: 'maas-spec-mc-2',
    question:
      'A Testing Agent discovers bugs in code generated by a Code Agent. The Testing Agent\'s prompt says "find and fix bugs." What is the PRIMARY problem with this design?',
    options: [
      'The Testing Agent should only identify bugs, not fix them (role violation)',
      'Testing agents cannot effectively fix bugs without understanding the full codebase',
      "Fixing bugs requires architectural decisions that the Testing Agent isn't qualified to make",
      'The Code Agent should run the tests itself to avoid coordination overhead',
    ],
    correctAnswer: 0,
    explanation:
      'This is a role violation. The Testing Agent should report bugs; the Code Agent should fix them. Mixing roles creates confusion and makes it hard to track which agent is responsible for what. Options B and C are secondary concerns. Option D is wrong—separation of concerns (Code vs Test) is valuable; testing your own code is less effective.',
  },
  {
    id: 'maas-spec-mc-3',
    question:
      'You have a Documentation Agent that generates user-facing docs. Should this agent have access to the raw implementation code, or only to API specifications?',
    options: [
      'Raw code access is essential for accurate documentation',
      'Only API specs—raw code exposes implementation details that confuse users',
      'Both raw code and API specs for maximum flexibility',
      'Neither—the agent should infer documentation from user feedback',
    ],
    correctAnswer: 1,
    explanation:
      'Documentation Agent should work from API specs (public contracts), not raw code (implementation details). This keeps docs focused on what users need to know, not how things work internally. Option A risks documenting internals that change. Option C adds noise and temptation to over-document. Option D is impractical—feedback comes later, not during generation.',
  },
  {
    id: 'maas-spec-mc-4',
    question:
      'A Security Agent reviews code for vulnerabilities. It finds a potential SQL injection. What should the agent do?',
    options: [
      'Automatically fix the vulnerability and commit the change',
      'Report the vulnerability with severity, location, and recommended fix',
      'Block the deployment and require human review',
      'Ignore it if the code passed unit tests',
    ],
    correctAnswer: 1,
    explanation:
      "The Security Agent should report findings with actionable details, not make changes directly. Option A risks introducing new bugs or breaking functionality. Option C might be too aggressive (not all vulnerabilities are critical). Option D is dangerous—unit tests don't catch all security issues. The agent's role is to identify and inform, not to execute fixes.",
  },
  {
    id: 'maas-spec-mc-5',
    question:
      'You want to add an Optimization Agent that refactors code for performance. When in the workflow should this agent run?',
    options: [
      'Before the Code Agent, to set performance requirements',
      'In parallel with the Code Agent, providing real-time suggestions',
      'After the Code Agent and Testing Agent, once code is working',
      'Only when performance issues are detected in production',
    ],
    correctAnswer: 2,
    explanation:
      'Optimization should come after code is working and tested. Premature optimization is risky—you might optimize the wrong things or break functionality. Option A is backwards—requirements come first, but optimization is later. Option B creates conflicts (Code Agent and Optimization Agent modifying simultaneously). Option D is too late—better to optimize before deployment.',
  },
];
